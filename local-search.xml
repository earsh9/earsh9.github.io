<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前缀树</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/1.%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/1.%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="一次建树，多次查询"><a href="#一次建树，多次查询" class="headerlink" title="一次建树，多次查询"></a>一次建树，多次查询</h1><p>Trie [traɪ] 读音和 try 相同，它的另一些名字有：字典树，前缀树，单词查找树等。</p><p>Trie 是一种非典型的多叉树树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>其节点信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;      <span class="hljs-comment">//该结点是否是一个串的结束</span><br>    <span class="hljs-keyword">private</span> Trie[] children;        <span class="hljs-comment">//字母映射表</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>插入字符串</li></ol><p>从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p><ul><li>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</li><li>子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。</li><li>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</li></ul><ol start="2"><li>查找字符串 &#x2F; 查找字符串前缀</li></ol><p>从字典树的根开始，对于当前待搜索的字符串(前缀)，沿着指针依次遍历其孩子节点。若搜索到头了说明存在该前缀，对于搜索字符串还要验证 isEnd 是否为真。</p><h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a>208. 实现 Trie (前缀树)</h2><p>请你实现 Trie 类：</p><p>Trie() 初始化前缀树对象。</p><p>void insert(String word) 向前缀树中插入字符串 word 。</p><p>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</p><p>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//其实就是实现 26 叉树</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<br>    <span class="hljs-keyword">private</span> Trie[] next;          <span class="hljs-comment">//only lowerCase letter</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        isEnd = <span class="hljs-literal">false</span>;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;            <span class="hljs-comment">//指向当前对象的指针，即 Trie 的根节点</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = word.length(), ch; i &lt; len; i++)&#123;<br>            ch = word.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (cur.next[ch] == <span class="hljs-literal">null</span>)&#123;<br>                cur.next[ch] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            cur = cur.next[ch];<br>        &#125;<br>        cur.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//将 search() 和 startsWith() 合并成 searchPrefix() 方法</span><br>    <span class="hljs-keyword">public</span> Trie <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String prefix)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = prefix.length(), ch; i &lt; len; i++)&#123;<br>            ch = prefix.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;                     <span class="hljs-comment">//数组大小为26, 需计算索引值</span><br>            <span class="hljs-keyword">if</span> (cur.next[ch] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            cur = cur.next[ch];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.isEnd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="472-连接词"><a href="#472-连接词" class="headerlink" title="472.连接词"></a>472.连接词</h2><p>给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。</p><p>连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。</p><p>示例：</p><p>输入：words &#x3D; [“cat”,”cats”,”catsdogcats”,”dog”,”dogcatsdog”,”hippopotamuses”,”rat”,”ratcatdogcat”]</p><p>输出：[“catsdogcats”,”dogcatsdog”,”ratcatdogcat”]</p><p>解释：</p><p>“catsdogcats” 由 “cats”, “dog” 和 “cats” 组成;</p><p>“dogcatsdog” 由 “dog”, “cats” 和 “dog” 组成;</p><p>“ratcatdogcat” 由 “rat”, “cat”, “dog” 和 “cat” 组成。</p><h3 id="前缀树-dfs-记忆化搜索"><a href="#前缀树-dfs-记忆化搜索" class="headerlink" title="前缀树 + dfs 记忆化搜索"></a>前缀树 + dfs 记忆化搜索</h3><ul><li>将字符串数组 words 按 字符串长度 升序排列，跳过空串。</li><li>排序好后按序遍历，若当前字符串存在由两个及以上的短单词构成，则加入 answer，反之加入前缀树</li><li>如何查找存在？dfs</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isEnd;<br>    <span class="hljs-keyword">public</span> Trie[] children;<br><br>    Trie()&#123;<br>        isEnd = <span class="hljs-literal">false</span>;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-type">Trie</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findAllConcatenatedWordsInADict0</span><span class="hljs-params">(String[] words)</span> &#123;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(words, (o1, o2) -&gt; o1.length() - o2.length());<br><br>    <span class="hljs-keyword">for</span> (String word : words) &#123;<br>        <span class="hljs-keyword">if</span> (word.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">//0 &lt;= word[i].length</span><br>        <span class="hljs-type">boolean</span>[] visit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[word.length()];       <span class="hljs-comment">//创建与当前单词长度相同的标记数组</span><br>        <span class="hljs-keyword">if</span> (dfs(word, <span class="hljs-number">0</span>, visit))&#123;<br>            ans.add(word);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            insert(word);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> st, <span class="hljs-type">boolean</span>[] vis)</span>&#123;        <span class="hljs-comment">//验证当前单词是否完全由 前缀树 中其他两个及以上单词组成</span><br>    <span class="hljs-keyword">if</span> (s.length() == st) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (vis[st]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;          <span class="hljs-comment">//若一个下标已经被访问过，则该下标一定不是若一个或多个短单词构成（否则上一次访问时已经判定该单词为连接词了）</span><br><br>    vis[st] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        node = node.children[idx];<br><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (node.isEnd)&#123;<br>            <span class="hljs-keyword">if</span> (dfs(s, i + <span class="hljs-number">1</span>, vis)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String s)</span>&#123;<br>    <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.toCharArray()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (node.children[idx] == <span class="hljs-literal">null</span>)&#123;<br>            node.children[idx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>        &#125;<br>        node = node.children[idx];<br>    &#125;<br>    node.isEnd = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>dp 解法 见 9.动态规划 - 5.其他类型dp</li></ul>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/2.%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/2.%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="解决一些元素分组的问题"><a href="#解决一些元素分组的问题" class="headerlink" title="解决一些元素分组的问题"></a>解决一些元素分组的问题</h1><p><a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></p><p>它管理一系列不相交的集合，并支持两种操作：</p><ul><li>合并（Union）：把两个不相交的集合合并为一个集合。</li><li>查询（Find）：查询两个元素是否在同一个集合中。</li></ul><h2 id="并查集的重要思想在于，用集合中的一个元素代表集合"><a href="#并查集的重要思想在于，用集合中的一个元素代表集合" class="headerlink" title="并查集的重要思想在于，用集合中的一个元素代表集合"></a>并查集的重要思想在于，用集合中的一个元素代表集合</h2><ul><li>一个有趣的比喻：把集合比喻成帮派，而代表元素则是帮主。<ul><li>初始化：所有大侠各自为战。他们各自的帮主自然就是自己。</li><li>两个元素想要单挑（合并）时，先找到其各自的帮主进行合并。</li><li>要寻找集合的代表元素，只需要一层一层往上访问父节点（图中箭头所指的圆），直达树的根节点（图中橙色的圆）即可。根节点的父节点是它自己。我们可以直接把它画成一棵树：</li></ul></li></ul><img src = "https://pic2.zhimg.com/80/v2-cca3ddf5806a221201ed78caf1d27041_1440w.jpg" width = 50%><ul><li>初始化<ul><li>假如有编号为1, 2, 3, …, n的n个元素，用一个数组fa[]来存储每个元素的父节点（每个元素有且仅有一个父节点），一开始先将它们的父节点设为自己。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] fa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[MAXN];<br>inline <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123;<br>        fa[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>查询<ul><li>递归的实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">inline <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x] == x)&#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> find(fa[x]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>合并<ul><li>先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">inline <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>    fa[find(i)] = find(j);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>上述简单的并查集效率过低，出现的链式结构越长，从底部找到根节点就越慢。</p><p>只关心一个元素对应的根节点 -&gt; 每个元素到根节点的路径尽可能短，最好只需要一步 -&gt; 在查询过程中，沿途将每个节点的父节点设为根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//合并（路径压缩）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(x == fa[x]) reutrn x;<br>    <span class="hljs-keyword">else</span>&#123;<br>        fa[x] = find(fa[x]);     <span class="hljs-comment">//父节点设为根节点</span><br>        <span class="hljs-keyword">return</span> fa[x];            <span class="hljs-comment">//返回父节点</span><br>    &#125;<br><br>    <span class="hljs-comment">//简写为一行：赋值运算符 = 的优先级没有三元运算符 ?: 高，要加括号</span><br>    <span class="hljs-keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>考虑一颗复杂的树 与 一个单一元素的合并：</p><img src = "https://pic2.zhimg.com/80/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_1440w.jpg" width = 50%><ul><li><p>假如这时我们要merge(7,8)，如果我们可以选择的话，是把7的父节点设为8好，还是把8的父节点设为7好呢？</p><ul><li><p>如果把 7 的父节点设为 8，会使树的深度（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长，寻找根节点的路径也相应变长。</p></li><li><p>而把 8 的父节点设为 7，不会有上述问题。</p></li></ul></li><li><p>这启示我们：要把简单的树往复杂的树上合并。</p></li><li><p>用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的子树的深度）。</p><ul><li><p>一开始，把所有元素的rank（秩）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p></li><li><p>路径压缩和按秩合并如果一起使用，时间复杂度接近 O(n) ，但很可能会破坏rank的准确性。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 按秩合并</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        fa[i] = i;<br>        rank[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> find(i), y = find(j);     <span class="hljs-comment">//先找父节点</span><br>    <span class="hljs-keyword">if</span>(rank[x] &lt;= rank[y])&#123;<br>        fa[x] = y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        fa[y] = x;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(rank[x] == rank[y] &amp;&amp; x != y)&#123;   <span class="hljs-comment">//如果深度相同且根节点不同，则新的根节点的深度+1 (画个图就懂了)</span><br>        rank[y]++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>练习：- 1020.飞地的数量</p>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树状数组&amp;线段树</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/3.%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/3.%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="单点修改-与-区间查询"><a href="#单点修改-与-区间查询" class="headerlink" title="单点修改 与 区间查询"></a>单点修改 与 区间查询</h1><ul><li>单点修改：更改数组中一个元素的值</li><li>区间查询：查询一个区间内所有元素的和</li></ul><h2 id="3-树状数组（Binary-Index-Tree-BIT）：折中-x2F-均衡的完成这两件事"><a href="#3-树状数组（Binary-Index-Tree-BIT）：折中-x2F-均衡的完成这两件事" class="headerlink" title="3.树状数组（Binary Index Tree, BIT）：折中&#x2F;均衡的完成这两件事"></a>3.树状数组（Binary Index Tree, BIT）：折中&#x2F;均衡的完成这两件事</h2><p>最简单的树状数组支持这两种操作，时间复杂度均为 logn ：</p><p>和前缀和数组一样的想法，区间 [a,b] 的和 等于 [1,b] - [1,a)。问题转化为求前 n 项和</p><ul><li><p>用一个数组 C 维护若干个小区间：</p><ul><li><p>单点修改时，只更新包含这一元素的区间；</p></li><li><p>求前n项和时，通过将区间进行组合，得到从1到n的区间，然后对所有用到的区间求和。</p></li><li><p>设原数组是 A，如果 Ci 维护的区间是 [Ai,Ai]，此结构就相当于普通数组（还浪费了一倍内存）；如果 Ci 维护的区间就是 [1,Ai] ，此结构就相当于前缀和。</p></li></ul></li><li><p>BIT 直译为 “二进制下标树”，说明与二进制息息相关。对于树状数组 C 中的任意下标 x：</p><ul><li><p>其能掌管的原数组 A 的区间和为：[x - lowbit(x) + 1, x]。这里取区间双闭，若想左开右闭，去掉 +1 即可。</p></li><li><p>lowbit()：x &amp; (-x)；（-x 为 x 的补码）；若 x 最低一位为1的位数是 i，返回 2 ^ i</p></li></ul></li><li><p>例如：C[1] &#x3D; A[1,1]、C[2] &#x3D; A[1,2]、C[3] &#x3D; A[3,3]、C[4] &#x3D; A[1,4]、C[5] &#x3D; A[5,5]、C[6] &#x3D; A[5,6]、C[7] &#x3D; A[7,7]、C[8] &#x3D; A[1,8]</p><ul><li><p>可以看出奇数下标只管自己这一位的和，因为奇数的 lowbit 为 1，-1+1 直接抵消</p></li><li><p>而偶数下标，像 2、4、8 这种只有一位是 1 的偶数，作差后直接掌管从头到它为止所有数的加和</p></li></ul></li><li><p>画成图就形如一颗二叉树，故此而得名。</p></li></ul><img src = "https://pic2.zhimg.com/80/v2-39ac61747342a733bf7acf913213a681_720w.jpg"><h3 id="操作：单点修改、前-n-项和、区间查询"><a href="#操作：单点修改、前-n-项和、区间查询" class="headerlink" title="操作：单点修改、前 n 项和、区间查询"></a>操作：单点修改、前 n 项和、区间查询</h3><p>将数组中位置在 i 处的数字，数值加 x</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> i; pos &lt; n; pos += lowbit(pos))&#123;<br>    tree[pos] += x;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求取前 n 项和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> n; pos &gt; <span class="hljs-number">0</span>; pos -= lowbit(pos))&#123;<br>    ans += tree[pos];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询区间 [a,b] 之间的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>  <span class="hljs-keyword">return</span> query(b) - query(a - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的模板题：</p><ul><li>307.区域和检索 - 数组可修改</li><li>检查区间 [left,right] 中的每个数是否被 ranges 中的数组 [a,b] 所覆盖过<ul><li>树状数组 + 去重处理</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">55</span>; <span class="hljs-comment">//数据范围有限</span><br><span class="hljs-type">int</span>[] tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowBit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br><span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span>&#123; <span class="hljs-comment">//给位置 i 处的数值 +x</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> i; pos &lt; n; pos += lowBit(pos))&#123;<br>  tree[pos] += x;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123; <span class="hljs-comment">//查询区间 [0,x] 的数值和</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> x; pos &gt; <span class="hljs-number">0</span>; pos -= lowBit(pos))&#123;<br>  sum += tree[pos];<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCovered</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] ranges, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <span class="hljs-comment">//去重，让区间内的数仅覆盖一次</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] r : ranges)&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> r[<span class="hljs-number">0</span>], b = r[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a; i &lt;= b; i++)&#123;<br>  <span class="hljs-keyword">if</span>(set.add(i))&#123;<br>    add(i, <span class="hljs-number">1</span>); <span class="hljs-comment">//进行区间标记覆盖，1代表存在0代表未被覆盖</span><br>  &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> right - left + <span class="hljs-number">1</span>, count = query(right) - query(left - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> len == count;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-线段树（segment-tree）"><a href="#4-线段树（segment-tree）" class="headerlink" title="4.线段树（segment tree）"></a>4.线段树（segment tree）</h2><ul><li><p>定义</p><ul><li><p>用来存放给定区间内对应信息的一种数据结构</p></li><li><p>与树状数组相同，单点修改(update)和区间求和(range query)的时间复杂度都为 o(logn)</p></li><li><p>不同的是还能进行区间最大值，区间最小值（Range Minimum&#x2F;Maximum Query problem）或者区间异或值的查询</p></li></ul></li><li><p>实现原理</p><ul><li><p><strong>数组</strong>：（与数组实现堆(heap)类似）用一个<strong>完全二叉树</strong>来存储对应于其每一个区间（segment）的数据</p><ul><li>索引从 1 开始，对于任意节点 i，其左子节点为 2<em>i，右子节点为 2</em>i+1，父节点为 i&#x2F;2</li></ul></li><li><p><strong>链表</strong>：</p><ul><li><p>动态开点，自顶向下初始化建树</p></li><li><p><strong>每一个结点中保存着相对应于这一个区间的信息：根节点保存[0,n)的和，叶子节点只存储单个元素信息，中间节点存储一段区间的信息（可以是区间和、区间最大值等…）</strong></p></li></ul></li></ul></li><li><p>实现步骤</p><ul><li><p>初始化建树</p><ul><li><p><strong>自顶向下</strong>构建，从根节点（保存数组 [0,n) 或者 [1,n] 的信息）二分向下按层构建</p></li><li><p>对于链表实现形式，只用创建根节点即可。随用随创建（lazyCreate）</p></li></ul></li><li><p>查询 query 和 修改 update 操作：</p><ul><li><p>自顶向下（不断 dfs 的过程）pushDown（将父节点保存的add懒标记信息传给孩子节点）</p></li><li><p>递归到叶子节点时，再 pushUp</p><ul><li>按照不同的需求，对应两个子结点的数据相应的来构建存储于它们母结点中的值（取sum、max、min等…）</li></ul></li></ul></li></ul></li></ul><p>例如对于给定数组[1,5,3,7,3,2,5,7]，其最小值线段树为：</p><img src = "https://upload-images.jianshu.io/upload_images/2112205-c8f57e983e932332.png?imageMogr2/auto-orient/strip|imageView2/2/w/622/format/webp"><p>以及每一个结点代表的区间为：</p><img src = "https://upload-images.jianshu.io/upload_images/2112205-60ffce49e8afc056.png?imageMogr2/auto-orient/strip|imageView2/2/w/1114/format/webp"><ul><li><p>单点修改(update)</p><ul><li>当输入数组中位于i位置的元素被更新时，我们只需从这一元素对应的叶子结点开始，沿二叉树的路径向上更新至根结点即可。（一个 dfs）</li></ul></li><li><p>区间查询</p><ul><li><p>若当前结点所代表的区间完全位于给定需要被查询的区间之外，则不考虑</p></li><li><p>若完全位于给定需要被查询的区间之内，返回节点的值参与求和</p></li><li><p>若部分位于需要被查询的区间之内，考虑区间内的（注意总有可能找到完全位于区间内的结点，因为叶子结点的区间长度为1，因此我们总能组合出合适的区间）</p></li></ul></li></ul><h3 id="307-的线段树实现（基于数组实现）"><a href="#307-的线段树实现（基于数组实现）" class="headerlink" title="307.的线段树实现（基于数组实现）"></a>307.的线段树实现（基于数组实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>  <span class="hljs-comment">//线段树</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> left, right, val;<br>    Node(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)&#123;<br>      <span class="hljs-built_in">this</span>.left = left;<br>      <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>  &#125;<br><br>  Node[] segTree;<br>  <span class="hljs-type">int</span>[] nums;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-built_in">this</span>.nums = nums;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    segTree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">4</span> * n];<br>    build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) update(<span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, nums[i]);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;    <span class="hljs-comment">//将 nums[index] 的值更新为 val</span><br>    update(<span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>, val - nums[index]);<br>    nums[index] = val;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">return</span> query(<span class="hljs-number">1</span>, left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>);     <span class="hljs-comment">//因为节点从 1 开始</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123; <span class="hljs-comment">//初始化建树：从编号为 u 的节点开始，构造范围为 [l,r] 的树节点</span><br>    segTree[u] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(l,r);<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    build(u &lt;&lt; <span class="hljs-number">1</span>, l, mid);<span class="hljs-comment">//左右子节点继续构建</span><br>    build(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span>&#123;  <span class="hljs-comment">//从编号为 u 的节点开始，在 x 位置增加 v</span><br>    <span class="hljs-keyword">if</span> (segTree[u].left == x &amp;&amp; segTree[u].right == x)&#123; <span class="hljs-comment">//走到叶子节点本身了即可返回</span><br>      segTree[u].val += v;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> segTree[u].left + segTree[u].right &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid) update(u &lt;&lt; <span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-keyword">else</span> update(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, x, v);<br>    pushUp(u);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;    <span class="hljs-comment">//从编号为 u 的节点开始，查询 [l,r] 区间和为多少</span><br>    <span class="hljs-keyword">if</span> (l &lt;= segTree[u].left &amp;&amp; segTree[u].right &lt;= r) <span class="hljs-keyword">return</span> segTree[u].val;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> segTree[u].left + segTree[u].right &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid) ans += query(u &lt;&lt; <span class="hljs-number">1</span>, l, r);   <span class="hljs-comment">//如果 mid &gt;= l,说明区间有一部分和在左子树</span><br>    <span class="hljs-keyword">if</span> (mid &lt; r) ans += query(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<span class="hljs-comment">//同理如果 mid + 1 &lt;= r -&gt; mid &lt; r,有部分区间和在右子树</span><br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>&#123;  <span class="hljs-comment">//子节点向上更新父节点,这里实现的是求和操作</span><br>    segTree[u].val = segTree[u &lt;&lt; <span class="hljs-number">1</span>].val + segTree[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].val;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="732-我的日程安排表-I（链表实现动态开点）"><a href="#732-我的日程安排表-I（链表实现动态开点）" class="headerlink" title="732.我的日程安排表 I（链表实现动态开点）"></a>732.我的日程安排表 I（链表实现动态开点）</h3><p>对一区间 [start,end) 进行判断是否与现有区间重叠，若没有则添加到日程表中return true，反之return false</p><p>由于数据范围为 [0,1e9] 遂使用链表实现动态开点，按需创建区间，而非像数组那样一来就开 4n 的空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    Node lc, rc;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;      <span class="hljs-comment">//懒标记、记录当前节点所管理的区间的最大重叠个数</span><br>    Node()&#123; &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) <span class="hljs-number">1e9</span>;<br><span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<span class="hljs-comment">//给定数据范围为 [0,N]</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> st, <span class="hljs-type">int</span> ed)</span>&#123;  <span class="hljs-comment">//查询</span><br>    <span class="hljs-keyword">if</span> (st &lt;= left &amp;&amp; right &lt;= ed) <span class="hljs-keyword">return</span> node.max;<br>    lazyCreate(node);         <span class="hljs-comment">//用之前先创建</span><br>    pushDown(node);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + right &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (st &lt;= mid) ans = Math.max(ans, query(node.lc, left, mid, st, ed));<br>    <span class="hljs-keyword">if</span> (ed &gt;= mid + <span class="hljs-number">1</span>) ans = Math.max(ans, query(node.rc, mid + <span class="hljs-number">1</span>, right, st, ed));<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> st, <span class="hljs-type">int</span> ed)</span>&#123; <span class="hljs-comment">//修改（还可以有形参 v 标记修改的数值）</span><br>    <span class="hljs-keyword">if</span> (st &lt;= left &amp;&amp; right &lt;= ed)&#123;<br>        node.add += <span class="hljs-number">1</span>;<br>        node.max += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    lazyCreate(node);<br>    pushDown(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + right &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (st &lt;= mid) update(node.lc, left, mid, st, ed);<br>    <span class="hljs-keyword">if</span> (ed &gt;= mid + <span class="hljs-number">1</span>) update(node.rc, mid + <span class="hljs-number">1</span>, right, st, ed);<br>    pushUp(node);           <span class="hljs-comment">//自底向上逐层更新结果</span><br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">lazyCreate</span><span class="hljs-params">(Node node)</span>&#123;<br>    <span class="hljs-keyword">if</span> (node.lc == <span class="hljs-literal">null</span>)&#123;<br>        node.lc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node.rc == <span class="hljs-literal">null</span>)&#123;<br>        node.rc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">pushDown</span><span class="hljs-params">(Node node)</span>&#123;  <span class="hljs-comment">//add标记了当前区间内所有元素共有的属性，当要向下新建节点时需继承给孩子节点</span><br>    node.lc.add += node.add;node.rc.add += node.add;<br>    node.lc.max += node.add;node.rc.max += node.add;<br>    node.add = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">pushUp</span><span class="hljs-params">(Node node)</span>&#123;<br>    node.max = Math.max(node.lc.max, node.rc.max);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;    <span class="hljs-comment">//根据不同需求实现不同方法</span><br>    <span class="hljs-keyword">if</span> (query(root, <span class="hljs-number">1</span>, N + <span class="hljs-number">1</span>,start + <span class="hljs-number">1</span>, end) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    update(root, <span class="hljs-number">1</span>, N + <span class="hljs-number">1</span>,start + <span class="hljs-number">1</span>, end);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h3><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><p>示例 1：</p><p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</p><p>输出：6</p><p>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><p><strong>可以采用动态规划 O(n) 求解，这里给出分治解法（可用于解决任意子区间的问题）：</strong></p><h3 id="线段树-区间合并法-解决多次询问的「区间最长连续上升序列问题」和「区间最大子段和问题」"><a href="#线段树-区间合并法-解决多次询问的「区间最长连续上升序列问题」和「区间最大子段和问题」" class="headerlink" title="线段树 区间合并法 解决多次询问的「区间最长连续上升序列问题」和「区间最大子段和问题」"></a>线段树 区间合并法 解决多次询问的「区间最长连续上升序列问题」和「区间最大子段和问题」</h3><h4 id="求解最长公共上升子序列的-pushUp-操作"><a href="#求解最长公共上升子序列的-pushUp-操作" class="headerlink" title="求解最长公共上升子序列的 pushUp 操作"></a>求解最长公共上升子序列的 pushUp 操作</h4><ol><li><p>定义一个操作 get(a, l, r) 表示查询 a 序列 [l, r] 区间内的最大子段和。</p><ul><li>本题就是 get(nums, 0, nums.length - 1)</li></ul></li><li><p>如何分治？对于一个区间 [l, r]，取 m &#x3D; (l + r) &#x2F; 2</p><ul><li><p>对区间 [l, m] 和 [m + 1, r] 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开始回升」。</p></li><li><p>考虑如何通过 [l, m] 区间的信息和 [m + 1, r] 区间的信息合并成区间 [l, r] 的信息。</p></li></ul></li><li><p>对于一个区间 [l, r]，维护四个量：</p><ul><li><p>lSum 表示 [l, r] 内以 l 为左端点的最大子段和</p></li><li><p>rSum 表示 [l, r] 内以 r 为右端点的最大子段和</p></li><li><p>mSum 表示 [l, r] 内的最大子段和</p></li><li><p>iSum 表示 [l, r] 的区间和</p></li></ul></li><li><p>如何从 [l, m] （左子区间）和 [m + 1, r] （右子区间）的信息 合并到 [l, r]？</p><ul><li><p>iSum 最容易，直接相加</p></li><li><p>lSum 考虑 max（左子区间的 lSum 、左子区间和 iSum + 右子区间 lSum）。rSum 同理。</p></li><li><p>mSum：考虑是否会跨越区间中间值 m ：(前两个不会，最后一个会)</p></li><li><p>max( 左子区间的 mSum、右子区间的 mSum、左子区间的 rSum + 右子区间的 lSum)</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Status</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> lSum, rSum, mSum, iSum;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Status</span><span class="hljs-params">(<span class="hljs-type">int</span> lSum, <span class="hljs-type">int</span> rSum, <span class="hljs-type">int</span> mSum, <span class="hljs-type">int</span> iSum)</span>&#123;<br>    <span class="hljs-built_in">this</span>.lSum = lSum;<br>    <span class="hljs-built_in">this</span>.rSum = rSum;<br>    <span class="hljs-built_in">this</span>.mSum = mSum;<br>    <span class="hljs-built_in">this</span>.iSum = iSum;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>  <span class="hljs-keyword">return</span> getInfo(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>).mSum;<br>&#125;<br><br><span class="hljs-keyword">public</span> Status <span class="hljs-title function_">getInfo</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>  <span class="hljs-keyword">if</span>(l == r)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Status</span>(nums[l], nums[l], nums[l], nums[l]);<br>  &#125;<br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>  <span class="hljs-type">Status</span> <span class="hljs-variable">lSub</span> <span class="hljs-operator">=</span> getInfo(nums, l, m);<br>  <span class="hljs-type">Status</span> <span class="hljs-variable">rSub</span> <span class="hljs-operator">=</span> getInfo(nums, m + <span class="hljs-number">1</span>, r);<br>  <span class="hljs-keyword">return</span> pushUp(lSub, rSub);<br>&#125;<br><br><span class="hljs-keyword">public</span> Status <span class="hljs-title function_">pushUp</span> <span class="hljs-params">(Status l, Status r)</span>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">iSum</span> <span class="hljs-operator">=</span> l.iSum + r.iSum;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">lSum</span> <span class="hljs-operator">=</span> Math.max(l.lSum, l.iSum + r.lSum);<br>  <span class="hljs-type">int</span> <span class="hljs-variable">rSum</span> <span class="hljs-operator">=</span> Math.max(r.rSum, l.rSum + r.iSum);<br>  <span class="hljs-type">int</span> <span class="hljs-variable">mSum</span> <span class="hljs-operator">=</span> Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Status</span>(lSum, rSum, mSum, iSum);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>状态树</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/4.%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/4.%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><p>在状态转化时统计答案，最后一项统计不到时特殊处理</p><h2 id="845-数组中的最长山脉"><a href="#845-数组中的最长山脉" class="headerlink" title="845. 数组中的最长山脉"></a>845. 数组中的最长山脉</h2><p>把符合下列属性的数组 arr 称为 山脉数组 ：</p><p>arr.length &gt;&#x3D; 3</p><p>存在下标 i（0 &lt; i &lt; arr.length - 1），满足</p><p>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]</p><p>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]</p><p>给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。</p><p>示例 1：</p><p>输入：arr &#x3D; [2,1,4,7,3,2,5]</p><p>输出：5</p><p>解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。</p><p><strong>方法：</strong></p><ol><li>前缀和 &#x2F; 动规：枚举山顶，统计每个点左右两边单增和单减的个数。时间和空间均O(n)</li><li>暴力枚举山顶，在满足山顶条件的情况下由中心向两边扩张。时间O(n)空间O(1)</li><li>有限状态机：在切换状态时再统计答案</li><li>官解还枚举了山脚，从左山脚走到山顶再走到右山脚</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestMountain</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length, ans = <span class="hljs-number">0</span>, status = <span class="hljs-number">0</span>, l = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span> (status == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i + <span class="hljs-number">1</span>])&#123;<br>                status = <span class="hljs-number">1</span>;                         <span class="hljs-comment">//上升状态</span><br>                l = i;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>])&#123;<br>                status = <span class="hljs-number">2</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] == arr[i + <span class="hljs-number">1</span>])&#123;<br>                status = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[i + <span class="hljs-number">1</span>])&#123;<br>                ans = Math.max(ans, i - l + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i + <span class="hljs-number">1</span>])&#123;<br>                    status = <span class="hljs-number">1</span>;<br>                    l = i;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    status = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span> (status == <span class="hljs-number">2</span>) ans = Math.max(ans, n - l);  <span class="hljs-comment">//最后一项遍历不到，特别处理</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/5.%E6%8E%92%E5%BA%8F/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/5.%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="实现快排（分治思想）"><a href="#实现快排（分治思想）" class="headerlink" title="实现快排（分治思想）"></a>实现快排（分治思想）</h2><p><a href="http://data.biancheng.net/view/117.html">http://data.biancheng.net/view/117.html</a></p><p><strong>一句话总结：先将一个元素排好序，然后再将剩下的元素排好序。</strong></p><p>快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。</p><p>给定一组乱序数字，如6，7，5，3，4，8，6，10，7，1</p><ol><li><p>在待排序的数列中，选取一个数作为<strong>基准数</strong>（一般为了方便选取第一个数）(而为了不出现在最坏的情况，可以随机选取）。</p></li><li><p>在待排序的数列中将小于基准数的数字移到其左边，大于的移到其右边，相等的数字不作移动。</p><ul><li><strong>从右向左</strong>找比基准数<strong>小</strong>的，<strong>从左向右</strong>找比基准数<strong>大</strong>的。</li></ul></li><li><p>此时左右分区的元素就相对有序了，继续分区然后移动，直到各个区只有一个数字为止。</p></li><li><p>交换的时候可以用swap()，也可以采用赋值的方式。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> st, <span class="hljs-type">int</span> ed)</span>&#123;<br>    <span class="hljs-keyword">if</span> (st &gt;= ed) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> nums[st];<br>    System.out.println(key);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st, j = ed;            <span class="hljs-comment">//i从左往右,j从右往前</span><br><br>    <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt; key)&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; j)&#123;                 <span class="hljs-comment">//确保跳出循环后是找见了合适的值才交换</span><br>            nums[i] = nums[j];<br>            i++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= key)&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>            nums[j] = nums[i];<br>            j--;<br>        &#125;<br>    &#125;<br>    nums[i] = key;               <span class="hljs-comment">//跳出循环时i=j,把key的值赋回去</span><br>    quickSort(nums,st,i-<span class="hljs-number">1</span>);<br>    quickSort(nums,i+<span class="hljs-number">1</span>,ed);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>最坏的情况是每次比较都需要交换，时间复杂度为o(n^2),即数组越规整越耗时；但此种情况并不常见，一般认为**时间复杂度为o(nlogn)**。</p></li><li><p>快排是在原始数组上进行修改，所占空间为常数级；但递归调用会占用栈，可以认为**空间复杂度为o(logn)**；最坏情况为每次只完成了一个元素，o(n)。</p></li><li><p>从另一个角度理解快排：</p><ul><li><p><strong>快排就是一个建立 二叉搜索树 的过程，其运作过程形如 BST的前序遍历。</strong></p></li><li><p>假设数组元素为 N，每一层的元素个数之和为 O(N)，分界点分布均匀的理想情况下，树高为 O(logN)。</p></li></ul></li></ol><img src = "https://mmbiz.qpic.cn/sz_mmbiz_gif/gibkIz0MVqdGZy8ttAE2M0GxYNH54ibyAfn2jDiaSNzia8GYnnIkeJTLuKMO6VFLMjrUrRXw5v9RDVG6awlNjPl0xA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1"><h3 id="快排的变体-gt-快速选择"><a href="#快排的变体-gt-快速选择" class="headerlink" title="快排的变体 -&gt; 快速选择"></a>快排的变体 -&gt; 快速选择</h3><p><a href="https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ">https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ</a></p><h4 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h4><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k &#x3D; 2</p><p>输出: 5</p><p><strong>思路：</strong></p><ol><li><p>因为快排每一次都能将一个元素放置到正确的位置 p，使得 nums[p] 左边的数比它小，右边的比它大。</p></li><li><p>即使整体数组并未完全排好序，但也可以先与 k 进行比较，每次缩小一半的排序范围。</p></li><li><p>随机化的快速选择算法可以认为时间复杂度为 O(N)，高效很多。(N + N&#x2F;2 + N&#x2F;4 + N&#x2F;8 +…)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">return</span> quickSelect(nums, nums.length - k, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);   <span class="hljs-comment">//转成求解第 n - k 小的数字</span><br>&#125;<br><br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quickSelect</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> random.nextInt(right - left + <span class="hljs-number">1</span>) + left;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> nums[idx];<br>    nums[idx] = nums[left];                         <span class="hljs-comment">//idx 处的值已经被 key 记录了</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> left, r = right;<br>    <span class="hljs-keyword">while</span> (l &lt; r)&#123;<br>        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] &gt; key) r--;<br>        nums[l] = nums[r];<br>        <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] &lt;= key) l++;<br>        nums[r] = nums[l];<br>    &#125;<br>    nums[l] = key;<br>    <span class="hljs-keyword">if</span> (l == k) <span class="hljs-keyword">return</span> nums[l];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &lt; k) <span class="hljs-keyword">return</span> quickSelect(nums, k, l + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> quickSelect(nums, k, left, l - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用数组实现-二叉堆"><a href="#用数组实现-二叉堆" class="headerlink" title="用数组实现 二叉堆"></a>用数组实现 二叉堆</h2><ul><li><p>二叉堆是一种 完全二叉树，存储在数组中</p><ul><li><p>一般的链表二叉树，操作节点的指针；在数组中，将数组索引作为指针。</p></li><li><p><strong>数组的第一个索引 0 空着不用</strong></p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父节点的索引</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">parent</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> &#123;<br>    <span class="hljs-keyword">return</span> root / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 左孩子的索引</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">left</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> &#123;<br>    <span class="hljs-keyword">return</span> root * <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 右孩子的索引</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">right</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> &#123;<br>    <span class="hljs-keyword">return</span> root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src = "https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4mUHfudscMxeMy4rhspM1RByASfhbw8hO6fTicKwwicReawGVHhbX7Kmnhw1FAykVdXVt4nibDtSwIdA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" width = "75%"><ul><li><p>分为 大根堆 和 小根堆，<strong>核心操作为 上浮 swim 和下沉 sink</strong>。</p></li><li><p>优先级队列：</p><ul><li><p>在插入和删除元素的时候，会自动实现元素排序，底层实现就是二叉堆。</p></li><li><p>主要操作：insert 插入一个元素、delMax（delMin）删除最大（最小）元素。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处使用泛型 Key 表示任何一种可以比较大小的数据结构。实现大根堆</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxPQ</span><br>    &lt;Key <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Key&gt;&gt;&#123;<br>        <span class="hljs-keyword">private</span> Key[] pq;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MaxPQ</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>            pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Key</span>[capacity + <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Key <span class="hljs-title function_">max</span><span class="hljs-params">()</span> <span class="hljs-keyword">return</span> pq[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Key e)</span>&#123;...&#125;<br><br>        <span class="hljs-comment">//删除并返回当前队列中的最大元素</span><br>        <span class="hljs-keyword">public</span> Key <span class="hljs-title function_">delMax</span><span class="hljs-params">()</span>&#123;...&#125;<br><br>        <span class="hljs-comment">//上浮第 k 个元素以维护最大堆的性质</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;...&#125;<br><br>        <span class="hljs-comment">//下沉第 k 个元素以维护最大堆的性质</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;...&#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;    <span class="hljs-comment">//交换数组的两个元素</span><br>            <span class="hljs-type">Key</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> pq[i];<br>            pq[i] = pq[j];<br>            pq[j] = tmp;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSmaller</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;    <span class="hljs-comment">//pq[i] 是否比 pq[j] 小</span><br>            <span class="hljs-keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//还有 left，right，parent 三种方法</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="实现-swim-和-sink"><a href="#实现-swim-和-sink" class="headerlink" title="实现 swim 和 sink"></a>实现 swim 和 sink</h3><ul><li><p>对于最大堆，何时需要恢复堆的性质？</p><ul><li><p>某节点 A 比其子节点小，需要对 A 进行<strong>下沉</strong>，让比它大的节点上来做父节点。</p></li><li><p>某节点 A 比其父节点大，应该对 A 进行<strong>上浮</strong>，自己去做父节点。</p></li><li><p>对于错位的节点需进行多次上浮 或者 下沉操作，使用 <strong>while</strong> 进行模拟。</p></li></ul></li><li><p>上浮：与父节点进行比较和交换</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-comment">//上浮到堆顶，不能再上浮</span><br>    <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">1</span> &amp;&amp; isSmaller(parent(k), k))&#123;<br>        exchange(parent(k), k);<br>        k = parent(k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>下沉：需要和两个孩子节点进行比较，如果 A 不是最大的就需要和 较大的子节点进行交换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-comment">//沉到堆底，就沉不下去了</span><br>    <span class="hljs-keyword">while</span>(left(k) &lt;= N)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">older</span> <span class="hljs-operator">=</span> left(k);                    <span class="hljs-comment">//假设左节点较大</span><br>        <span class="hljs-keyword">if</span>(right(k) &lt;= N &amp;&amp; isSmaller(older, right(k)))&#123;        <span class="hljs-comment">//若右节点存在，比较大小</span><br>            older = right(k);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(isSmaller(older, k)) <span class="hljs-keyword">break</span>;         <span class="hljs-comment">//older 为孩子节点中的较大者，如果 K 比俩孩子都大，不用沉了</span><br>        exchange(k, older);<br>        k = older;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-delMax-和-insert"><a href="#实现-delMax-和-insert" class="headerlink" title="实现 delMax 和 insert"></a>实现 delMax 和 insert</h3><ul><li>insert方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Key e)</span>&#123;<br>    N++;<br>    pq[N] = e;<br>    swim(N);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>delMax方法先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Key <span class="hljs-title function_">delMax</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Key</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> pq[<span class="hljs-number">1</span>];            <span class="hljs-comment">//标记大根堆的最大元素</span><br>    exchange(<span class="hljs-number">1</span>, N);             <span class="hljs-comment">//与堆底元素对调</span><br>    pq[N] = <span class="hljs-literal">null</span>;               <span class="hljs-comment">//删除 A</span><br>    N--;<br>    sink(<span class="hljs-number">1</span>);                    <span class="hljs-comment">//让 B 下沉</span><br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="附上一个215题实现"><a href="#附上一个215题实现" class="headerlink" title="附上一个215题实现"></a>附上一个215题实现</h3><ul><li>时间复杂度：由于堆的大小不会超过 k，插入和删除都是 O(k)，加外层 for 循环 -&gt; O(Nlogk)</li><li>空间复杂度：O(k)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用数组实现小根堆</span><br><span class="hljs-comment">//维护一个大小为 k 的堆，当堆的大小超过 k 时删除堆顶元素。最后堆顶元素即为当前第 k 大的元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">minPQ</span> <span class="hljs-variable">minPQ</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">minPQ</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        minPQ.insert(num);<br>        <span class="hljs-keyword">if</span> (minPQ.N &gt; k) minPQ.delMin();<br>    &#125;<br>    <span class="hljs-keyword">return</span> minPQ.pq[<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">minPQ</span>&#123;<br>    <span class="hljs-type">int</span>[] pq;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    minPQ(<span class="hljs-type">int</span> sz)&#123;<br>        pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sz + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span>&#123;<br>        N++;<br>        pq[N] = e;<br>        swim(N);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delMin</span><span class="hljs-params">()</span>&#123;<br>        change(<span class="hljs-number">1</span>, N);<br>        pq[N] = <span class="hljs-number">0</span>;<br>        N--;<br>        sink(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;       <span class="hljs-comment">//上浮</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> k / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span> &amp;&amp; pq[k] &lt; pq[parent])&#123;<br>            change(k, parent);<br>            k = parent;<br>            parent = k / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;       <span class="hljs-comment">//下沉</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * k &gt; N) <span class="hljs-keyword">return</span>;      <span class="hljs-comment">//若 1 为父节点，1 * 2 和 1 * 2 + 1 才是孩子节点的索引</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">older</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * k;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span> &lt;= N &amp;&amp; pq[older] &gt; pq[<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>])&#123;   <span class="hljs-comment">//与俩孩子节点进行比较，找到较小者</span><br>            older = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (k &lt;= N &amp;&amp; pq[k] &gt; pq[older])&#123;<br>            change(k, older);<br>            sink(older);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> pq[i];<br>        pq[i] = pq[j];<br>        pq[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序 与 <strong>二叉树的后序遍历</strong> 很像：</p><ul><li><p>待每个节点的后序位置（左右子节点已经排好序）时执行 merge() 方法，合并两个子节点上的子数组。</p></li><li><p>将 nums[left…right] 理解成二叉树的节点，sort() 函数为二叉树遍历函数，整个归并过程为：</p></li><li><p>正因归并的时候是相对有序的排放，此为<strong>稳定排序</strong>。时空复杂度上比快排多消耗一个 O(N) 的数组。</p></li></ul><img src = "https://mmbiz.qpic.cn/sz_mmbiz_gif/gibkIz0MVqdEYjsa02Q7unU9ErV4p4Ly0FELvuVd1ia6GXofXJVibyqkSpMhVGEDsPmjHgBUJW5Mg9FGN6gt7SuCg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" width = "75%"><ul><li>框架：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义：排序 nums[lo..hi]</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> &#123;<br>    <span class="hljs-keyword">if</span> (lo == hi) &#123;                 <span class="hljs-comment">//单个元素无需排序</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (lo + hi) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 利用定义，排序 nums[lo..mid]</span><br>    sort(nums, lo, mid);<br>    <span class="hljs-comment">// 利用定义，排序 nums[mid+1..hi]</span><br>    sort(nums, mid + <span class="hljs-number">1</span>, hi);<br><br>    <span class="hljs-comment">/****** 后序位置 ******/</span><br>    <span class="hljs-comment">// 此时两部分子数组已经被排好序</span><br>    <span class="hljs-comment">// 合并两个有序数组，使 nums[lo..hi] 有序</span><br>    merge(nums, lo, mid, hi);<br>    <span class="hljs-comment">/*********************/</span><br>&#125;<br><br><span class="hljs-comment">// 将有序数组 nums[lo..mid] 和有序数组 nums[mid+1..hi]</span><br><span class="hljs-comment">// 合并为有序数组 nums[lo..hi]</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> hi)</span>;<br></code></pre></td></tr></table></figure><h3 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a>912. 排序数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//归并排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>    Merge.sort(nums);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Merge</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] tmp;         <span class="hljs-comment">//辅助数组</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];         <span class="hljs-comment">//提前将 tmp 数组 new 出来，避免在递归时频繁分配和释放内存。</span><br>        sort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        sort(nums, left, mid);<br>        sort(nums, mid + <span class="hljs-number">1</span>, right);<br>        merge(nums, left, mid, right);<br>    &#125;<br><br>    <span class="hljs-comment">//无法实现原地合并 -&gt; 先 copy 到 tmp 数组，再双指针</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span> (right + <span class="hljs-number">1</span> - left &gt;= <span class="hljs-number">0</span>) System.arraycopy(nums, left, tmp, left, right + <span class="hljs-number">1</span> - left);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left, j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> left; p &lt;= right; p++)&#123;<br>            <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>)&#123;<br>                nums[p] = tmp[j++];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == right + <span class="hljs-number">1</span>)&#123;<br>                nums[p] = tmp[i++];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp[i] &lt; tmp[j])&#123;<br>                nums[p] = tmp[i++];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                nums[p] = tmp[j++];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="148-排序链表（链表最适合的排序方式：归并排序）"><a href="#148-排序链表（链表最适合的排序方式：归并排序）" class="headerlink" title="148. 排序链表（链表最适合的排序方式：归并排序）"></a>148. 排序链表（链表最适合的排序方式：归并排序）</h3><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><ul><li><p>链表使用归并排序天然的并不消耗额外的空间，但如何寻找中间节点？</p><ul><li><p>快慢指针：一个每次走一步，一个每次走两步直到快的走到了头</p></li><li><p>注意每次走到头了要截断即 .next &#x3D; null，否则后期无法合并</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">return</span> head == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : mergeSort(head, <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(ListNode head, ListNode tail)</span>&#123;     <span class="hljs-comment">//左闭右开</span><br>    <span class="hljs-keyword">if</span> (head.next == tail)&#123;<br>        head.next = <span class="hljs-literal">null</span>;                                   <span class="hljs-comment">//需要截断</span><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast != tail)&#123;<br>        slow = slow.next;<br>        fast = fast.next;<br>        <span class="hljs-keyword">if</span> (fast != tail)&#123;<br>            fast = fast.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> mergeSort(head, slow);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> mergeSort(slow, tail);<br>    <span class="hljs-keyword">return</span> merge(l, r);<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode left, ListNode right)</span>&#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (left.val &lt; right.val)&#123;<br>            cur.next = left;<br>            left = left.next;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            cur.next = right;<br>            right = right.next;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br><br>    <span class="hljs-comment">//因为是分治的进行排序，所以在合并完最多剩下一个</span><br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span>)&#123;<br>        cur.next = left;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">null</span>)&#123;<br>        cur.next = right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/6.%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/6.%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a>693. 交替位二进制数</h2><p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p><ul><li>逐位检查</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasAlternatingBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> n &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> ((u ^ pre) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = u;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>利用交替二进制数的特点：</p><ul><li><p>若 n 为交替二进制数，则其右移一位得到的值 m 仍为交替二进制数</p></li><li><p>将 n 与 m 异或会得到形如 00011…11 的结果 x</p></li><li><p>将 x 加一（进位后）得到形如 00100.。0 的结果，将该结果与 x 按位与 会得到全 0 的结果</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasAlternatingBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> n ^ (n &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> (x &amp; (x + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="762-二进制表示中质数个计算置位"><a href="#762-二进制表示中质数个计算置位" class="headerlink" title="762. 二进制表示中质数个计算置位"></a>762. 二进制表示中质数个计算置位</h2><p>给定一个整数区间 [left,right]，计算区间内所有数字二进制表示中 1 的个数，若个数为素数，计数加一，返回最终结果。</p><p>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; 10^6</p><p>0 &lt;&#x3D; right - left &lt;&#x3D; 10^4</p><ul><li><p>知识点回顾：</p><ul><li><p>求整数 x 的二进制有多少个 1:</p><ul><li><p>x &amp;&#x3D; (x - 1) -&gt; 消除最低位的 1，while 循环 x !&#x3D; 0</p></li><li><p>用 lowBit 实现：x &amp; (-x) -&gt; 只保留整数 x 最低位的 1</p></li></ul></li><li><p>如何判断一个数为素数</p><ul><li>for(int i &#x3D; 2; i * i &lt;&#x3D; x; i++) if(x % i &#x3D;&#x3D; 0) return false;</li></ul></li><li><p>巧用 mask，数据最多有20位，使用一个数 mask 存储所有质数信息：若 i 为质数则置 第 i 位为 1</p><ul><li>对于任何一个数的 bitCount, 若 (1 &lt;&lt; bitCount &amp; mask) !&#x3D; 0 -&gt; 该 bitCount 为质数</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPrimeSetBits</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++)&#123;<br>        <span class="hljs-keyword">if</span> (isPrime(getBitCnt(i))) ans++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBitCnt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lowBit</span> <span class="hljs-operator">=</span> x &amp; (-x);<br>        cnt++;<br>        x -= lowBit;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i * i &lt;= x; i++)&#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/7.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/7.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>正则表达式 ： regular expression.(缩写regex、re)</p><h2 id="2047-句子中的有效单词数"><a href="#2047-句子中的有效单词数" class="headerlink" title="2047. 句子中的有效单词数"></a>2047. 句子中的有效单词数</h2><p>句子仅由小写字母（’a’ 到 ‘z’）、数字（’0’ 到 ‘9’）、连字符（’-‘）、标点符号（’!’、’.’ 和 ‘,’）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。</p><p>如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：</p><p>仅由小写字母、连字符和（或）标点（不含数字）。</p><p><strong>至多一个</strong> 连字符 ‘-‘ 。如果存在，连字符两侧应当都存在小写字母（”a-b” 是一个有效单词，但 “-ab” 和 “ab-“ 不是有效单词）。</p><p><strong>至多一个</strong> 标点符号。如果存在，标点符号应当位于 token 的 末尾 。</p><p>这里给出几个有效单词的例子：”a-b.”、”afad”、”ba-c”、”a!” 和 “!” 。</p><p>给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。</p><h3 id="除正常模拟外，还可以练习re"><a href="#除正常模拟外，还可以练习re" class="headerlink" title="除正常模拟外，还可以练习re"></a>除正常模拟外，还可以练习re</h3><p>由于 token 之间有一个至多个的空格，调用 spilt 后会有空字符串，所以有了 if 的第一个判断。</p><ul><li><p>() ：标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</p></li><li><p>[a-z]* ：全字母的情况；* 号代表前面的字符可以出现 0 次、一次或多次</p></li><li><p>[a-z]+-[a-z]+ ： + 号匹配前面的子表达式一次或多次。</p><ul><li>连字符 - 不代表什么正则，所以界定其仅出现在两个字母之间一次即可。</li></ul></li><li><p>？ 号匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countValidWords</span><span class="hljs-params">(String sentence)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;([a-z]*|([a-z]+-[a-z]+))[!.,]?&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (String s : sentence.split(<span class="hljs-string">&quot; &quot;</span>)) &#123;<br>        <span class="hljs-keyword">if</span> (s.length() &gt; <span class="hljs-number">0</span> &amp;&amp; s.matches(regex)) &#123;<br>            ans++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="537-复数乘法"><a href="#537-复数乘法" class="headerlink" title="537. 复数乘法"></a>537. 复数乘法</h2><p>正常模拟更快，但学习一下复数（a + bi）（a,b可取所有整数）的切割 regex。</p><p>因为 “+” 是特殊含义，想识别它需前加 <strong>双反斜杠</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">complexNumberMultiply</span><span class="hljs-params">(String num1, String num2)</span> &#123;<br>    String[] ss1 = num1.split(<span class="hljs-string">&quot;\\+|i&quot;</span>), ss2 = num2.split(<span class="hljs-string">&quot;\\+|i&quot;</span>);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(ss1[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.parseInt(ss1[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Integer.parseInt(ss2[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Integer.parseInt(ss2[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    sb.append(a * c - b * d).append(<span class="hljs-string">&quot;+&quot;</span>).append(a * d + b * c).append(<span class="hljs-string">&quot;i&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sb);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>bfs</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/BFS%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/BFS%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="111题-二叉树的最小深度"><a href="#111题-二叉树的最小深度" class="headerlink" title="111题 二叉树的最小深度"></a>111题 二叉树的最小深度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> ( root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    queue.offer(root);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;                 <span class="hljs-comment">//根节点算一层</span><br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>)&#123;      <span class="hljs-comment">//结束条件：从根节点走到最近的叶节点</span><br>                <span class="hljs-keyword">return</span> depth;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-comment">//将cur的相邻(这里只有左右两个方位)节点加入队列</span><br>                queue.offer(cur.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>)&#123;<br>                queue.offer(cur.right);<br>            &#125;<br>        &#125;<br>        depth++;                <span class="hljs-comment">//每一层结束了以后才加一</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>提交有个出错点：</code></p><p><code>对于单端队列 Queue：先进先出(添加到队尾，取队首元素并删除)；</code></p><p><code>有offer/poll/peek 或者 add/remove/element 两种增删获取的方式，区别只在于出错时前者return false/null，后者throw Exception。</code></p><p><code>而双端队列 Deque: 允许两头都进，两头都出；所以对应都带First或者Las</code></p><p><code>添加元素到队尾：addLast/offerLast；到队首：addFirst/offerFirst；取队首元素并删除：removeFirst/pollFirst</code></p><p><code>而stack作为后进先出，push = addFirst，pop = removeFirst</code></p><p><code>https://blog.csdn.net/wang_chaochen/article/details/117282584</code></p><h2 id="102题-二叉树的层序遍历"><a href="#102题-二叉树的层序遍历" class="headerlink" title="102题 二叉树的层序遍历"></a>102题 二叉树的层序遍历</h2><p>妥妥的BFS框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> ret;<br><br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <span class="hljs-comment">//先进先出</span><br>    queue.offer(root);<br><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            list.add(cur.val);<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>)&#123;<br>                queue.offer(cur.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>)&#123;<br>                queue.offer(cur.right);<br>            &#125;<br>        &#125;<br>        ret.add(list);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="752题-打开转盘锁"><a href="#752题-打开转盘锁" class="headerlink" title="752题 打开转盘锁"></a>752题 打开转盘锁</h2><p>先将问题抽象成一个图，对于起点0000，其下一步可以走的地方有8个，即0001，0009，0010，0090…1000，9000（按照向上和向下两个方向进行扩散）</p><h3 id="双向BFS优化"><a href="#双向BFS优化" class="headerlink" title="双向BFS优化"></a>双向BFS优化</h3><p><code>知道起点和终点，同时扩散,有交集时停止</code></p><ol><li>不再使用队列，而是用HashSet方便快速判断两集合是否有交集</li><li>while循环最后交换q1和q2的内容，即默认扩散q1，即轮流扩散q1和q2</li><li>还可以在while循环一开始选择集合小的进行扩散，因为在BFS中集合元素越多，扩散后的集合就越多；每次扩散集合小的，占用的空间增长速度慢一些，效率就高些。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123;<br>    <span class="hljs-keyword">if</span> (q1.size() &gt; q2.size()) &#123;<br>    <span class="hljs-comment">// 交换 q1 和 q2</span><br>        temp = q1;<br>        q1 = q2;<br>        q2 = temp;<br>    &#125;<br>    <span class="hljs-comment">//....</span><br></code></pre></td></tr></table></figure><ul><li>完整版</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> &#123;<br>    Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(deadends));         <span class="hljs-comment">//将dead和visited合并,节省一个Set空间</span><br>    <span class="hljs-keyword">if</span> (visited.contains(<span class="hljs-string">&quot;0000&quot;</span>) || visited.contains(target)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;       <span class="hljs-comment">//预处理特殊的</span><br><br>    Set&lt;String&gt; q1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    Set&lt;String&gt; q2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();             <span class="hljs-comment">//双向BFS,集合可以快速判断元素是否存在</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    q1.add(<span class="hljs-string">&quot;0000&quot;</span>);<br>    q2.add(target);<br><br>    <span class="hljs-keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123;<br>        <span class="hljs-comment">//哈希集合不能被更改,先用tmp存储此轮的扩散结果</span><br>        Set&lt;String&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (String cur : q1) &#123;<br>            <span class="hljs-keyword">if</span> (visited.contains(cur)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (q2.contains(cur)) <span class="hljs-keyword">return</span> step;    <span class="hljs-comment">//起点和终点有交集时</span><br>            visited.add(cur);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cnt &lt; <span class="hljs-number">4</span>; cnt++)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> plusOne(cur,cnt);<br>                <span class="hljs-keyword">if</span> (!visited.contains(up))&#123;<br>                    tmp.add(up);<br>                &#125;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> minusOne(cur,cnt);<br>                <span class="hljs-keyword">if</span> (!visited.contains(down))&#123;<br>                    tmp.add(down);<br>                &#125;<br>            &#125;<br>        &#125;<br>        step++;<br>        q1 = q2;    <span class="hljs-comment">//起点和终点交替进行扩散</span><br>        q2 = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">plusOne</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> bit)</span>&#123;<br>    <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>    <span class="hljs-keyword">if</span> (chars[bit] == <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>        chars[bit] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<span class="hljs-keyword">else</span> chars[bit] += <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minusOne</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> bit)</span>&#123;<br>    <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>    <span class="hljs-keyword">if</span> (chars[bit] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>        chars[bit] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>    &#125;<span class="hljs-keyword">else</span> chars[bit] -= <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向BFS模板题：2059-转化数字的最小运算数"><a href="#双向BFS模板题：2059-转化数字的最小运算数" class="headerlink" title="双向BFS模板题：2059. 转化数字的最小运算数"></a>双向BFS模板题：2059. 转化数字的最小运算数</h2><p>给你一个下标从 0 开始的整数数组 nums ，该数组由 互不相同 的数字组成。另给你两个整数 start 和 goal 。</p><p>整数 x 的值最开始设为 start ，你打算执行一些运算使 x 转化为 goal 。你可以对数字 x 重复执行下述运算：</p><p>如果 0 &lt;&#x3D; x &lt;&#x3D; 1000 ，那么，对于数组中的任一下标 i（0 &lt;&#x3D; i &lt; nums.length），可以将 x 设为下述任一值：</p><p>x + nums[i]</p><p>x - nums[i]</p><p>x ^ nums[i]（按位异或 XOR）</p><p>注意，你可以按任意顺序使用每个 nums[i] 任意次。使 x 越过 0 &lt;&#x3D; x &lt;&#x3D; 1000 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。</p><p>返回将 x &#x3D; start 转化为 goal 的最小操作数；如果无法完成转化，则返回 -1 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3], start &#x3D; 6, goal &#x3D; 4</p><p>输出：2</p><p>解释：</p><p>可以按 6 → 7 → 4 的转化路径进行，只需执行下述 2 次运算：</p><ul><li><p>6 ^ 1 &#x3D; 7</p></li><li><p>7 ^ 3 &#x3D; 4</p></li></ul><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000</p><p>-10^9 &lt;&#x3D; nums[i], goal &lt;&#x3D; 10^9</p><p>0 &lt;&#x3D; start &lt;&#x3D; 1000</p><p>start !&#x3D; goal</p><p>nums 中的所有整数互不相同</p><h3 id="一个Deque，一个visit数组"><a href="#一个Deque，一个visit数组" class="headerlink" title="一个Deque，一个visit数组"></a>一个Deque，一个visit数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单向BFS</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> goal)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br>    Deque&lt;Integer&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    dq.addLast(start);<br>    <span class="hljs-type">int</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1001</span>];        <span class="hljs-comment">//有效的数据范围在 0 - 1000</span><br>    Arrays.fill(vis, INF);<br>    vis[start] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (!dq.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dq.pollFirst(), step = vis[t];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;t + num, t - num, t ^ num&#125;;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : result) &#123;<br>                <span class="hljs-keyword">if</span> (i == goal) <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt;= <span class="hljs-number">1000</span> &amp;&amp; vis[i] == INF)&#123;<br>                    dq.addLast(i);<br>                    vis[i] = step + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双向搜索时注意： x 越过 0 &lt;&#x3D; x &lt;&#x3D; 1000 范围的运算可以生效但不能再执行其他运算。</li><li>意味着不同方向搜索时检查的时间也不一样，所以要用 flag 来标记一下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双向BFS</span><br><span class="hljs-type">int</span>[] nums;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations0</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> goal)</span> &#123;<br>    <span class="hljs-built_in">this</span>.nums = nums;<br>    Deque&lt;Integer&gt; d1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(), d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    d1.addLast(start);<br>    d2.addLast(goal);<br>    Map&lt;Integer, Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map1.put(start, <span class="hljs-number">0</span>);        <span class="hljs-comment">//value, step</span><br>    map2.put(goal, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">while</span> (!d1.isEmpty() &amp;&amp; !d2.isEmpty())&#123;<br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-keyword">if</span> (d1.size() &lt; d2.size()) t = update(d1, map1, map2, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">else</span> t = update(d2, map2, map1, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (t != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Deque&lt;Integer&gt; d1, Map&lt;Integer, Integer&gt; map1, Map&lt;Integer, Integer&gt; map2, <span class="hljs-type">boolean</span> flag)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> d1.size();<br>    <span class="hljs-keyword">while</span> (m-- &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> d1.pollFirst(), step = map1.get(t);<br>        <span class="hljs-keyword">if</span> (flag)&#123;         <span class="hljs-comment">//正向搜索，出队时检查是否满足条件，否则不再参与计算</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>                <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span> || t &gt; <span class="hljs-number">1000</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;t + num, t - num, t ^ num&#125;;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : result) &#123;<br>                    <span class="hljs-keyword">if</span> (map2.containsKey(i)) <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span> + map2.get(i);<br>                    <span class="hljs-keyword">if</span> (!map1.containsKey(i))&#123;<br>                        d1.addLast(i);<br>                        map1.put(i, step + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;              <span class="hljs-comment">//反向搜索，入队时检查是否满足条件</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>                <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;t + num, t - num, t ^ num&#125;;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : result) &#123;<br>                    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; <span class="hljs-number">1000</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span> (map2.containsKey(i)) <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span> + map2.get(i);<br>                    <span class="hljs-keyword">if</span> (!map1.containsKey(i))&#123;<br>                        d1.addLast(i);<br>                        map1.put(i, step + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的还有：</p><ul><li><p>127题 单词接龙</p><ul><li>枚举每次替换一个字母的单词，并用 map1、map2、wordList 来剪枝</li><li>也可以建立无向图，求两点间最短路径</li></ul></li><li><p>2045题 到达目的地的第二短时间</p><ul><li>无向图求次短路径：Dijkstra 算法</li><li>在知道总节点个数的情况下，边的集合可以用 List[] 代替 Map</li></ul></li></ul><h3 id="多源最短路：源点集-到-目标点集-求最短路"><a href="#多源最短路：源点集-到-目标点集-求最短路" class="headerlink" title="多源最短路：源点集 到 目标点集 求最短路"></a>多源最短路：源点集 到 目标点集 求最短路</h3><ul><li><p>1765题 地图中的最高点</p></li><li><p>1162题 地图分析（官方有详解 + dp 优化）</p><ul><li>dp：陆地为源点集，从右下和左上两个方向扩张，细节满满。</li></ul></li><li><p>994题 腐烂的橘子</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dfs</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<ul><li><p>回溯就是递归+剪枝，需要明确:dfs(路径，选择列表)</p></li><li><p>每一次只考虑当前节点要做的事情，选择与撤销选择就对应前序遍历和后序遍历</p></li><li><p>对于全排列、N皇后问题：</p><p>  需要找出所有可能的解，dfs无需返回值，需用list等来记录结果。</p></li><li><p>对于解数独问题：</p><p>  只需找出一个符合的解即可，dfs需返回bool类型，一旦发现找到合适的解，一层一层的上传回去，节省时间。</p></li></ul><ol><li><p>若不想让dfs传参太多，可适当设置全局变量</p></li><li><p>要想对判断是否符合条件这一部分进行简化的话，就要设置数组、集合、dp[ ]记忆化搜索。去重部分和动归一样，都是设置备忘录。</p></li><li><p>细节处理：</p><ol><li>前导0的多种情况一并考虑的方法：</li></ol><p>parseInt直接将字符串转换为int型数据。</p><p>后一个或是处理前导0，例如tmp &#x3D; “013”,num &#x3D; 13,Integer.toString &#x3D; “13”，长度不同，如此可解决00型和012型。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(tmp);<br><span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span> || tmp.length() != Integer.toString(num).length())&#123;<br>     <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">2. List是以链表形式存储，删除只需remove(list.size – 1)；而Set是以数的形式存储，是以节点形式删除，即删掉内容delete(num)</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>     Arrays.fill(dp[i],<span class="hljs-literal">true</span>);          <span class="hljs-comment">//二维以上数组只能一行一行的初始化</span><br> &#125;<br></code></pre></td></tr></table></figure><p>   以牺牲空间来节省时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>         dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br> <span class="hljs-comment">//判断一个字符串s(i,j)是否回文就是看,s(i+1,j-1)是否回文且两头是否相等</span><br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">1. 当有两个及以上的if判断条件时，要警惕出现未实现函数就被判断完return的情况2. 如果觉得for循环很难理解，考虑选择当前位置+考虑不选择，一样解决问题：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> num; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br> list.add(i);<br>    addSum(target-i,i+<span class="hljs-number">1</span>,k-<span class="hljs-number">1</span>);<br>    list.remove(list.size() - <span class="hljs-number">1</span>);<br>&#125;<br><br>    <span class="hljs-comment">//这里与for循环是一个意思</span><br><span class="hljs-comment">/*    // 考虑选择当前位置</span><br><span class="hljs-comment">temp.push_back(cur);</span><br><span class="hljs-comment">dfs(cur + 1, n, k);</span><br><span class="hljs-comment">temp.pop_back();</span><br><span class="hljs-comment">// 考虑不选择当前位置</span><br><span class="hljs-comment">dfs(cur + 1, n, k);*/</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">1. 像位置在9*9的矩阵中时，可以按行、列、块等来新建数组存储位置信息，二进制位运算也很简化。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flip</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> num)</span>&#123;<br> <span class="hljs-comment">//重点：翻转函数，可以实现由1变0，由0变1，针对dfs前后的选择与撤销选择。原理：任何数与1相异或两次都能复原</span><br> rows[i] ^= (<span class="hljs-number">1</span> &lt;&lt; num);<br> cols[j] ^= (<span class="hljs-number">1</span> &lt;&lt; num);<br> blocks[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>] ^= (<span class="hljs-number">1</span> &lt;&lt; num);<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>杂</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/%E4%B8%80%E4%BA%9B/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/%E4%B8%80%E4%BA%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="x3D-x3D-和-equals的区别"><a href="#x3D-x3D-和-equals的区别" class="headerlink" title="&#x3D;&#x3D;和.equals的区别"></a>&#x3D;&#x3D;和.equals的区别</h2><ol><li><p>&#x3D;&#x3D; 是运算符</p><ul><li>可以使用在基本数据类型变量和引用数据类型变量中</li><li>基本数据类型（除了boolean）：比较数值。（对于 char 型，若为单字符比较其对应的ASCII码，反之直接比较数值）<ul><li>不同类型之间也能比较（比如 int 和 double。进行自动类型提升即可）</li></ul></li><li>引用数据类型：比较地址值是否相同（即两个引用是否指向同一个对象实体）</li></ul></li><li><p>equals() 是一个方法</p><ul><li>方法需要对象来调用，所以无法比较基本数据类型。仅适用于引用数据类型</li><li>Object 类中 equals() 的定义：<ul><li>说明 Object 类中定义的 equals 和 &#x3D;&#x3D; 作用相同，比较俩对象地址值是否相同。</li></ul></li><li>像 String、Date、File、包装类等都重写了 Object 类中的 equals() 方法<ul><li>重写后不再比较引用的地址是否相同。<strong>比较的是两个对象的“实体内容”是否相同</strong>。</li><li>toString() 方法也是，默认 Object 类输出地址值，只有上述的重写了可以输出“实体内容”。</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span> == obj;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>自定义类如何重写 equals() 比较两对象的“实体内容”是否相同</li><li>IDEA 中支持自动生成 equals()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//比如比较俩对象的 name 和 age 是否相同；可参见 String 重写的 equals()</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> == obj) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//如果当前对象和形参对象所指地址值相同直接 return true</span><br><br>    <span class="hljs-keyword">if</span>(obj instance Customer)&#123;   <span class="hljs-comment">//多态</span><br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">cust</span> <span class="hljs-operator">=</span> (Customer) obj;   <span class="hljs-comment">//向下转型 (父类) obj -&gt; (子类) Customer</span><br>        <span class="hljs-comment">//比较两对象的每个属性是否相同：基本数据类型 age 用 ==、引用数据类型 name 用 equals()</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.age == cust.age &amp;&amp; <span class="hljs-built_in">this</span>.name.equals(cust.name))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>String实例是对象，判断String相等就应该用equals()而不是简单的&#x3D;&#x3D;。</p><p>&#x3D;&#x3D; 是判断两个引用指向的是不是一个对象。<br>至于 为什么idea能用 &#x3D;&#x3D; 判断，肯定是因为你们用了</p><p>String[] s &#x3D; {“1”};</p><p>的形式创建的字符串数组，</p><p>此时”1”被放在<strong>常量池</strong>，在evalRPN函数再用”1”会直接指向常量池里之前创建的”1”，即两个引用指向的是同一个对象，所以能相等。<strong>（常量池会复用）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;BB&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;BB&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;BB&quot;</span>);<br>System.out.println(s1 == s2);       <span class="hljs-comment">//true</span><br>System.out.println(s1 == s3);       <span class="hljs-comment">//false；而 equals() 都是 true,因为 String 重写了</span><br></code></pre></td></tr></table></figure><p>而leetcode上tokens里的字符串都是通过 new String(“1”);方式创建的对象，所以&#x3D;&#x3D;不相等必须要equals。</p><ul><li><p>对于字符串来说，“&#x3D;&#x3D;”比较两个变量本身的值，即两个对象在内存中的首地址。而“equals()”比较字符串中所包含的内容是否相同。</p></li><li><p>但是对于非字符串的对象来说，”&#x3D;&#x3D;”和”equals”都是用来比较对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个对象。</p></li></ul><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>若数组大小一定或数组元素范围有限，可以通过桶排序来代替快排。</p><p>即一次遍历数组，将相同数值的值计数，形如一桶一桶的排序起来。常见如 chars[i - ‘a’]++;</p><p>有时会和前缀和联系起来进行一些处理：</p><ul><li>825.适龄的朋友</li></ul><p>在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。</p><p>如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x !&#x3D; y）发送好友请求：</p><p>ages[y] &lt;&#x3D; 0.5 * ages[x] + 7</p><p>ages[y] &gt; ages[x]</p><p>ages[y] &gt; 100 &amp;&amp; ages[x] &lt; 100</p><p>否则，x 将会向 y 发送一条好友请求。</p><p>注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。</p><p>返回在该社交媒体网站上产生的好友请求总数。</p><p>示例：</p><p>输入：ages &#x3D; [16,17,18]</p><p>输出：2</p><p>解释：产生的好友请求为 17 -&gt; 16 ，18 -&gt; 17 。</p><p>提示：</p><ul><li>n &#x3D;&#x3D; ages.length</li><li>1 &lt;&#x3D; n &lt;&#x3D; 2 * 104</li><li>1 &lt;&#x3D; ages[i] &lt;&#x3D; 120</li></ul><p><strong>思路：</strong></p><ol><li>遇见条件多的情况先进行适当化简<ul><li>发现条件3为多余项，与条件2等价</li><li>3个条件合并成符合要求的为：0.5*x + 7 &lt; y ≤ x</li></ul></li><li>由 0.5 * x + 7 &lt; x，求得大于15岁才能交友</li><li>年龄数组有一定范围且并不大，除了可以 <strong>“快排 + 双指针”</strong> 动态维护满足条件的年龄范围</li><li>还可以 <strong>“桶排序 + 前缀和”</strong> 一次性提取得到符合的请求总数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numFriendRequests</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ages)</span> &#123;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">121</span>];                   <span class="hljs-comment">//桶排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> age : ages)&#123;<br>            count[age]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">121</span>];                    <span class="hljs-comment">//计算前缀和</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">120</span>; i++)&#123;<br>            pre[i] += pre[i - <span class="hljs-number">1</span>] + count[i];         <span class="hljs-comment">//满足 ≤ 年龄 i 的人数</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>; i &lt;= <span class="hljs-number">120</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(count[i] &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-number">0.5</span> * i + <span class="hljs-number">8</span>);         <span class="hljs-comment">//0.5*15+8 = 15,只有≥15岁才能交友</span><br>            sum += count[i] * (pre[i] - pre[bound - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//前缀和作差再减去自身即为总人数</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="用数组实现大根堆"><a href="#用数组实现大根堆" class="headerlink" title="用数组实现大根堆"></a>用数组实现大根堆</h2><h2 id="toArray-用法：将list转化为数组"><a href="#toArray-用法：将list转化为数组" class="headerlink" title="toArray()用法：将list转化为数组"></a>toArray()用法：将list转化为数组</h2><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>][]);<br></code></pre></td></tr></table></figure><ul><li><p>toArray()调用的时候一般要传一个数组指定类型，如果不传参数会默认返回Object数组。</p></li><li><p>int[0][]指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型, 并不是真实的长度</p></li><li><p>toArray内部会自动判断传入数组大小是否小于list中元素的个数，如果小于则会产生一个大小等于元素个数的新数组，写入数据后返回，否则写入传入的数组，然后返回。</p></li></ul><p><strong>但是！不能直接返回int数组，例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>]);          <span class="hljs-comment">//无法返回 int[]</span><br></code></pre></td></tr></table></figure><ul><li><p>因为ArrayList里面只能放引用类型，不能放基本类型。</p></li><li><p>所以只能返回Integer数组，然后转成int数组(不能强转)，因为在java中所有的数组都是引用类型的，而int和Integer能直接转换是因为jdk会帮我们自己打包解包(包装类)。</p></li><li><p>但是可以返回 int[][] 因为java中的二维数组 int[][] 可以看成存放 int[] 的数组，而int[]是引用类型。</p></li></ul><p>比如 Integer 类里有：toString()方法、parseInt()方法、int 变量等等。</p><p>list 里只装了 Integer 类型的数值 只能返回 Integer 数组。</p><p>而 int[][] 可以看着一个 大 int[] 型数组里每一个元素也是 int[] 数组。此时传入 toArray() 的类型是已知的 int[] 型，可以直接返回 int[][] 数组。</p><p>应用详见：- 56.合并区间</p>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分治</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/%E5%88%86%E6%B2%BB/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/%E5%88%86%E6%B2%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="105题-从前序与中序遍历序列构造二叉树"><a href="#105题-从前序与中序遍历序列构造二叉树" class="headerlink" title="105题 从前序与中序遍历序列构造二叉树"></a>105题 从前序与中序遍历序列构造二叉树</h2><p><code>关键：前序遍历提供根节点的信息，中序遍历提供了由根节点将整个序列分为左、右子树的信息。</code></p><p><code>官解输入多个参数是为了清晰，且时间和内存上的消耗都会小很多</code></p><p><code>画个图标明一下就很清楚，左右区间均是闭区间</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>    Map&lt;Integer,Integer&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : inorder) &#123;<br>        hash.put(i,index++);           <span class="hljs-comment">//以空间换时间，每次由前序遍历根节点的值找到其在中序遍历中的位置</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> createTree(preorder,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,hash,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//preorder : 前序遍历序列</span><br><span class="hljs-comment">//preLeft,preRight : 前序遍历序列(子区间)的左右边界，闭区间</span><br><span class="hljs-comment">//hash : 中序遍历中数值与下标的关系</span><br><span class="hljs-comment">//inLeft,inRight : 中序遍历序列(子区间)的左右边界，闭区间</span><br><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">createTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preLeft, <span class="hljs-type">int</span> preRight, Map&lt;Integer,Integer&gt; hash, <span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight)</span>&#123;<br>    <span class="hljs-keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[preLeft];<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pIndex</span> <span class="hljs-operator">=</span> hash.get(rootVal);          <span class="hljs-comment">//根节点在中序遍历中的位置</span><br>    node.left = createTree(preorder,preLeft + <span class="hljs-number">1</span>, pIndex - inLeft + preLeft, hash,inLeft,pIndex - <span class="hljs-number">1</span>);<br>    node.right = createTree(preorder,pIndex - inLeft + preLeft + <span class="hljs-number">1</span>,preRight,hash,pIndex + <span class="hljs-number">1</span>,inRight);<br><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a>395. 至少有 K 个重复字符的最长子串</h2><p>给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。</p><p>示例 1：</p><p>输入：s &#x3D; “aaabb”, k &#x3D; 3</p><p>输出：3</p><p>解释：最长子串为 “aaa” ，其中 ‘a’ 重复了 3 次。</p><p>示例 2：</p><p>输入：s &#x3D; “ababbc”, k &#x3D; 2</p><p>输出：5</p><p>解释：最长子串为 “ababb” ，其中 ‘a’ 重复了 2 次， ‘b’ 重复了 3 次。</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 10^4</p><p>s 仅由小写英文字母组成</p><p>1 &lt;&#x3D; k &lt;&#x3D; 10^5</p><h3 id="分治：按不满足条件的字符分段而治"><a href="#分治：按不满足条件的字符分段而治" class="headerlink" title="分治：按不满足条件的字符分段而治"></a>分治：按不满足条件的字符分段而治</h3><ul><li><p>复杂度分析</p><ul><li><p>时间复杂度：O(N⋅∣Σ∣)，其中 N 为字符串的长度，Σ 为字符集，本题中字符串仅包含小写字母，因此∣Σ∣&#x3D;26。由于每次递归调用都会完全去除某个字符，因此递归深度最多为∣Σ∣。</p></li><li><p>空间复杂度：O(∣Σ∣^2 )。递归的深度为 O(∣Σ∣)，每层递归需要开辟 O(∣Σ∣) 的额外空间。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分治(0ms)</span><br><span class="hljs-type">char</span>[] ch;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSubstring0</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-keyword">if</span> (k &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">this</span>.ch = s.toCharArray();<br>    <span class="hljs-keyword">return</span> check(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> ed, <span class="hljs-type">int</span> k)</span>&#123;    <span class="hljs-comment">//双闭</span><br>    <span class="hljs-keyword">if</span> (st &gt; ed || k &gt; ed - st + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span>[] letter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st; i &lt;= ed; i++)&#123;<br>        letter[ch[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br><br>    <span class="hljs-type">char</span> <span class="hljs-variable">split</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                          <span class="hljs-comment">//枚举不满足条件的字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span> (letter[i] &gt; <span class="hljs-number">0</span> &amp;&amp; letter[i] &lt; k)&#123;<br>            split = (<span class="hljs-type">char</span>) (i + <span class="hljs-string">&#x27;a&#x27;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (split == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ed - st + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st;                             <span class="hljs-comment">//若将该双层while循环置于查找 split 的过程中，会多遍历很多：26个字母每次开启新循环时都是从头开始，这是不必要的</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= ed)&#123;<br>        <span class="hljs-keyword">while</span> (i &lt;= ed &amp;&amp; ch[i] == split) i++;<br>        <span class="hljs-keyword">if</span> (i &gt; ed) <span class="hljs-keyword">break</span>;<br><br>        st = i;<br>        <span class="hljs-keyword">while</span> (i &lt;= ed &amp;&amp; ch[i] != split) i++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> check(st, i - <span class="hljs-number">1</span>, k);<br>        ret = Math.max(ret, len);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口：枚举最长子串中的字符种类数目"><a href="#滑动窗口：枚举最长子串中的字符种类数目" class="headerlink" title="滑动窗口：枚举最长子串中的字符种类数目"></a>滑动窗口：枚举最长子串中的字符种类数目</h3><ul><li>时间复杂度：<ul><li>记录子串中出现的字符个数 total 一定是不小于 枚举的字符种类数目 typeNum 的，而 typeNum 严格 ≥ 1<ul><li>即左右滑动窗口时不会出现 l &gt; r 或是区间交叠的情况。</li></ul></li><li>整体来看只对字符串 s 遍历了一次。即 O(N * ∣Σ∣)，其中 N 为字符串的长度，Σ 为字符集，本题中字符串仅包含小写字母，因此 ∣Σ∣&#x3D;26。我们需要遍历所有可能的 t，共 ∣Σ∣ 种可能性；内层循环中滑动窗口的复杂度为 O(N)，且初始时需要 O(∣Σ∣) 的时间初始化 cnt 数组。</li></ul></li><li>空间复杂度：O(∣Σ∣)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSubstring</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-keyword">if</span> (k &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">char</span>[] ch = s.toCharArray();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">typeNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; typeNum &lt;= <span class="hljs-number">26</span>; typeNum++)&#123;                 <span class="hljs-comment">// O(∣Σ∣)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;               <span class="hljs-comment">//记录子串中出现的字符个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                <span class="hljs-comment">//计数器：实现O(1)的方式查看该子串中字符数量是否均不小于k：只记录小于k的个数</span><br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">while</span> (r &lt; n)&#123;               <span class="hljs-comment">//右移右边界                    o(N)</span><br>            cnt[ch[r] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span> (cnt[ch[r] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>)&#123;<br>                total++;<br>                less++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt[ch[r] - <span class="hljs-string">&#x27;a&#x27;</span>] == k) less--;<br><br>            <span class="hljs-keyword">while</span> (total &gt; typeNum)&#123;   <span class="hljs-comment">//右移左边界</span><br>                cnt[ch[l] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                <span class="hljs-keyword">if</span> (cnt[ch[l] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>)&#123;<br>                    total--;less--;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cnt[ch[l] - <span class="hljs-string">&#x27;a&#x27;</span>] == k - <span class="hljs-number">1</span>)&#123;<br>                    less++;<br>                &#125;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (less == <span class="hljs-number">0</span>) ret = Math.max(ret, r - l + <span class="hljs-number">1</span>);<br>            r++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似题：- 1763.最长的美好子字符串</p><p>当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。比方说，”abABB” 是美好字符串，因为 ‘A’ 和 ‘a’ 同时出现了，且 ‘B’ 和 ‘b’ 也同时出现了。然而，”abA” 不是美好字符串因为 ‘b’ 出现了，而 ‘B’ 没有出现。</p><p>给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。</p><p>示例 1：</p><p>输入：s &#x3D; “YazaAay”</p><p>输出：”aAa”</p><p>解释：”aAa” 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 ‘a’ 和大写形式 ‘A’ 也同时出现了。</p><p>“aAa” 是最长的美好子字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">//method1：暴力(4ms)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestNiceSubstring1</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxPos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lower</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, upper = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span> (Character.isLowerCase(chars[j]))&#123;<br>                    lower |= <span class="hljs-number">1</span> &lt;&lt; (chars[j] - <span class="hljs-string">&#x27;a&#x27;</span>);<br>                &#125;<span class="hljs-keyword">else</span> upper |= <span class="hljs-number">1</span> &lt;&lt; (chars[j] - <span class="hljs-string">&#x27;A&#x27;</span>);<br><br>                <span class="hljs-keyword">if</span> (upper == lower &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen)&#123;<br>                    maxPos = i;<br>                    maxLen = j - i + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxPos, maxPos + maxLen);<br>    &#125;<br><br>    <span class="hljs-comment">//method2：分治(0ms)</span><br>    <span class="hljs-comment">//由于字符串中含有部分字母只含大写或小写字母，将字符串从这些非法字符处切割成若干段，最长子串一定在某一段中，不会有跨越的情况。</span><br>    <span class="hljs-comment">//递归检查 [st,ed] 段是否为美好子串，是则比较更新 maxLen，否则切割。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxPos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//    char[] ch;</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestNiceSubstring2</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ch = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        dfs(<span class="hljs-number">0</span>,n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> s.substring(maxPos, maxPos + maxLen);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> ed)</span>&#123;   <span class="hljs-comment">//双闭</span><br>        <span class="hljs-keyword">if</span> (st &gt;= ed) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lower</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, upper = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st; i &lt;= ed; i++)&#123;<br>            <span class="hljs-keyword">if</span> (Character.isLowerCase(ch[i]))&#123;<br>                lower |= <span class="hljs-number">1</span> &lt;&lt; (ch[i] - <span class="hljs-string">&#x27;a&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                upper |= <span class="hljs-number">1</span> &lt;&lt; (ch[i] - <span class="hljs-string">&#x27;A&#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lower == upper)&#123;<br>            <span class="hljs-keyword">if</span> (ed - st + <span class="hljs-number">1</span> &gt; maxLen)&#123;<br>                maxPos = st;<br>                maxLen = ed - st + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> lower &amp; upper;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> st;<br>        <span class="hljs-keyword">while</span> (pos &lt;= ed)&#123;<br>            st = pos;<br>            <span class="hljs-keyword">while</span> (pos &lt;= ed &amp;&amp; (valid &amp; <span class="hljs-number">1</span> &lt;&lt; (Character.toLowerCase(ch[pos]) - <span class="hljs-string">&#x27;a&#x27;</span>)) != <span class="hljs-number">0</span>)&#123;<br>                pos++;<br>            &#125;<br>            dfs(st, pos - <span class="hljs-number">1</span>);<br>            pos++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//method3：滑动窗口(2ms)</span><br>    <span class="hljs-comment">//统计字符串出现的字母种类数(同一字母大小写算一种),按种类数动态维护窗口的左右边界、大小</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestNiceSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ch = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            type |= <span class="hljs-number">1</span> &lt;&lt; (Character.toLowerCase(ch[i]) - <span class="hljs-string">&#x27;a&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">typeNum</span> <span class="hljs-operator">=</span> Integer.bitCount(type);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= typeNum; i++)&#123;<br>            check(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxPos, maxPos + maxLen);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> typeNum)</span>&#123;<br>        <span class="hljs-type">int</span>[] lowCnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span>[] uppCnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                     <span class="hljs-comment">//大小写同时存在的字母个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, total = <span class="hljs-number">0</span>; r &lt; ch.length; r++)&#123;    <span class="hljs-comment">//total：字母种类数(不分大小写)</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> Character.toLowerCase(ch[r]) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (Character.isLowerCase(ch[r]))&#123;<br>                lowCnt[idx]++;<br>                <span class="hljs-keyword">if</span> (lowCnt[idx] == <span class="hljs-number">1</span> &amp;&amp; uppCnt[idx] &gt; <span class="hljs-number">0</span>)&#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                uppCnt[idx]++;<br>                <span class="hljs-keyword">if</span> (uppCnt[idx] == <span class="hljs-number">1</span> &amp;&amp; lowCnt[idx] &gt; <span class="hljs-number">0</span>)&#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            total += (lowCnt[idx] + uppCnt[idx]) == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (total &gt; typeNum)&#123;        <span class="hljs-comment">//右移左边界</span><br>                idx = Character.toLowerCase(ch[l]) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                total -= (lowCnt[idx] + uppCnt[idx]) == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (Character.isLowerCase(ch[l]))&#123;<br>                    --lowCnt[idx];<br>                    <span class="hljs-keyword">if</span> (lowCnt[idx] == <span class="hljs-number">0</span> &amp;&amp; uppCnt[idx] &gt; <span class="hljs-number">0</span>)&#123;<br>                        cnt--;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    --uppCnt[idx];<br>                    <span class="hljs-keyword">if</span> (uppCnt[idx] == <span class="hljs-number">0</span> &amp;&amp; lowCnt[idx] &gt; <span class="hljs-number">0</span>)&#123;<br>                        cnt--;<br>                    &#125;<br>                &#125;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt == typeNum &amp;&amp; r - l + <span class="hljs-number">1</span> &gt; maxLen)&#123;<br>                maxPos = l;<br>                maxLen = r - l + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/%E5%A0%86/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="从朴素优先队列到多路归并"><a href="#从朴素优先队列到多路归并" class="headerlink" title="从朴素优先队列到多路归并"></a>从朴素优先队列到多路归并</h1><ul><li>264.丑数 II</li><li>313.超级丑数</li><li>373.查找和最小的K对数字</li><li>632.最小区间</li><li>719.找出第 k 小的距离对</li><li>786.第 K 个最小的素数分数</li><li>1439.有序矩阵中的第 k 个最小数组和</li><li>1508.子数组和排序后的区间和</li><li>1675.数组的最小偏移量</li></ul><h2 id="1036-逃离大迷宫"><a href="#1036-逃离大迷宫" class="headerlink" title="1036. 逃离大迷宫"></a>1036. 逃离大迷宫</h2><p>压缩网格 + BFS</p><p>使用 TreeSet 实现网格数据升序排列。</p><h2 id="373-查找和最小的K对数字"><a href="#373-查找和最小的K对数字" class="headerlink" title="373. 查找和最小的K对数字"></a>373. 查找和最小的K对数字</h2><p>给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。</p><p>定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。</p><p>请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  …  (uk,vk) 。</p><p>示例 1:</p><p>输入: nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3</p><p>输出: [1,2],[1,4],[1,6]</p><p>解释: 返回序列中的前 3 对数：</p><p>[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</p><p>提示:</p><ul><li>1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 10^4</li><li>10^9 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 10^9</li><li>nums1, nums2 均为升序排列</li><li>1 &lt;&#x3D; k &lt;&#x3D; 1000</li></ul><p><strong>思路：</strong> 优先队列 &#x2F; 二分查找</p><p>乍一看以为暴力能过，但是针对：[1,1,2]、[1,2,3]、10 这样的并不好模拟</p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>两数组已经升序排列，按照任取俩数之<strong>和</strong> 放入 优先队列，实现只取前 k 个出来：</p><ul><li><p>为了避免重复加入，可以先将 nums1 的前 k 个索引数对 (0,0),(1,0),…,(k−1,0) 加入到队列中</p></li><li><p>再取出堆顶元素，逐个将 nums2 的索引增加。</p></li><li><p>对于成对的数组，想逐个加入 list 中可以使用 **Arrays.asList&lt;&gt;()**：而无需新建再遍历数组</p><ul><li>res.add(Arrays.asList(nums1[top[0]], nums2[top[1]]));</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> (nums1[o1[<span class="hljs-number">0</span>]] + nums2[o1[<span class="hljs-number">1</span>]]) - (nums1[o2[<span class="hljs-number">0</span>]] + nums2[o2[<span class="hljs-number">1</span>]]);<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Math.min(nums1.length, k); i++)&#123;<br>        pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, <span class="hljs-number">0</span>&#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span> &amp;&amp; !pq.isEmpty())&#123;<br>        <span class="hljs-type">int</span>[] top = pq.poll();<br>        res.add(Arrays.asList(nums1[top[<span class="hljs-number">0</span>]], nums2[top[<span class="hljs-number">1</span>]]));<br><br>        <span class="hljs-keyword">if</span> (top[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> &lt; nums2.length)&#123;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;top[<span class="hljs-number">0</span>], top[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>&#125;);<br>        &#125;<br>        k--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分性：点对和小于 x 的个数 一定少于 点对和 大于等于 x 的个数</p><ul><li><p>两数组升序，可得任意 数对和 的最小值和最大值：</p><ul><li>l &#x3D; nums1[0] + nums2[0]、r &#x3D; nums1[m - 1] + nums2[n - 1]</li></ul></li><li><p>在值域 [l,r] 上进行二分，找到第一个满足<strong>点对和小于等于 x，且数量超过 k 的值 x</strong></p><ul><li><p>数量计算利用 二分性，直接暴力会超时。</p></li><li><p>存在不同点对 和 相同的情况：</p><ul><li>先将和小于 x 的点对加入答案，再酌情将 等于 x 的点对加入。暴力双层循环也会超时</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> nums1[<span class="hljs-number">0</span>] + nums2[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums1[m - <span class="hljs-number">1</span>] + nums2[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//二分查找 第k小的 数对和 大小</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> r;        <span class="hljs-comment">//去找第一个和小于等于 x 的 数对 大于等于 k 个</span><br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ed = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (st &lt; m &amp;&amp; ed &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span> (nums1[st] + nums2[ed] &gt; mid)&#123;<br>                ed--;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                cnt += ed + <span class="hljs-number">1</span>;<br>                st++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (cnt &lt; k)&#123;      <span class="hljs-comment">//说明 mid 取小了，导致 数对个数 少于 k 个</span><br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            x = mid;<br>            r = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">//当前满足 &gt;= k 个的数值已经被 x 记录了，就算下一轮循环不满足条件直接退出也不影响</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//先将 小于 x 的数对加入 answer</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//放在循环之外，因为随着 value 的增大，pos 的位置肯定是逐渐减小的</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : nums1) &#123;<br>        <span class="hljs-keyword">while</span> (pos &gt;= <span class="hljs-number">0</span> &amp;&amp; value + nums2[pos] &gt;= x) &#123;<br>            pos--;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= pos &amp;&amp; k &gt; <span class="hljs-number">0</span>; j++, k--) &#123;<br>            res.add(Arrays.asList(value, nums2[j]));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//再将 等于 x 的值加入 answer</span><br>    pos = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">while</span> (pos &gt;= <span class="hljs-number">0</span> &amp;&amp; nums1[i] + nums2[pos] &gt; x) &#123;<br>            pos--;<br>        &#125;<br>    <span class="hljs-comment">//固定 pos 即 j，滑动 i 来看是否有等于的数对</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; k &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums1[j] + nums2[pos] == x; j--, k--) &#123;<br>            res.add(Arrays.asList(nums1[j], nums2[pos]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a>264. 丑数 II</h2><p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p><p>丑数 就是只包含质因数 2、3 和&#x2F;或 5 的正整数。</p><p>示例 1：</p><p>输入：n &#x3D; 10</p><p>输出：12</p><p>解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</p><p>示例 2：</p><p>输入：n &#x3D; 1</p><p>输出：1</p><p>解释：1 通常被视为丑数。</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 1690</p><p><strong>思路：</strong></p><ol><li><p>普通优先队列，先将1进队，再顺次放入其 2、3、5倍的数字</p><ul><li>要去重、判断是否超出 int 型数据的范围。击败 5 %</li></ul></li></ol><h3 id="多路归并（多指针）"><a href="#多路归并（多指针）" class="headerlink" title="多路归并（多指针）"></a>多路归并（多指针）</h3><ul><li><p>最小堆预先存储了较多丑数，且维护最小堆的过程导致时间复杂度较高（n log n）</p></li><li><p>而所有丑数都是基于 原先丑数 乘以 质因数 2、3、5 得来的。如何不重复计算序列？</p><ul><li><p>对于丑数序列 a1,a2,…,an，序列中的每一个数都必然能够被以下三个序列（中的至少一个）覆盖：</p><ul><li><p>由丑数 × 2 所得的有序序列：1 × 2，2 × 2，3 × 2，4 × 2，5 × 2，6 × 2，8 × 2，…</p></li><li><p>由丑数 × 3 所得的有序序列：1 × 3，2 × 3，3 × 3，4 × 3，5 × 3，6 × 3，8 × 3，…</p></li><li><p>由丑数 × 5 所得的有序序列：1 × 5，2 × 5，3 × 5，4 × 5，5 × 5，6 × 5，8 × 5，…</p></li></ul></li></ul></li><li><p>这相当于 3个数组，分别是能被2、3、5整除的递增数组，且每个数组的第一个数都为1。</p><ul><li><p>无需列出这3个数组，在传统双指针的基础上动态维护<strong>三指针</strong>，将三个数组合并为严格递增的数组。</p></li><li><p>一边移指针，一边算各个数组的下一个数，一边merge</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-comment">//dp[i] 表示第 i 个丑数</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];    <span class="hljs-comment">//dp[0] 舍弃</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//三指针表示下一个丑数是当前指针指向的丑数乘以对应的质因数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, i3 = <span class="hljs-number">1</span>, i5 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> dp[i2] * <span class="hljs-number">2</span>, b = dp[i3] * <span class="hljs-number">3</span>, c = dp[i5] * <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Math.min(a, Math.min(b, c));<br>        dp[i] = num;<br><br>    <span class="hljs-comment">//有 6 = 2 * 3 和 3 * 2 重复计算的情况，都将指针更新到最新</span><br>        <span class="hljs-keyword">if</span> (a == num) i2++;<br>        <span class="hljs-keyword">if</span> (b == num) i3++;<br>        <span class="hljs-keyword">if</span> (c == num) i5++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数论</title>
    <link href="/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/%E6%95%B0%E8%AE%BA/"/>
    <url>/earsh9.github.io/2022/08/04/%E5%85%B6%E4%BB%96/%E6%95%B0%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="取余基础"><a href="#取余基础" class="headerlink" title="取余基础"></a>取余基础</h3><ul><li>(a + b) % mod &#x3D; ((a % mod) + (b % mod)) % mod</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">证明：设 p 为 a 和 b 的最大公约数，则<br>a = k0 * p + r0;<br>b = k1 * p + r1;<br>(a + b) % p = [(k0 + k1) * p + r0 + r1] % p = (r0 + r1) % p;<br>(a % p + b % p) % p = (r0 + r1) % p; 即证<br></code></pre></td></tr></table></figure><ul><li>(a - b) % mod &#x3D; ((a % mod) - (b % mod) + mod) % mod;       &#x2F;&#x2F;预防作差结果为负</li><li>(a * b) % mod &#x3D; ((a % mod) * (b % mod)) % mod;</li><li>没有相除的操作！需考虑逆元</li></ul><h3 id="欧几里得算法：求最大公约数（gcd）"><a href="#欧几里得算法：求最大公约数（gcd）" class="headerlink" title="欧几里得算法：求最大公约数（gcd）"></a>欧几里得算法：求最大公约数（gcd）</h3><p>设 q 为 a、b 的最大公约数，记作 q &#x3D; (a, b)；则 q &#x3D; (a, b) &#x3D; (b, a % b)。</p><p>证明：由定理有</p><p>a &#x3D; k1 * q</p><p>b &#x3D; k2 * q</p><p>要证第二个等号相等，即证 a % b 的最大公约数也是 q。</p><p>即设 a % b &#x3D; r，求 r 是多少？</p><p>a &#x3D; k * b + r</p><p>r &#x3D; k1 * q - k * k2 * q &#x3D; (k1 - k2 * k) * q。即证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> gcd(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>扩展欧几里得<ul><li>限定 a 、b、c、x、y 为整数</li><li>给出一个 a * x + b * y &#x3D; c，可以求出 x 和 y</li><li>例如：10x + 15y &#x3D; 5，x &#x3D; ？，y &#x3D; ？</li></ul></li></ul><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>在实数域（R域）中，若 x * y &#x3D; 1，则 x 与 y 互为逆元。</p><p>找逆元的方法：</p><ol><li>扩展欧几里得</li><li>费马舍定理</li><li>欧拉定理</li></ol><p>在取模的运算中，对任意 x % p 使得值在 [0,p) 范围内；p 为质数的情况下，1 ~ p - 1 的数均可找到逆元。</p><p>(2 * x) % p &#x3D;&#x3D; 1，p &#x3D; 7，求 x &#x3D; ?</p><p>x &#x3D; 4；(2 * 4) % 7 &#x3D;&#x3D; 1。</p><p>2 与 4 互为逆元；1 的逆元为本身；3 与 5 互为逆元；6 的逆元为本身。</p><h2 id="2156-查找给定哈希值的子串"><a href="#2156-查找给定哈希值的子串" class="headerlink" title="2156. 查找给定哈希值的子串"></a>2156. 查找给定哈希值的子串</h2><p>给定整数 p 和 m ，一个长度为 k 且下标从 0 开始的字符串 s 的哈希值按照如下函数计算：</p><p>hash(s, p, m) &#x3D; (val(s[0]) * p0 + val(s[1]) * p1 + … + val(s[k-1]) * pk-1) mod m.</p><p>其中 val(s[i]) 表示 s[i] 在字母表中的下标，从 val(‘a’) &#x3D; 1 到 val(‘z’) &#x3D; 26 。</p><p>给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。</p><p>请你返回 s 中 第一个 长度为 k 的 子串 sub ，满足 hash(sub, power, modulo) &#x3D;&#x3D; hashValue 。</p><p>测试数据保证一定 存在 至少一个这样的子串。</p><p>子串 定义为一个字符串中连续非空字符组成的序列。<br> <br>示例 1：</p><p>输入：s &#x3D; “leetcode”, power &#x3D; 7, modulo &#x3D; 20, k &#x3D; 2, hashValue &#x3D; 0</p><p>输出：”ee”</p><p>解释：”ee” 的哈希值为 hash(“ee”, 7, 20) &#x3D; (5 * 1 + 5 * 7) mod 20 &#x3D; 40 mod 20 &#x3D; 0 。</p><p>“ee” 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 “ee” 。</p><p><strong>思路：</strong></p><ol><li><p>暴力选定窗口再计算哈希值会超限，考虑复用之前的计算的结果。</p></li><li><p>正向滑动窗口：</p><ul><li><p>第一个窗口：<code>(x0*p^0 + x1*p^1 + ... + xk-1*p^k-1) % mod = value</code>，若value !&#x3D; hashvalue</p></li><li><p>第二个窗口：减去第一项再添加一项 <code>xk*p^k</code>；且现存的每一项都要除以 p，因为多了一次幂</p></li></ul></li><li><p>问题在于 value 是取模后的结果，即 (a*p) % mod，需要知道 p 的逆元 x 才能保证前后系数不变：</p><ul><li><code>(a * p * x) % mod == a</code></li><li>例如：p &#x3D; 2，mod &#x3D; 7，需知道 2 的逆元为 4，才能保证在取模的情况下除以 p 并不改变系数的大小：</li><li><code>a * 2 * 4 % 7 = a % 7 * 8 % 7 = a</code></li></ul></li><li><p>而若 mod 非质数，逆元不一定存在。如：2 * x % 20 &#x3D; 1，求 x &#x3D; ？</p></li><li><p>逆向滑动窗口采用乘以 p 的方式，取模运算中一样可以。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">subStrHash</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> power, <span class="hljs-type">int</span> modulo, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> hashValue)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><br>    <span class="hljs-type">int</span>[] v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>        v[j++] = c - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//逆向的第一个窗口</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= n - k; i--)&#123;<br>        h = (h * power + v[i]) % modulo;<br>        p = p * power % modulo;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> n - k;                          <span class="hljs-comment">//默认是最后一个窗口</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;       <span class="hljs-comment">//i：待加的窗口</span><br>        h = (h * power + v[i] - v[i + k] * p % modulo + modulo) % modulo;           <span class="hljs-comment">// + modulo 是为了防止溢出; 每个待减的项都是 v[i+k] * p^(k-1) 即上一个for循环的结果 p</span><br>        <span class="hljs-keyword">if</span> (h == hashValue) index = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.substring(index,index + k);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计算自然数-num-的数根"><a href="#计算自然数-num-的数根" class="headerlink" title="计算自然数 num 的数根"></a>计算自然数 num 的数根</h3><p>每个自然数都有一个数根。对于给定的自然数，反复将各个位上的数字相加，直到结果为一位数，则该一位数即为原自然数的数根</p><h2 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258. 各位相加"></a>258. 各位相加</h2><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p><p><strong>除了O(n) 的模拟外，如何在 O(1) 的时间复杂度下实现？</strong></p><ul><li><p>对于自然数 abc &#x3D; 100 * a + 10 * b + c</p></li><li><p>一次各位相加后为: a + b + c</p></li><li><p>中间差值为 99 * a + 9 * b</p></li><li><p>相当于 num 对 9 取模</p></li><li><p>若取模结果为0，例如 99 % 9 &#x3D;&#x3D; 0，9 + 9 -&gt; 18，1 + 8 -&gt; 9，直接return 9</p></li><li><p>否则return 对 9 取模的结果，例如 83 % 9 &#x3D; 2，8 + 3 -&gt; 11 -&gt; 2</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-comment">// if ( num == 0 ) return 0;</span><br>    <span class="hljs-comment">// if ( num % 9 == 0 ) return 9;</span><br>    <span class="hljs-comment">// return num % 9;</span><br><br>    <span class="hljs-comment">//利用 10 ^ n 对 9 取模恒为 1</span><br>    <span class="hljs-keyword">return</span> (num - <span class="hljs-number">1</span>) % <span class="hljs-number">9</span> + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//若 num % 9 == 0，(num - 1) % 9 == 8，后 + 1 正好为 9</span><br>    <span class="hljs-comment">//若 num = 10 ^ n，(num - 1) % 9 == 0，后 + 1 正好为 1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当 num &#x3D; 0 时，num − 1 &#x3D; −1 &lt; 0，负数对 9 取余或取模的结果的正负在不同语言中有所不同。</p><p>对于取余的语言，结果的正负和左操作数相同，则 num − 1 对 9 取余的结果为 −1，加 1 后得到结果 0，可以得到正确的结果；**(Java 为此)**</p><p>对于取模的语言，结果的正负和右操作数相同，则 num − 1 对 9 取模的结果为 8，加 1 后得到结果 9，无法得到正确的结果，此时需要对 num &#x3D; 0 的情况专门做处理。</p>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最短路算法</title>
    <link href="/earsh9.github.io/2022/08/04/10.%E5%9B%BE%E8%AE%BA/0.%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    <url>/earsh9.github.io/2022/08/04/10.%E5%9B%BE%E8%AE%BA/0.%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="给定一张有权图，如何求某两点之间的最短路径？"><a href="#给定一张有权图，如何求某两点之间的最短路径？" class="headerlink" title="给定一张有权图，如何求某两点之间的最短路径？"></a>给定一张有权图，如何求某两点之间的最短路径？</h1><ul><li>743.网络延迟时间 提交了所有最短路算法</li></ul><h2 id="三种存图方式"><a href="#三种存图方式" class="headerlink" title="三种存图方式"></a>三种存图方式</h2><p>约定 n 为顶点数，m 为边数</p><ol><li><p>邻接矩阵：适合边数较多的稠密图（m ≈ n^2）</p><ul><li><p>二维矩阵：int[][] g &#x3D; new int[n][n];</p></li><li><p>(x,y)为起点到终点，weight 为权重：g[x][y] &#x3D; weight</p></li></ul></li><li><p>邻接表：适合边数较少的稀疏图（m ≈ n）</p><ul><li><p>又称链式前向星。用数组模拟邻接表，以链表的形式存边。</p><ul><li><p>head[u]：以 u 作为起点的第一条边的编号</p></li><li><p>next[cnt]：编号为 cnt 的边的下一条边，该边与 cnt 同一个起点。</p></li><li><p>to[cnt]：编号为 cnt 的边的终点</p></li><li><p>初始时，令 head[u] &#x3D; cnt &#x3D; 0（或者 -1），表示尚未有边，每个点都是孤立点。(能自圆其说即可)</p></li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];       <span class="hljs-comment">//存储某个节点所对应的边的 集合 / 链表 所对应的头节点</span><br><span class="hljs-type">int</span>[] to = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];         <span class="hljs-comment">//访问某条边的尾节点</span><br><span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];       <span class="hljs-comment">//由于是以链表形式存边的，该数组用于找到下一条边</span><br><span class="hljs-type">int</span>[] val = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];        <span class="hljs-comment">//存权值</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                   <span class="hljs-comment">//对边进行编号</span><br>Arrays.fill(head, -<span class="hljs-number">1</span>);         <span class="hljs-comment">//初始化链表头</span><br><br><span class="hljs-comment">//添边：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span>&#123;           <span class="hljs-comment">//起点为 u, 终点为 v，权重为 w 的边</span><br>   to[cnt] = v;<br>   next[cnt] = head[u];<br>   head[u] = cnt;<br>   val[cnt] = w;<br>   cnt++;<br>&#125;<br><br><span class="hljs-comment">//遍历：先找到 head 节点，依次遍历到结束为止</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> head[u]; i != -<span class="hljs-number">1</span>; i = next[i])&#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> to[i];<br>   ...<br>&#125;<br><br><span class="hljs-comment">//删边：相当于链表里的删点操作。例如删除 e(u, vv)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;      <span class="hljs-comment">//记录待删边的前一条边的编号</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> head[u]; i != -<span class="hljs-number">1</span>; i = next[i])&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> to[i];<br>    <span class="hljs-keyword">if</span>(j == vv)&#123;<br>        <span class="hljs-keyword">if</span>(i == head[u]) head[u] = next[i];    <span class="hljs-comment">//要删的是链表的第一条边</span><br>        <span class="hljs-keyword">else</span> next[last] = next[i];             <span class="hljs-comment">//前一条边的 next 边 就是 当前待删的 i 边的下一条边</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    last = i;<br>&#125;<br><br><span class="hljs-comment">//反向添边</span><br>cnt ^ <span class="hljs-number">1</span> = cnt + <span class="hljs-number">1</span>;   <span class="hljs-comment">//cnt 起始为奇数时</span><br></code></pre></td></tr></table></figure><ul><li>也可以拿结构体来写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> to, next, val;                    <span class="hljs-comment">//终点、下一条边、权重</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Edge</span><span class="hljs-params">(<span class="hljs-type">int</span> to, <span class="hljs-type">int</span> next, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-built_in">this</span>.to = to;<span class="hljs-built_in">this</span>.next = next;<span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] head;<span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;      <span class="hljs-comment">//边编号 从 1 开始</span><br><span class="hljs-keyword">static</span> Edge[] es;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span>&#123;<br>    es[cnt] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>(v, head[u], w);<br>    head[u] = cnt;                 <span class="hljs-comment">//head 指针由 -1 转为指向 边编号</span><br>    cnt++;<br>&#125;<br><br>main()&#123;<br>    head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    Arrays.fill(head, -<span class="hljs-number">1</span>);        <span class="hljs-comment">//初始化时让每条边 .next 都指向 -1，后随着 head[u] 存储的边编号的改变 而像链表一样 顺次排开</span><br>    es = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>[m + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>类：严格要求某操作复杂度要 O(m) 时才会考虑使用(很少用)<ul><li>用 List 存所有边对象，在需要时进行遍历</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>&#123;<br><br>   <span class="hljs-comment">//代表从 x 到 y 有一条权重为 weight 的边</span><br><br>   <span class="hljs-type">int</span> x, y, weight;<br>   Edge(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> weight)&#123;<br>      <span class="hljs-built_in">this</span>.x = x;<br>      <span class="hljs-built_in">this</span>.y = y;<br>      <span class="hljs-built_in">this</span>.weight = weight;<br>   &#125;<br>&#125;<br><br>List&lt;Edge&gt; es = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>...<br><span class="hljs-keyword">for</span>(Edge e : es)&#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Floyd（邻接矩阵存图）"><a href="#Floyd（邻接矩阵存图）" class="headerlink" title="Floyd（邻接矩阵存图）"></a>Floyd（邻接矩阵存图）</h2><p>又称为Floyd-Warshell算法。Warshell算法是离散数学中求传递闭包的算法，两者思想一致。</p><ol><li>Floyd算法是求解 <strong>多源最短路</strong> 时常用算法，经一次算法即可求出任意两点之间的最短距离，且可处理有负权边的情况（但无法处理负权环）</li><li>本质是 <strong>动态规划</strong>，三层 for 循环枚举 中转点 - 起点 - 终点 - 松弛。</li><li>时间复杂度 O(n ^ 3)，空间复杂度 O(n ^ 2)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">floyd</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; p &lt;= n; p++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                w[i][j] = Math.min(w[i][j], w[i][p] + w[p][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><ol><li>求解 <strong>单源最短路</strong> 中最快的算法，缺点：无法处理存在负权边的情况。</li><li>本质是 <strong>贪心</strong>，通过不断调整每个点的“当前距离”最终得到最优结果；必须遍历完整个图！</li></ol><p><strong>算法流程：</strong></p><p>求某一点 s 到其他所有点的最短距离，对于每个点 v 维护一个 “当前距离”（dist[v]）和“是否访问过”(visited[v])。</p><p>首先 dist[s]初始化为0，其他点的距离初始化为无穷，并将所有点初始化为未访问。</p><p>记 u -&gt; v 的边权为weight[u-&gt;v]。然后进行以下步骤：</p><ol><li><p>从所有未访问的点中，找出当前距离最小的，设为u，并将其标记为已访问的。</p></li><li><p>调整u的所有边（若是有向图则为出边）连接的并且未被访问过的点：若weight[u-&gt;v] + dist[u] &lt; dist[v], 则将dist[v]更新为dist[u]+weight[u-&gt;v]。</p></li><li><p>重复1和2步骤，直到所有点都被标记为已访问的，则dist[i]即s到i的最短距离。如果只想求从s到某一点的最短距离，那么当该点被标记为访问过之后可直接退出。</p></li><li><p>补充：如果除了最短距离之外还想求出具体的路径，只需建立一个pre数组，在步骤2后添加操作：pre[v] &#x3D; u（前提是dist[v]被更新）。</p></li></ol><h3 id="朴素版本-O-n-2"><a href="#朴素版本-O-n-2" class="headerlink" title="朴素版本 O(n ^ 2)"></a>朴素版本 O(n ^ 2)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            g[i][j] = g[j][i] = i == j ? <span class="hljs-number">0</span> : INF;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//存图：</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] time : times)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> time[<span class="hljs-number">0</span>], y = time[<span class="hljs-number">1</span>], w = time[<span class="hljs-number">2</span>];<br>        g[x][y] = w;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];      <span class="hljs-comment">//从起点 到 当前点 的距离</span><br>    Arrays.fill(dist, INF);<br>    dist[k] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;      <span class="hljs-comment">//遍历 n 次以确保全图所有顶点均被遍历</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; y &lt;= n; y++)&#123;  <span class="hljs-comment">//寻找未被访问过的、最短路径的起点</span><br>            <span class="hljs-keyword">if</span>(!vis[y] &amp;&amp; (x == -<span class="hljs-number">1</span> || dist[y] &lt; dist[x]))&#123;<br>                x = y;<br>            &#125;<br>        &#125;<br><br>        vis[x] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; y &lt;= n; y++)&#123;   <span class="hljs-comment">//松弛</span><br>            <span class="hljs-keyword">if</span>(dist[y] &gt; dist[x] + g[x][y])&#123;<br>                dist[y] = dist[x] + g[x][y];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化-O-mlogn"><a href="#堆优化-O-mlogn" class="headerlink" title="堆优化 O(mlogn)"></a>堆优化 O(mlogn)</h3><ul><li><p>虽外部一个while内部一个for，但本质只是遍历完了所有边(顶点有vis数组限制)。加上pq.offer()操作，为 <strong>ElogV</strong></p><ul><li>优先队列本质为树，每次入队出队维护的时间复杂度为树高 logV</li></ul></li><li><p>pq.poll()操作为 logV，执行 V 次，即 <strong>VlogV</strong>。</p></li><li><p>二者并行执行，综上时间复杂度为 O(VlogV + ElogV)。一般情况下 E &gt; V，化简为 O(ElogV)。</p><ul><li>当图为稠密图(E &#x3D; V ^ 2)时，时间复杂度为 O(V^2 logE)。此时运行时间上还不如 朴素版本的快。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, k, m;                           <span class="hljs-comment">//全局变量，在任何函数均未执行前已经初始化为 0</span><br><span class="hljs-type">int</span>[] head;<span class="hljs-type">int</span>[] to;                   <span class="hljs-comment">//故此处的数组 不能 new，只能预先声明</span><br><span class="hljs-type">int</span>[] next;<span class="hljs-type">int</span>[] val;<br><span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];to = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>    next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];val = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span>&#123;<br>    next[++cnt] = head[u];<br>    head[u] = cnt;<br>    to[cnt] = v;<br>    val[cnt] = w;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.n = n; <span class="hljs-built_in">this</span>.k = k; m = times.length;<br>    init();<br><br>    Arrays.fill(head, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] time : times) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> time[<span class="hljs-number">0</span>], v = time[<span class="hljs-number">1</span>], w = time[<span class="hljs-number">2</span>];<br>        add(u, v, w);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    Arrays.fill(dist, INF);<br>    dist[k] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br><br>    PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]));<br>    pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;k, <span class="hljs-number">0</span>&#125;);           <span class="hljs-comment">//(点编号，到起点的距离）</span><br><br>    <span class="hljs-keyword">while</span> (!pq.isEmpty())&#123;<br>        <span class="hljs-type">int</span>[] poll = pq.poll();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], step = poll[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">if</span> (vis[id]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> head[id]; i != <span class="hljs-number">0</span>; i = next[i])&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> to[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[id] + val[i])&#123;<br>                dist[j] = dist[id] + val[i];<br>                pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;j, dist[j]&#125;);<br>            &#125;<br>        &#125;<br>        vis[id] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Bellmon-Ford-算法"><a href="#Bellmon-Ford-算法" class="headerlink" title="Bellmon-Ford 算法"></a>Bellmon-Ford 算法</h2><ul><li><p>单源最短路算法。时间复杂度为 O(nm)，虽不如 Dijkstra 快，但能处理 负权边 和 负权环 的情况。</p></li><li><p>原理：<strong>对于一个不包含 负权环 的 n 个点的图，任意两点之间的最短路径 至多 包含 n - 1 条边。</strong></p><ul><li>如果存在 负权环，每次在负权环上走一圈，都会使换上每一点的距离减少，因此不存在最短路。BF算法可以检测出这一点。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>&#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        Edge(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)&#123;<br>            <span class="hljs-built_in">this</span>.u = u;<span class="hljs-built_in">this</span>.v = v; <span class="hljs-built_in">this</span>.w = w;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BF</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Edge&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] time : times) &#123;      <span class="hljs-comment">//添边</span><br>            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>(time[<span class="hljs-number">0</span>], time[<span class="hljs-number">1</span>], time[<span class="hljs-number">2</span>]));<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];       <span class="hljs-comment">//源点 到 当前点的最短距离</span><br>        Arrays.fill(dist, INF);<br>        dist[k - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;               <span class="hljs-comment">//源点 k，存点从 0 开始所以需减一</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;   <span class="hljs-comment">//遍历 n 次</span><br>            <span class="hljs-keyword">for</span> (Edge edge : edges) &#123;  <span class="hljs-comment">//暴力地去遍历每条边来检查哪些点的当前距离可以更新</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> edge.u, to = edge.v, weight = edge.w;<br>                <span class="hljs-keyword">if</span> (dist[to - <span class="hljs-number">1</span>] &gt; dist[from] + weight)&#123;<br>                    dist[to - <span class="hljs-number">1</span>] = dist[from] + weight;<br><span class="hljs-comment">//                    pre[to] = pre[from];     用于记录具体的最短路径</span><br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="SPFA：对BF的改进"><a href="#SPFA：对BF的改进" class="headerlink" title="SPFA：对BF的改进"></a>SPFA：对BF的改进</h2><ul><li><p>BF 为暴力的检查哪些点的距离可以被更新</p></li><li><p>SPFA优化为采用类似bfs的思想，使用 队列 或 栈 进行有选择的选取</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">spfa</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    Arrays.fill(dist, INF);<br>    dist[k] = <span class="hljs-number">0</span>;<br><br>    Deque&lt;Integer&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();   <span class="hljs-comment">//点编号</span><br>    <span class="hljs-type">boolean</span>[] inque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>    dq.addLast(k);<br>    inque[k] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (!dq.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> dq.pollFirst();<br>        inque[poll] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> head[poll]; i != <span class="hljs-number">0</span>; i = next[i])&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> to[i], w = val[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[poll] + w)&#123;<br>                dist[j] = dist[poll] + w;<br>                <span class="hljs-keyword">if</span> (inque[j]) <span class="hljs-keyword">continue</span>;<br>                dq.addLast(j);<br>                inque[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>图论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最短路相关延申</title>
    <link href="/earsh9.github.io/2022/08/04/10.%E5%9B%BE%E8%AE%BA/1.%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9B%B8%E5%85%B3%E5%BB%B6%E4%BC%B8/"/>
    <url>/earsh9.github.io/2022/08/04/10.%E5%9B%BE%E8%AE%BA/1.%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9B%B8%E5%85%B3%E5%BB%B6%E4%BC%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路-一题多解"><a href="#最短路-一题多解" class="headerlink" title="最短路 一题多解"></a>最短路 一题多解</h1><h2 id="2045-到达目的地的第二短时间"><a href="#2045-到达目的地的第二短时间" class="headerlink" title="2045. 到达目的地的第二短时间"></a>2045. 到达目的地的第二短时间</h2><p>城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示，其中每个 edges[i] &#x3D; [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。每组节点对由 最多一条 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 time 分钟。</p><p>每个节点都有一个交通信号灯，每 change 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 同时 改变。你可以在 任何时候 进入某个节点，但是 只能 在节点 信号灯是绿色时 才能离开。如果信号灯是  绿色 ，你 不能 在节点等待，必须离开。</p><p>第二小的值 是 严格大于 最小值的所有值中最小的值。</p><p>例如，[2, 3, 4] 中第二小的值是 3 ，而 [2, 2, 4] 中第二小的值是 4 。<br>给你 n、edges、time 和 change ，返回从节点 1 到节点 n 需要的 第二短时间 。</p><p>注意：</p><p>你可以 任意次 穿过任意顶点，包括 1 和 n 。<br>你可以假设在 启程时 ，所有信号灯刚刚变成 绿色 。</p><img src = "https://assets.leetcode.com/uploads/2021/09/29/e1.png" width = "25%"><img src = "https://assets.leetcode.com/uploads/2021/09/29/e2.png" width = "25%"><p>输入：n &#x3D; 5, edges &#x3D; [[1,2],[1,3],[1,4],[3,4],[4,5]], time &#x3D; 3, change &#x3D; 5</p><p>输出：13</p><p>解释：</p><p>上面的左图展现了给出的城市交通图。右图中的蓝色路径是最短时间路径。</p><p>花费的时间是：</p><ul><li>从节点 1 开始，总花费时间&#x3D;0</li><li>1 -&gt; 4：3 分钟，总花费时间&#x3D;3</li><li>4 -&gt; 5：3 分钟，总花费时间&#x3D;6</li></ul><p>因此需要的最小时间是 6 分钟。</p><p>右图中的红色路径是第二短时间路径。</p><ul><li>从节点 1 开始，总花费时间&#x3D;0</li><li>1 -&gt; 3：3 分钟，总花费时间&#x3D;3</li><li>3 -&gt; 4：3 分钟，总花费时间&#x3D;6</li><li>在节点 4 等待 4 分钟，总花费时间&#x3D;10</li><li>4 -&gt; 5：3 分钟，总花费时间&#x3D;13</li></ul><p>因此第二短时间是 13 分钟。</p><h3 id="在一张正权无向图上求严格次短路，该图无重边与自环"><a href="#在一张正权无向图上求严格次短路，该图无重边与自环" class="headerlink" title="在一张正权无向图上求严格次短路，该图无重边与自环"></a>在一张正权无向图上求严格次短路，该图无重边与自环</h3><p>由提示 edges.length &lt;&#x3D; min(2 * 10^4, n(n - 1) &#x2F; 2) 知该图为稀松图。</p><p><strong>无 vis 数组，次短路有可能出现节点复走的情况：</strong></p><h4 id="method1-堆优化-Dijkatra"><a href="#method1-堆优化-Dijkatra" class="headerlink" title="method1 : 堆优化 Dijkatra"></a>method1 : 堆优化 Dijkatra</h4><p>在 [最短路] 的基础上 再加一个 [严格次短路] 数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> n, m, cnt;<br><span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] head;<span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] to;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] next;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    to = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span> * m + <span class="hljs-number">2</span>];<br>    next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span> * m + <span class="hljs-number">2</span>];<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span>&#123;<br>    next[++cnt] = head[u];<br>    head[u] = cnt;<br>    to[cnt] = v;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">secondMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> time, <span class="hljs-type">int</span> change)</span> &#123;<br>    <span class="hljs-built_in">this</span>.n = n;<span class="hljs-built_in">this</span>.m = edges.length;<br>    init();<br>    Arrays.fill(head, -<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>        add(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);   <span class="hljs-comment">//无向图两边都要加且数组初始化也要 *2</span><br>        add(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dist1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];     <span class="hljs-comment">//最短路径</span><br>    <span class="hljs-type">int</span>[] dist2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];     <span class="hljs-comment">//次短路径</span><br>    Arrays.fill(dist1, INF);<br>    Arrays.fill(dist2, INF);<br>    dist1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]));<br>    pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);           <span class="hljs-comment">//点编号，路径长度</span><br><br>    <span class="hljs-keyword">while</span> (!pq.isEmpty())&#123;<br>        <span class="hljs-type">int</span>[] poll = pq.poll();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], step = poll[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> head[id]; i != -<span class="hljs-number">1</span>; i = next[i])&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> to[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> step / change, b = step % change;    <span class="hljs-comment">//例:当前所花时间为6min,每5min改变一次,6/5=1,奇数次,需等待 change - 6%5分钟</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">wait</span> <span class="hljs-operator">=</span> (a &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : change - b;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dist</span> <span class="hljs-operator">=</span> step + time + wait;<br>            <span class="hljs-keyword">if</span> (dist &lt; dist1[j])&#123;<br>                dist2[j] = dist1[j];<br>                dist1[j] = dist;<br>                pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;j, dist1[j]&#125;);<br>                pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;j, dist2[j]&#125;);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dist &gt; dist1[j] &amp;&amp; dist &lt; dist2[j])&#123;<br>                dist2[j] = dist;<br>                pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;j, dist2[j]&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist2[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="method2-BFS，既然边权一致，先求步数后算时间"><a href="#method2-BFS，既然边权一致，先求步数后算时间" class="headerlink" title="method2 : BFS，既然边权一致，先求步数后算时间"></a>method2 : BFS，既然边权一致，先求步数后算时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">secondMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> time, <span class="hljs-type">int</span> change)</span> &#123;<br>    List&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n + <span class="hljs-number">1</span>];         <span class="hljs-comment">//list类型的数组比 Map 更快些</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        graph[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>        graph[edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>        graph[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[][] path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];         <span class="hljs-comment">//记录两个指标：到达节点 i 的 最小 和 次小 步长</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        Arrays.fill(path[i], Integer.MAX_VALUE);<br>    &#125;<br>    path[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);<br><br>    <span class="hljs-comment">//没有 visit 数组的原因在于：次小路径有可能出现节点复走</span><br>    <span class="hljs-keyword">while</span> (path[n][<span class="hljs-number">1</span>] == Integer.MAX_VALUE)&#123;<br>        <span class="hljs-type">int</span>[] cur = queue.poll();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>], step = cur[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : graph[node]) &#123;<br>            <span class="hljs-keyword">if</span> (step + <span class="hljs-number">1</span> &lt; path[i][<span class="hljs-number">0</span>])&#123;           <span class="hljs-comment">//只计算所走的节点个数，比较后的最小 或者 次小 都可以加入队列</span><br>                path[i][<span class="hljs-number">0</span>] = step + <span class="hljs-number">1</span>;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, step + <span class="hljs-number">1</span>&#125;);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step + <span class="hljs-number">1</span> &gt; path[i][<span class="hljs-number">0</span>] &amp;&amp; step + <span class="hljs-number">1</span> &lt; path[i][<span class="hljs-number">1</span>])&#123;<br>                path[i][<span class="hljs-number">1</span>] = step + <span class="hljs-number">1</span>;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, step + <span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; path[n][<span class="hljs-number">1</span>]; i++) &#123;               <span class="hljs-comment">//path[n][1] 为第二小路径所经过的节点个数</span><br>        <span class="hljs-keyword">if</span> (ret % (<span class="hljs-number">2</span> * change) &gt;= change)&#123;              <span class="hljs-comment">//只有到达当前节点时间 与 一轮红绿灯时间 取余的结果 又刚变红灯不就要等了</span><br>            ret += (<span class="hljs-number">2</span> * change - ret % (<span class="hljs-number">2</span> * change));<br>        &#125;<br>        ret += time;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="method3：AStar-算法（启发式算法）"><a href="#method3：AStar-算法（启发式算法）" class="headerlink" title="method3：AStar 算法（启发式算法）"></a>method3：AStar 算法（启发式算法）</h4><p>将问题拓展为「使用 AStar 算法来找第 K 短路」（修改代码的 K 即可）</p><p><strong>利用终点的第 k 次出队必然是第 k 短路（注意要求的是严格的第 k 短路）。</strong></p><ol><li><p>AStar 算法：计算公式为 F &#x3D; G + H</p><ul><li><p>其中 G 为 Dijkstra 算法所计算的从 源点s 到 i 的最短距离，我们要求的也是 第 K 小的 G。（Dijkstra 算法的计算公式就是 F &#x3D; G）</p></li><li><p>H 为点 i 到 终点 的距离，因为此题所有边权一样直接 step + 1 即可。</p></li></ul></li><li><p>优先队列里是按 F 进行升序排列的，即我们找到的是从 s 途径 i 的最小距离 而不是 s 到 i 的最小距离！</p><ul><li>但如果只求 源点s 到 终点n 的最短距离，此时 H &#x3D; 0，最小的 F 就是 最小的 G</li></ul></li><li><p>类似的还有 -127.单词接龙（超限）</p><ul><li>A* 算法需预先证明正确性，在数据量较大时若无法很好提前判断「是否有解」， Astar 将不能带来「搜索空间的优化」，效果不如「双向 BFS」。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> to, next;       <span class="hljs-comment">//终点、下一条边；权重 val 一般也放在这里</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Edge</span><span class="hljs-params">(<span class="hljs-type">int</span> to, <span class="hljs-type">int</span> next)</span>&#123;<br>        <span class="hljs-built_in">this</span>.to = to;<span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] head;<span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;      <span class="hljs-comment">//边编号 从 1 开始</span><br><span class="hljs-keyword">static</span> Edge[] es;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span>&#123;<br>    es[cnt] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>(v, head[u]);<br>    head[u] = cnt;                 <span class="hljs-comment">//head 指针由 -1 转为指向 边编号</span><br>    cnt++;<br>&#125;<br><br><span class="hljs-type">int</span>[] dist;<span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n;<span class="hljs-type">int</span>[][] edges;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">secondMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> time, <span class="hljs-type">int</span> change)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> edges.length;<br>    head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    es = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>[<span class="hljs-number">2</span> * m + <span class="hljs-number">1</span>];<br>    Arrays.fill(head, -<span class="hljs-number">1</span>);               <span class="hljs-comment">//初始化时让每条边 .next 都指向 -1，后随着 head[u] 存储的边编号的改变 而像链表一样 顺次排开</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>        add(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>        add(edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">this</span>.n = n;<span class="hljs-built_in">this</span>.edges = edges;<br>    bfs();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> Astar(<span class="hljs-number">2</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cnt; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> ans / change, b = ans % change;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wait</span> <span class="hljs-operator">=</span> (a &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : change - b;<br>        ans += time + wait;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">()</span>&#123;<br>    Arrays.fill(dist, INF);<br>    Deque&lt;Integer&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    dq.addLast(n);<br>    dist[n] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (!dq.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> dq.pollFirst(), step = dist[x];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> head[x]; i != -<span class="hljs-number">1</span>; i = es[i].next)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> es[i].to;<br>            <span class="hljs-keyword">if</span> (dist[j] != INF) <span class="hljs-keyword">continue</span>;<br>            dist[j] = step + <span class="hljs-number">1</span>;<br>            dq.addLast(j);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Astar</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1[<span class="hljs-number">2</span>] - o2[<span class="hljs-number">2</span>]);<br>    pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, dist[<span class="hljs-number">1</span>]&#125;);     <span class="hljs-comment">//F : 0 + dist[1]</span><br><br>    <span class="hljs-keyword">while</span> (!pq.isEmpty())&#123;<br>        <span class="hljs-type">int</span>[] poll = pq.poll();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> poll[<span class="hljs-number">0</span>], step = poll[<span class="hljs-number">1</span>];   <span class="hljs-comment">//step 为 G</span><br>        <span class="hljs-keyword">if</span> (x == n &amp;&amp; min != step)&#123;<br>            min = step;<br>            <span class="hljs-keyword">if</span> (--k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> min;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> head[x]; i != -<span class="hljs-number">1</span>; i = es[i].next)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> es[i].to;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;j, step + <span class="hljs-number">1</span>, step + <span class="hljs-number">1</span> + dist[j]&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a>127. 单词接龙</h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk：</p><p>每一对相邻的单词只差一个字母。</p><p>对于 1 &lt;&#x3D; i &lt;&#x3D; k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。sk &#x3D;&#x3D; endWord</p><p>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。</p><p>示例 1：</p><p>输入：beginWord &#x3D; “hit”, endWord &#x3D; “cog”, wordList &#x3D; [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>输出：5</p><p>解释：一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”, 返回它的长度 5。</p><h3 id="双向-bfs：解决搜索空间爆炸问题"><a href="#双向-bfs：解决搜索空间爆炸问题" class="headerlink" title="双向 bfs：解决搜索空间爆炸问题"></a>双向 bfs：解决搜索空间爆炸问题</h3><ul><li><p>创建「两个队列」分别用于两个方向的搜索；</p></li><li><p>创建「两个哈希表」用于「解决相同节点重复搜索」和「记录转换次数」；</p></li><li><p>为了尽可能让两个搜索方向“平均”，每次从队列中取值进行扩展时，先判断哪个队列容量较少；</p></li><li><p>如果在搜索过程中「搜索到对方搜索过的节点」，说明找到了最短路径。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//wordList 不单拎出来都会超限</span><br>List&lt;String&gt; wordList;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ladderLength0</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!wordList.contains(endWord)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.wordList = wordList;<br><br>    Deque&lt;String&gt; d1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(), d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    d1.addLast(beginWord);<br>    d2.addLast(endWord);<br><br>    Map&lt;String, Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();      <span class="hljs-comment">//当前单词，从不同方向替换了多少次才变成的</span><br>    map1.put(beginWord, <span class="hljs-number">0</span>);<br>    map2.put(endWord, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!d1.isEmpty() &amp;&amp; !d2.isEmpty())&#123;<br>        <span class="hljs-keyword">if</span> (d1.size() &lt;= d2.size())&#123;<br>            t = update(d1, map1, map2);<br>        &#125;<span class="hljs-keyword">else</span> t = update(d2, map2, map1);<br>        <span class="hljs-keyword">if</span> (t != -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;                       <span class="hljs-comment">//t 算的是转换次数，题目求的是转换序列的单词数目</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> t == -<span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : t + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Deque&lt;String&gt; dq, Map&lt;String, Integer&gt; map1, Map&lt;String, Integer&gt; map2)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> dq.size();<br>    <span class="hljs-keyword">while</span> (m-- &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> dq.pollFirst();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> map1.getOrDefault(s, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">//枚举</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;        <span class="hljs-comment">//第几位被替换</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++)&#123;            <span class="hljs-comment">//被替换成啥字母</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">0</span>,i) + (<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;a&#x27;</span> + j) + s.substring(i + <span class="hljs-number">1</span>);  <span class="hljs-comment">//注意替换后还要char回来！</span><br>                <span class="hljs-keyword">if</span> (!wordList.contains(sub)) <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-keyword">if</span> (map2.containsKey(sub)) <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span> + map2.get(sub);<br><br>                <span class="hljs-keyword">if</span> (!map1.containsKey(sub)) &#123;<br>                    dq.addLast(sub);<br>                    map1.put(sub, step + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bfs-优化建图"><a href="#bfs-优化建图" class="headerlink" title="bfs + 优化建图"></a>bfs + 优化建图</h3><ul><li>所有单词长度相同，用带 * 号 一次性取代 替换 26个字母的for循环，更高效。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;String, Integer&gt; wordId = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();   <span class="hljs-comment">//单词(边),边编号</span><br>    List&lt;List&lt;Integer&gt;&gt; edge = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-comment">//存图</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nodeNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String word : wordList) &#123;<br>            addEdge(word);<br>        &#125;<br>        addEdge(beginWord);<br>        <span class="hljs-keyword">if</span> (!wordId.containsKey(endWord)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span>[] dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nodeNum];<br>        Arrays.fill(dist, Integer.MAX_VALUE);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stId</span> <span class="hljs-operator">=</span> wordId.get(beginWord), edId = wordId.get(endWord);<br>        dist[stId] = <span class="hljs-number">0</span>;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        queue.offer(stId);<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curId</span> <span class="hljs-operator">=</span> queue.poll(), step = dist[curId];<br>            <span class="hljs-keyword">if</span> (curId == edId)&#123;<br>                <span class="hljs-keyword">return</span> step / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-comment">//每个单词 都是 通过带 * 号的中间单词 变换到另一个 List 中的单词的</span><br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nxtId : edge.get(curId))&#123;<br>                <span class="hljs-keyword">if</span> (dist[nxtId] == Integer.MAX_VALUE)&#123;<br>                    dist[nxtId] = step + <span class="hljs-number">1</span>;<br>                    queue.offer(nxtId);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(String s)</span>&#123;<br>        addWord(s);<br>        <span class="hljs-type">char</span>[] ch = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id1</span> <span class="hljs-operator">=</span> wordId.get(s);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> ch[i];<br>            ch[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newWord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch);<br>            addWord(newWord);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id2</span> <span class="hljs-operator">=</span> wordId.get(newWord);<br>            edge.get(id1).add(id2);<br>            edge.get(id2).add(id1);<br>            ch[i] = tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWord</span><span class="hljs-params">(String word)</span>&#123;<br>        <span class="hljs-keyword">if</span> (!wordId.containsKey(word))&#123;<br>            wordId.put(word, nodeNum++);<br>            edge.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>图论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>拓扑排序</title>
    <link href="/earsh9.github.io/2022/08/04/10.%E5%9B%BE%E8%AE%BA/2.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <url>/earsh9.github.io/2022/08/04/10.%E5%9B%BE%E8%AE%BA/2.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一个有向无环图必然存在至少一个拓扑序与之对应，反之亦然"><a href="#一个有向无环图必然存在至少一个拓扑序与之对应，反之亦然" class="headerlink" title="一个有向无环图必然存在至少一个拓扑序与之对应，反之亦然"></a>一个有向无环图必然存在至少一个拓扑序与之对应，反之亦然</h1><ul><li><p>拓扑排序：</p><ul><li><p>将图中的所有节点展开成一维序列，对于序列中任意的节点 ，如果在序列中 u 在 v 的前面，则说明在图中存在从 u 出发达到 v 的通路，即 u 排在 v 的前面。反之亦然。</p></li><li><p>举例：现有吃饭、做饭、择菜、烧水四件事，排出一个调度表。</p><ul><li><p>那么图中有 烧水-&gt; 做饭、择菜-&gt; 做饭、做饭-&gt;吃饭 这三条边(即先后顺序)</p></li><li><p>最先做的一定是入度为0的事情(即开端)，每做完一件事删除对应的边，再做下一件事直至做完。</p></li></ul></li></ul></li><li><p>以 BFS 的思想输出 拓扑序</p><ul><li><p>起始时，将所有入度为 0 的节点进行入队</p></li><li><p><strong>从队列中进行节点出队操作，出队序列就是对应我们输出的拓扑序</strong>。对于当前弹出的节点 x，遍历 x 的所有出度，即遍历所有由 x 直接指向的节点 y，对 y 做入度减一操作（因为 x 节点已经从队列中弹出，被添加到拓扑序中，等价于 x 节点从有向图中被移除，相应的由 x 发出的边也应当被删除，带来的影响是与 x 相连的节点 y 的入度减一）；</p></li><li><p>对 y 进行入度减一之后，检查 y 的入度是否为 0，如果为 0 则将 y 入队（当 y 的入度为 0，说明有向图中在 y 前面的所有的节点均被添加到拓扑序中，此时 y 可以作为拓扑序的某个片段的首部被添加，而不是违反拓扑序的定义）；</p></li><li><p>循环前两个流程，直到队列为空。</p></li></ul></li><li><p>只有存在至少一个「入度为 0 的点」 -&gt; 求得「某个有向无环图的拓扑序」(充分条件)</p><ul><li><p>反证法：假设有向无环图的拓扑序不存在入度为 0 的点。</p><ul><li><p>从图中的任意节点 x 进行出发，沿着边进行反向检索，由于不存在入度为 0 的节点，因此每个点都能够找到上一个节点。</p></li><li><p>当找到一条长度为 n + 1 的反向路径时，由于图中只有 n 个节点，因此必然有至少一个节点在该路径中重复出现，即该反向路径中存在环，与「有向无环图」的起始条件冲突。</p></li></ul></li></ul></li></ul><h2 id="802-找到最终的安全状态"><a href="#802-找到最终的安全状态" class="headerlink" title="802.找到最终的安全状态"></a>802.找到最终的安全状态</h2><p><a href="https://leetcode-cn.com/problems/find-eventual-safe-states/">https://leetcode-cn.com/problems/find-eventual-safe-states/</a></p><p>在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。</p><p>对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。</p><p>返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。</p><p>该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。</p><img src = "https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png"><p>输入：graph &#x3D; [[1,2],[2,3],[5],[0],[5],[],[]]</p><p>输出：[2,4,5,6]</p><p>解释：示意图如上。</p><p>节点5和节点6是终端节点，因为它们都没有出边。</p><p>从节点2、4、5和6开始的所有路径都指向节点5或6。</p><h3 id="dfs-三色标记法"><a href="#dfs-三色标记法" class="headerlink" title="dfs + 三色标记法"></a>dfs + 三色标记法</h3><ul><li>若起始节点位于一个环内，或者能到达一个环，则该节点不是安全的。否则，该节点是安全的。<ul><li>白色(用 0 表示)：尚未遍历到的点</li><li>灰色(用 1 表示)：在栈中、环内的点</li><li>黑色(用 2 表示)：遍历结束安全的点</li></ul></li><li>初始遍历该点时将其置为灰色，依次遍历其关联的点，若遇见灰色说明找到环了，退出搜索，栈中节点依旧保持灰色，将[找到了环]这一信息一直保留在栈中<ul><li>若没遇见说明安全，将其置为黑色</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">eventualSafeNodes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>    <span class="hljs-type">int</span>[] color = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;         <span class="hljs-comment">//枚举起始节点</span><br>        <span class="hljs-keyword">if</span> (check(graph, color, i)) ans.add(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span>[] color, <span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span> (color[x] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> color[x] == <span class="hljs-number">2</span>;<br><br>    color[x] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : graph[x]) &#123;<br>        <span class="hljs-keyword">if</span> (!check(graph, color, i)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    color[x] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反向图-拓扑排序"><a href="#反向图-拓扑排序" class="headerlink" title="反向图 + 拓扑排序"></a>反向图 + 拓扑排序</h2><ul><li><p>若一个节点没有出边，则该节点是安全的；若一个节点出边相连的点都是安全的，则该节点也是安全的</p></li><li><p><strong>如果想要判断某个节点数 x 是否安全，起始时将 x 进行入队，并跑一遍拓扑排序是不足够的</strong></p><ul><li>因为无法事先确保 x 的入度为 0，就有可能存在与 x 相连节点 y 的入度无法减到 0 的情况，以至于无法输出真实拓扑序</li></ul></li><li><p>从<strong>反向图</strong>出发，此时入度和出度颠倒。</p><ul><li>对于原图中「出度」为 0 的节点 x，没指向任何节点必然无法进入环，是安全的；同时由它们在反向图中指向的节点（在原图中「只指向」它们的节点），必然也是无法进入环的，对应到反向图中，就是那些减去 x 对应的入度之后，入度为 0 的节点。</li></ul></li><li><p>得到反图和入度数组，将入度为 0 的节点入队，依次取出队首元素，将其出边相连的点入度减一，若减一后入度为 0 则入队</p><ul><li>循环直至队列为空。此时入队为 0 的节点即为安全节点</li><li>在反图中从入度为0的节点(即终端节点)以 bfs 的形式进行扩张去 “感染” 其他的安全节点。没能将入度减为0的即不是安全节点</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">eventualSafeNodes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; rg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();     <span class="hljs-comment">//reverse graph</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) rg.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br><br>    <span class="hljs-type">int</span>[] in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];                          <span class="hljs-comment">//入度数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : graph[i]) &#123;<br>            rg.get(j).add(i);<br>        &#125;<br>        in[i] = graph[i].length;<br>    &#125;<br><br>    Deque&lt;Integer&gt; dq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (in[i] == <span class="hljs-number">0</span>) dq.offer(i);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!dq.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> dq.poll();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : rg.get(poll)) &#123;<br>            <span class="hljs-keyword">if</span> (--in[x] == <span class="hljs-number">0</span>) dq.offer(x);<br>        &#125;<br>    &#125;<br><br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (in[i] == <span class="hljs-number">0</span>) ans.add(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的有 954.二倍数对数组、207.课程表（官解的 bfs 和 dfs 对应上述两个方法）</p><h2 id="310-最小高度树"><a href="#310-最小高度树" class="headerlink" title="310. 最小高度树"></a>310. 最小高度树</h2><p><a href="https://leetcode-cn.com/problems/minimum-height-trees/">https://leetcode-cn.com/problems/minimum-height-trees/</a></p><ul><li><p>任何一个点都可以成为根节点，要想 [最小高度] -&gt; 树的重心（一棵树最多有两个重心）</p></li><li><p>实现：循环剔除度为 1 的节点，直至所剩节点数 &lt;&#x3D; 2</p><ul><li>拓扑排序：每次度为 1 的节点进队</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        ans.add(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-type">int</span>[] degree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    List&lt;Integer&gt;[] adj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        adj[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>        adj[edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>        adj[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>        degree[edge[<span class="hljs-number">0</span>]]++;<br>        degree[edge[<span class="hljs-number">1</span>]]++;<br>    &#125;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (degree[i] == <span class="hljs-number">1</span>) &#123;<br>            queue.offer(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">remainNodes</span> <span class="hljs-operator">=</span> n;<br>    <span class="hljs-keyword">while</span> (remainNodes &gt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> queue.size();<br>        remainNodes -= sz;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj[curr]) &#123;<br>                degree[v]--;<br>                <span class="hljs-keyword">if</span> (degree[v] == <span class="hljs-number">1</span>) &#123;<br>                    queue.offer(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        ans.add(queue.poll());<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>图论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>欧拉图</title>
    <link href="/earsh9.github.io/2022/08/04/10.%E5%9B%BE%E8%AE%BA/3.%E6%AC%A7%E6%8B%89%E5%9B%BE/"/>
    <url>/earsh9.github.io/2022/08/04/10.%E5%9B%BE%E8%AE%BA/3.%E6%AC%A7%E6%8B%89%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><h2 id="332题-重新安排行程"><a href="#332题-重新安排行程" class="headerlink" title="332题 重新安排行程"></a>332题 重新安排行程</h2><p><code>此题为找到欧拉环游或者半欧拉图，因为有存在割边的情况</code></p><p><code>原题第80个测试用例是错的,我们的算法是:能找见欧拉环游就返回,若不能就返回null</code></p><p><code>而官解是:能找见返回正确的,找不见会返回错误的</code></p><h3 id="邻接表实现"><a href="#邻接表实现" class="headerlink" title="邻接表实现"></a>邻接表实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ALmid332</span> &#123;<br>    List&lt;String&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;String&gt; res;<br>    <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findItinerary</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123; <span class="hljs-comment">//该map就是实现了邻接表,而邻接矩阵对稀松矩阵不太友好</span><br>        Map&lt;String,List&lt;Node&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();           <span class="hljs-comment">//对于这个List&lt;String&gt;希望存储它的两个属性,一个是value,一个是标记是否被遍历过的boolean,所以直接写成class省事</span><br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; t : tickets) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> t.get(<span class="hljs-number">0</span>), end = t.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (!map.containsKey(start))&#123;<br>                map.put(start,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            &#125;<br>            map.get(start).add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(end, <span class="hljs-literal">false</span>));      <span class="hljs-comment">//attention!!!!,此if无else直接解决List&lt;Node&gt;的创建问题,只需无脑add就行了</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (List&lt;Node&gt; value : map.values()) &#123;               <span class="hljs-comment">//对于List&lt;String&gt;直接调用Collections.sort()不报错是因为String已经实现Comparable这个接口了,而Node没有需在class中自行实现</span><br>            Collections.sort(value);<br>        &#125;<br><br>        size = tickets.size();<br><br>        ret.add(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        dfs(map,<span class="hljs-string">&quot;JFK&quot;</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Map&lt;String,List&lt;Node&gt;&gt; map, String from, <span class="hljs-type">int</span> cnt)</span>&#123;       <span class="hljs-comment">//一旦有标记数组dfs都得是有返回值的了</span><br>        <span class="hljs-keyword">if</span> (cnt == size) &#123;<br>            res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(ret);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (map.containsKey(from))&#123;<br>            List&lt;Node&gt; tmp = map.get(from);<br>            <span class="hljs-keyword">for</span> (Node s : tmp) &#123;<br>                <span class="hljs-keyword">if</span> (s.visit) <span class="hljs-keyword">continue</span>;<br><br>                ret.add(s.name);<br>                s.visit = <span class="hljs-literal">true</span>;<br><br>                <span class="hljs-keyword">if</span> (dfs(map,s.name,cnt + <span class="hljs-number">1</span>))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ret.remove(ret.size()-<span class="hljs-number">1</span>);<br>                    s.visit = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Node&gt;&#123;          <span class="hljs-comment">//自行实现接口</span><br>        String name;<br>        <span class="hljs-type">boolean</span> visit;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span> <span class="hljs-params">(String name, <span class="hljs-type">boolean</span> vis)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.visit = vis;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Node o)</span> &#123;                    <span class="hljs-comment">//告诉Node如何实现compareTo,当有Node o传进来就和它比较,返回值int值的正负代表大于小于等于</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(o.name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Hierholzer-算法"><a href="#Hierholzer-算法" class="headerlink" title="Hierholzer 算法"></a>Hierholzer 算法</h3><p><code>官解是想实现:对于欧拉图其奇度顶点只能为0或2,一个点入度和出度差一会导致死胡同,而程序无法预知死胡同在哪,逆序思想,先将无路可走的点加入answer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;String, PriorityQueue&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, PriorityQueue&lt;String&gt;&gt;();<br>    <span class="hljs-comment">//优先队列自带字典序排列的属性,其性质类似于堆？每次弹出都是可选择满足条件的</span><br>    List&lt;String&gt; itinerary = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findItinerary</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;<br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> ticket.get(<span class="hljs-number">0</span>), dst = ticket.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (!map.containsKey(src)) &#123;<br>                map.put(src, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;String&gt;());<br>            &#125;<br>            map.get(src).offer(dst);<br>        &#125;<br>        dfs(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        Collections.reverse(itinerary);<br>        <span class="hljs-keyword">return</span> itinerary;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String curr)</span> &#123;<br>        <span class="hljs-keyword">while</span> (map.containsKey(curr) &amp;&amp; map.get(curr).size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> map.get(curr).poll();                    <span class="hljs-comment">//记录队列顶端的值,并删除(删边的操作)</span><br>            dfs(tmp);<br>        &#125;<br>        itinerary.add(curr);                                     <span class="hljs-comment">//当遇见[无路可走]的情况了再加入该点,逆序操作.bug:仅针对欧拉图有效,非欧拉图会给出错误答案</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="753题-破解保险箱"><a href="#753题-破解保险箱" class="headerlink" title="753题 破解保险箱"></a>753题 破解保险箱</h2><p><code>题目解析：对于k进制的n位密码，将其所有密码串以最短的形式输出</code></p><p><code>例如，密码00，01，10，11可以通过字符串“00110”全部涵盖</code></p><p><code>考虑的出发点从最大限度的让前一个密码的后n-1位作为下一个密码的前n-1位，如此可以减少搜索成本</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> kk;<br>    <span class="hljs-type">int</span> nn;<br>    <span class="hljs-type">int</span> max;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    Map&lt;String, Boolean&gt; visit;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">crackSafe</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        nn= n;<br>        kk = k;<br>        max = (<span class="hljs-type">int</span>) Math.pow(k,n);<br>        visit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            init += <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        s.append(init);<br><br>        dfs(init,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> s.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String cur, <span class="hljs-type">int</span> cnt)</span>&#123;<br>        <span class="hljs-keyword">if</span> (cnt == max) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; kk; i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> cur + i;<br>            <span class="hljs-keyword">if</span> (visit.containsKey(tmp) &amp;&amp; visit.get(tmp)) <span class="hljs-keyword">continue</span>;<br>            visit.put(tmp, <span class="hljs-literal">true</span>);<br>            s.append(i);<br>            <span class="hljs-keyword">if</span> (!dfs(tmp.substring(<span class="hljs-number">1</span>),cnt + <span class="hljs-number">1</span>)) &#123;<br>                s.delete(s.length() - <span class="hljs-number">1</span>, s.length());<br>                visit.put(tmp, <span class="hljs-literal">false</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>官解：为何先遍历再加节点进answer呢？首先你并不知道哪条路走不通，所以只能边走边删边。</p><p>以往dfs套路就是合适的加入answer不合适的在dfs结束后删除，而这里无法找到一个合适的结束条件来return answer，若任由其删除，结果返回就会是空。</p><p>所以这里采用：先去试，等找到合适的了（死胡同）再去加入answer，最后无脑返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    <span class="hljs-type">int</span> highest;<br>    <span class="hljs-type">int</span> k;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">crackSafe</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        highest = (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, n - <span class="hljs-number">1</span>); <span class="hljs-comment">//想取低n-1位</span><br>        <span class="hljs-built_in">this</span>.k = k;<br>        dfs(<span class="hljs-number">0</span>);                              <span class="hljs-comment">//先dfs再添加节点,n-1个前导0也是如此</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            ans.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; k; ++x) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nei</span> <span class="hljs-operator">=</span> node * <span class="hljs-number">10</span> + x;<br>            <span class="hljs-keyword">if</span> (!seen.contains(nei)) &#123;<br>                seen.add(nei);<br>                dfs(nei % highest);<br>                ans.append(x);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>图论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础思想</title>
    <link href="/earsh9.github.io/2022/08/04/9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.%E5%9F%BA%E7%A1%80/"/>
    <url>/earsh9.github.io/2022/08/04/9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<ul><li>动态规划中每一个状态是由上一个状态推导出来的，这一点区别于贪心。贪心没有状态推导，而是从局部直接选最优的。</li><li>五部曲：<ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul></li><li>debug方法：打印出 dp 数组，看是否与自己推导的一致。</li></ul><p>动态规划的题目分为两大类，都存在一定的递推性质：</p><ol><li>求最优解类，典型问题是背包问题：「最优子结构」 ——即当前问题的最优解取决于子问题的最优解</li><li>计数类，比如统计方案数的问题：当前问题的方案数取决于子问题的方案数</li></ol><h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><img src = "https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png"><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>示例1：</p><img src = "https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg"><p>输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</p><p>输出：2</p><p>解释：</p><p>3x3 网格的正中间有一个障碍物。</p><p>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol><p><strong>思路：</strong></p><ol><li><p>知道当前状态是由前一行前一列相邻格子的状态决定</p><ul><li><p>dp 数组的初始化基于 遇到障碍物后的格子无需初始化，保持为0就行</p></li><li><p>也可以用现有的 obstacle 数组求解</p></li></ul></li><li><p>如何空间优化？</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;       <span class="hljs-comment">//遇到障碍物后的方格无需初始化了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空间复杂度优化：滚动数组"><a href="#空间复杂度优化：滚动数组" class="headerlink" title="空间复杂度优化：滚动数组"></a>空间复杂度优化：滚动数组</h3><ul><li><p>状态转移方程只跟前一行和前一列的相邻两个值有关，在循环嵌套里计算的时候，前一行的值就是上一个循环的计算结果，只需要考虑 列 这一个维度就行了</p></li><li><p>原来 dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1] 等于 dp[j] +&#x3D; dp[j-1]. 其中等号右边的 dp[j] 相当于 dp[i-1][j]，dp[j-1] 相当于 dp[i][j-1]，就从二维压缩为一维了。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[col];<br><br>    f[<span class="hljs-number">0</span>] = obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;         <span class="hljs-comment">//有障碍方案数为0，无障碍方案数初始化为1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                f[j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;             <span class="hljs-comment">//关键！</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; obstacleGrid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>                f[j] += f[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[col - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h2><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><p>输入: 2</p><p>输出: 1</p><p>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</p><p>示例 2:</p><p>输入: 10</p><p>输出: 36</p><p>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</p><p>说明: 你可以假设 n 不小于 2 且不大于 58。</p><h3 id="dp-i-代表什么？"><a href="#dp-i-代表什么？" class="headerlink" title="dp[i] 代表什么？"></a>dp[i] 代表什么？</h3><p>对于数字 i ，被拆分成若干份后能得到的最大乘积！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-comment">//dp[i] : 数字 i 拆分成至少两个正整数的和之后，可以得到的最大乘积</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;       <span class="hljs-comment">//0不是正整数,1无法拆分成两个及以上的数；可以初始化 dp[2] = 1</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++)&#123;<br>      <span class="hljs-comment">//拆分成 j 和 i - j ; 还是将 i - j 继续拆分</span><br>            cur = Math.max(cur, Math.max(j * (i - j), j * dp[i - j]));<br>        &#125;<br>        dp[i] = cur;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数学解法<ul><li><p>对于任意 ≥ 4 的因子 f，总是拆分后收益更大，例如 2 <em>(f - 2) &gt;&#x3D; f, 2</em> f - 4 &gt;&#x3D; f 恒成立</p></li><li><p>即将数字全拆成小于4的因子，而1是不必要的；只有2、3的组合</p></li><li><p>由于 2 <em>2</em> 2 &lt; 3 *3，将任意 3 个 2 合并成 2 个 3，收益更大；2* 2 &gt; 3 * 1，剩下的 2 保留</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">4</span>)&#123;            <span class="hljs-comment">//只拆分 3，剩余的 2 要保留</span><br>        ans *= <span class="hljs-number">3</span>;<br>        n -= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans * n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p>示例 1：</p><img src = "https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg"><p>输入：n &#x3D; 3</p><p>输出：5</p><p>示例 2：</p><p>输入：n &#x3D; 1</p><p>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 19</p><h3 id="如何画图抽象出dp表达式？"><a href="#如何画图抽象出dp表达式？" class="headerlink" title="如何画图抽象出dp表达式？"></a>如何画图抽象出dp表达式？</h3><p>例如：n 为 3 时，以 1、2、3 分别作为根节点去计算BST的种类数：</p><ol><li>当 1 为根节点时，其左子树为空，右子树有 2 个节点，布局与 n &#x3D; 2 时所画出来的一样；(题目只求种数，不看数值只看布局)</li><li>当 3 为根节点时，其左子树有 2 个节点，布局与 n &#x3D; 2 时所画出来的一样；</li><li>当 2 为根节点时，左右子树各 1 个节点，布局与 n &#x3D; 1 时只有一颗二叉树的情况一致</li></ol><p><strong>dp[i] ：1 到 i 节点组成的BST个数</strong></p><ul><li>dp[i] +&#x3D; dp[以j为根节点左子树个数] * dp[以 j 为根节点右子树个数]</li><li>初始化：dp[0] &#x3D; 1,dp[1] &#x3D; 1。空树 和 一个节点树 各为一种情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//f[i] : 1 到 i 节点组成的二叉搜索树个数</span><br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;      <span class="hljs-comment">//枚举根节点</span><br>            f[i] += f[j - <span class="hljs-number">1</span>] * f[i - j];  <span class="hljs-comment">//j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> f[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍&amp;买卖股票</title>
    <link href="/earsh9.github.io/2022/08/04/9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E4%B8%8E%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/"/>
    <url>/earsh9.github.io/2022/08/04/9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E4%B8%8E%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><ul><li>198.打家劫舍</li><li>213.打家劫舍II</li><li>337.打家劫舍 III</li></ul><p>任意相邻的两间房屋，只能偷一间，问能偷到的最大金额是多少？</p><p>三道题不同之处在于房屋陈设布局不一样。</p><ol><li>数组上连续元素二选一</li><li>成环之后连续元素二选一</li><li>房屋形似 “ 二叉树 ”，父与子节点不能同时偷</li></ol><h2 id="198题（确定状态转移方程"><a href="#198题（确定状态转移方程" class="headerlink" title="198题（确定状态转移方程"></a>198题（确定状态转移方程</h2><p>dp[j]：前 j 间房屋所能偷到的最大金额。</p><ol><li>不偷，就延续 dp[j - 1] 的偷盗金额！</li><li>偷，dp[j - 2] 的金额 加上 当前房屋的金额</li></ol><p>dp[j] &#x3D; Math.max(dp[j - 1], dp[j - 2] + nums[j]);</p><ul><li>当前状态与 前一个 或者 前两个 状态有关。<strong>从前往后</strong>遍历</li><li>dp[0]与dp[1]需初始化 - &gt; 只有一间房屋 和 两间房屋 可偷时应该怎么偷？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; j &lt; n; j++)&#123;<br>        dp[j] = Math.max(dp[j - <span class="hljs-number">1</span>], dp[j - <span class="hljs-number">2</span>] + nums[j]);    <span class="hljs-comment">//不偷 应该考虑dp[j - 1]</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="213题（拆段计算"><a href="#213题（拆段计算" class="headerlink" title="213题（拆段计算"></a>213题（拆段计算</h2><p>由于房屋围成一圈，意味着第 1 间 和 第 n 间 不能 同时偷，问题转化为：</p><ul><li>第 1 ~ n - 1 间房屋，间隔偷盗</li><li>第 2 ~ n 间房屋，间隔偷盗</li><li>注意初始化的状态不一样！</li></ul><h3 id="写法-1-注重拆段，写法-2-注重-初始化"><a href="#写法-1-注重拆段，写法-2-注重-初始化" class="headerlink" title="写法 1 注重拆段，写法 2 注重 初始化"></a>写法 1 注重拆段，写法 2 注重 初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    n = nums.length;<br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">return</span> Math.max(robby(<span class="hljs-number">0</span>, n - <span class="hljs-number">2</span>, nums), robby(<span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, nums));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robby</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> ed, <span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    dp[st] = nums[st];<br>    <span class="hljs-keyword">if</span>(ed - st + <span class="hljs-number">1</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[st];           <span class="hljs-comment">//！</span><br>    dp[st + <span class="hljs-number">1</span>] = Math.max(dp[st], nums[st + <span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st + <span class="hljs-number">2</span>; i &lt;= ed; i++)&#123;<br>        dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[ed];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> Math.max(f1, nums[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> Math.max(f2, nums[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;           <span class="hljs-comment">//第 1 ~ n - 1 间房屋</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> s1;<br>        s1 = Math.max(s1, f1 + nums[i]);<br>        f1 = tmp;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt; n; i++)&#123;               <span class="hljs-comment">//第 2 ~ n 间房屋</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> s2;<br>        s2 = Math.max(s2, f2 + nums[i]);<br>        f2 = tmp;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Math.max(s1, s2);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="337题（dfs-动规"><a href="#337题（dfs-动规" class="headerlink" title="337题（dfs + 动规"></a>337题（dfs + 动规</h2><ul><li>首先需确认 “遍历方式”：深度还是广度 ？</li><li>父与子 之间的直接连接 两边只能选一个</li><li>后序遍历 可以自由决定 抢父节点 还是考虑 抢孩子节点，并将返回的结果相加</li></ul><h3 id="暴力搜索-记忆化"><a href="#暴力搜索-记忆化" class="headerlink" title="暴力搜索 + 记忆化"></a>暴力搜索 + 记忆化</h3><p>避免重复计算 孙子节点的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;TreeNode, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.val;<br>    <span class="hljs-keyword">if</span> (map.containsKey(root)) <span class="hljs-keyword">return</span> map.get(root);<br><br>    <span class="hljs-comment">//抢 父节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> root.val;<br>    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) value1 += rob(root.left.left) + rob(root.left.right);<br>    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) value1 += rob(root.right.left) + rob(root.right.right);<br><br>    <span class="hljs-comment">//不抢 父节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> rob(root.left) + rob(root.right);<br><br>    map.put(root, Math.max(value1, value2));<br>    <span class="hljs-keyword">return</span> Math.max(value1, value2);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树形-dp-入门题"><a href="#树形-dp-入门题" class="headerlink" title="树形 dp 入门题"></a>树形 dp 入门题</h3><ul><li>对于暴力递归，是实时计算 偷 与 不偷 的结果</li><li>而 动规 用数组记录每个节点的结果就不用实时计算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用长度为 2 的数组记录：当前节点 偷还是不偷 所能得到的最大金钱。       &#123;不偷, 偷&#125;</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-type">int</span>[] ret = dfs(root);<br>    <span class="hljs-keyword">return</span> Math.max(ret[<span class="hljs-number">0</span>], ret[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dfs(TreeNode node)&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-comment">//首先得到 左右节点 偷与不偷 的结果</span><br>    <span class="hljs-type">int</span>[] left = dfs(node.left);<br>    <span class="hljs-type">int</span>[] right = dfs(node.right);<br><br>    <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//明确 父与子节点 不能同时偷</span><br>    <span class="hljs-comment">//取孩子节点 偷与不偷 结果的最大值 !!!!</span><br>    ret[<span class="hljs-number">0</span>] = Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>    ret[<span class="hljs-number">1</span>] = node.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h1><h2 id="121题：只能买卖一次"><a href="#121题：只能买卖一次" class="headerlink" title="121题：只能买卖一次"></a>121题：只能买卖一次</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：</p><p>输入：[7,1,5,3,6,4]</p><p>输出：5</p><p>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>示例 2：</p><p>输入：prices &#x3D; [7,6,4,3,1]</p><p>输出：0</p><p>解释：在这种情况下, 没有交易完成, 所以最大利润为 0</p><h3 id="使用贪心，选取差值最大值"><a href="#使用贪心，选取差值最大值" class="headerlink" title="使用贪心，选取差值最大值"></a>使用贪心，选取差值最大值</h3><ul><li>暴力找最大间隔区间，超时</li><li>贪心：股票只买卖一次，找左边最小值和右边最大值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++)&#123;<br>        min = Math.min(min, prices[i]);<br>        result = Math.max(result, prices[i] - min);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动规：“持有”-不代表是当日买入，有可能是之前就有了"><a href="#动规：“持有”-不代表是当日买入，有可能是之前就有了" class="headerlink" title="动规：“持有” 不代表是当日买入，有可能是之前就有了"></a>动规：“持有” 不代表是当日买入，有可能是之前就有了</h3><p>int[][] dp &#x3D; new int[n][2]</p><ul><li><p>dp[i][0] : 第 i 天 持有 股票所得的最多现金，买入即为 -prices[i]</p><ul><li>dp[i][0] &#x3D; Math.max(dp[i - 1][0], -prices[i]);</li></ul></li><li><p>dp[i][1] ： 第 i 天 不持有 股票所得的最多现金</p><ul><li>dp[i][1] &#x3D; Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);</li></ul></li><li><p>初始化：dp[0][1] &#x3D; 0, dp[0][0] &#x3D; -prices[0]</p></li><li><p>还可以采用滚动数组优化</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;           <span class="hljs-comment">//0：持有；1：不持有</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], -prices[i]);<br>        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="122题：多次交易，可以同一天买入和卖出"><a href="#122题：多次交易，可以同一天买入和卖出" class="headerlink" title="122题：多次交易，可以同一天买入和卖出"></a>122题：多次交易，可以同一天买入和卖出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);<br></code></pre></td></tr></table></figure><h2 id="含手续费、冷冻期"><a href="#含手续费、冷冻期" class="headerlink" title="含手续费、冷冻期"></a>含手续费、冷冻期</h2><p>可以无限次交易，但 「不能同时参与多笔交易」。且：</p><ul><li><p>714题 买卖股票的最佳时机含手续费</p><ul><li>每次卖出需支付手续费 fee</li></ul></li><li><p>309题 最佳买卖股票时机含冷冻期</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//手续费</span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];                <span class="hljs-comment">//持有</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;                         <span class="hljs-comment">//不持有</span><br><br>    dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>    dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i] - fee);<br><br><span class="hljs-comment">//冷冻期</span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">3</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];               <span class="hljs-comment">//持有</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;                        <span class="hljs-comment">//不持有且不在冷冻期</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;                        <span class="hljs-comment">//不持有但在冷冻期</span><br><br>    dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>    dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>    dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];             <span class="hljs-comment">//处在冷冻期说明：刚卖出</span><br><br>    <span class="hljs-keyword">return</span> Math.max(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><h2 id="规定最多可交易的笔数"><a href="#规定最多可交易的笔数" class="headerlink" title="规定最多可交易的笔数"></a>规定最多可交易的笔数</h2><p>依旧是 <strong>「不能同时参与多笔交易」</strong></p><ul><li><p>123题：最多两笔</p><ul><li><p>定义五种状态：</p><ul><li>0: 没有操作, 1: 第一次买入, 2: 第一次卖出, 3: 第二次买入, 4: 第二次卖出</li></ul></li><li><p><strong>边界初始化：</strong></p><ul><li>第二次买入：依赖于第一次卖出的状态，相当于第0天第一次买入，第一次卖出，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</li></ul></li><li><p>在最终时，卖出一定比持有现金多；而两次卖出的状态现金最大一定是最后一次卖出。</p></li></ul></li><li><p>188题：最多 k 笔</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">5</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);<br>        dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i][<span class="hljs-number">1</span>] + prices[i]);<br>        dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i][<span class="hljs-number">2</span>] - prices[i]);<br>        dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i][<span class="hljs-number">3</span>] + prices[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fstBuy</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, fstSell = <span class="hljs-number">0</span>;         <span class="hljs-comment">//第一次持有与卖出</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">secBuy</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, secSell = <span class="hljs-number">0</span>;         <span class="hljs-comment">//第二次持有与卖出</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p : prices)&#123;<br>            fstBuy = Math.max(fstBuy, -p);<br>            fstSell = Math.max(fstSell, fstBuy + p);<br><br><span class="hljs-comment">//既要第二次的买入受限于第一次的先卖出，又要持续比较第二次何时买入才划算：</span><br><span class="hljs-comment">//初始化为最小值！以一种不合法的状态开始</span><br><br>            secBuy = Math.max(secBuy, fstSell - p);<br>            secSell = Math.max(secSell, secBuy + p);<br>        &#125;<br>        <span class="hljs-keyword">return</span> secSell;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>更加规律化的 k 笔交易</p><ul><li><strong>初始化所有的交易次数是为确保 最后结果是最多 k 次买卖的最大利润</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];     <span class="hljs-comment">//第 i 天、第几次交易、是否持有</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= k; i++)&#123;<br>        dp[<span class="hljs-number">0</span>][i][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];           <span class="hljs-comment">//0 为不持有，1为持有</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;<br>            <span class="hljs-comment">//当前的卖出 是 同笔交易的买入 要卖了</span><br>            dp[i][j][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + prices[i]);<br><br>            dp[i][j][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>简化 dp 数组的维度：</p><ul><li><p>持有 和 不持有 的状态由 buy 和 sell 数组分别表示</p><ul><li><p>buy[i][j]：对于数组 prices[0..i] 中的价格，进行了 j 笔交易，且处于 <strong>持有</strong> 状态</p></li><li><p>sell[i][j]：处于 <strong>不持有</strong> 状态</p></li></ul></li><li><p>第 i 天的状态 只与 前一天 有关：使用滚动数组</p><ul><li>删除 n 那一维度即可（未贴出）</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    k = Math.min(k, n / <span class="hljs-number">2</span>);            <span class="hljs-comment">//n 天最多进行 n/2 笔交易</span><br>    <span class="hljs-type">int</span>[][] buy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][k + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span>[][] sell = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][k + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= k; i++)&#123;<br>        buy[<span class="hljs-number">0</span>][i] = -prices[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;<br>            buy[i][j] = Math.max(buy[i - <span class="hljs-number">1</span>][j], sell[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - prices[i]);<br>            sell[i][j] = Math.max(sell[i - <span class="hljs-number">1</span>][j], buy[i - <span class="hljs-number">1</span>][j] + prices[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sell[n - <span class="hljs-number">1</span>][k];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>其他类型dp</title>
    <link href="/earsh9.github.io/2022/08/04/9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8Bdp/"/>
    <url>/earsh9.github.io/2022/08/04/9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8Bdp/</url>
    
    <content type="html"><![CDATA[<h1 id="状态压缩-dp"><a href="#状态压缩-dp" class="headerlink" title="状态压缩 dp"></a>状态压缩 dp</h1><h2 id="1994-好子集的数目"><a href="#1994-好子集的数目" class="headerlink" title="1994. 好子集的数目"></a>1994. 好子集的数目</h2><p>给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。</p><p>比方说，如果 nums &#x3D; [1, 2, 3, 4] ：<br>[2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 &#x3D; 2<em>3 ，6 &#x3D; 2</em>3 和 3 &#x3D; 3 。<br>[1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 &#x3D; 2<em>2 和 4 &#x3D; 2</em>2 。<br>请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。</p><p>nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,4]</p><p>输出：6</p><p>解释：好子集为：</p><ul><li><p>[1,2]：乘积为 2 ，可以表示为质数 2 的乘积。</p></li><li><p>[1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。</p></li><li><p>[1,3]：乘积为 3 ，可以表示为质数 3 的乘积。</p></li><li><p>[2]：乘积为 2 ，可以表示为质数 2 的乘积。</p></li><li><p>[2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。</p></li><li><p>[3]：乘积为 3 ，可以表示为质数 3 的乘积。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数字范围小 -&gt; 筛选出符合条件的 10个质数，记为 p；1 添加与否对好子集产生的影响放在最后考虑</span><br><span class="hljs-comment">//每次仅能出现一次 -&gt; 用 10位的二进制数表示是否选取的状态</span><br><span class="hljs-comment">//压缩状态dp；一个数能否被放入好子集中的充要条件：该数不能被相同的质数相乘表示</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] primes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>,<span class="hljs-number">29</span>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfGoodSubsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">31</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) freq[num]++;     <span class="hljs-comment">//相同的数只能出现一次，但不同下标的为不同的数，故统计次数</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>;<br>    <span class="hljs-type">long</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[mask];<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    将 nums 中的数 t 用 [试除法] 进行质数分解，并用 cur 标记</span><br><span class="hljs-comment">    并判断 t 能添加到哪些好子集中 -&gt; 枚举与 cur 无交集的状态 prev -&gt; 计算 f[prev | cur]</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">30</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span> (freq[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">check</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span> (i % (primes[j] * primes[j]) == <span class="hljs-number">0</span>) &#123;<br>                check = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)&#123;<br>                cur |= (<span class="hljs-number">1</span> &lt;&lt; j);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!check) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//枚举前一个状态 prev</span><br>        <span class="hljs-comment">//确保考虑一个新数值 i 时，依赖的子集 prev 存储的为尚未考虑 i 的方案数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> mask - <span class="hljs-number">1</span>; prev &gt;= <span class="hljs-number">0</span>; prev--)&#123;<br>            <span class="hljs-keyword">if</span> ((prev &amp; cur) == <span class="hljs-number">0</span>)&#123;          <span class="hljs-comment">//只有当前考虑数与前一状态不冲突时才能考虑方案数累加</span><br>                f[prev | cur] = (f[prev | cur] + f[prev] * freq[i]) % mod;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; mask; i++) ans = (ans + f[i]) % mod;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; freq[<span class="hljs-number">1</span>]; i++) ans = ans * <span class="hljs-number">2</span> % mod;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="序列dp-字符串哈希"><a href="#序列dp-字符串哈希" class="headerlink" title="序列dp + 字符串哈希"></a>序列dp + 字符串哈希</h1><h2 id="472-连接词"><a href="#472-连接词" class="headerlink" title="472.连接词"></a>472.连接词</h2><p>给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。</p><p>连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。</p><p>示例：</p><p>输入：words &#x3D; [“cat”,”cats”,”catsdogcats”,”dog”,”dogcatsdog”,”hippopotamuses”,”rat”,”ratcatdogcat”]</p><p>输出：[“catsdogcats”,”dogcatsdog”,”ratcatdogcat”]</p><p>解释：</p><p>“catsdogcats” 由 “cats”, “dog” 和 “cats” 组成;</p><p>“dogcatsdog” 由 “dog”, “cats” 和 “dog” 组成;</p><p>“ratcatdogcat” 由 “rat”, “cat”, “dog” 和 “cat” 组成。</p><p>解法一为 前缀树 + dfs 记忆化搜索，见 其他 - 1.前缀树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Long&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">P</span> <span class="hljs-operator">=</span> <span class="hljs-number">131</span>, OFFSET = <span class="hljs-number">128</span>;<br><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findAllConcatenatedWordsInADict</span><span class="hljs-params">(String[] words)</span> &#123;<br>    <span class="hljs-keyword">for</span> (String word : words) &#123;<br>        <span class="hljs-keyword">if</span> (word.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word.toCharArray()) &#123;<br>            hash = hash * P + (ch - <span class="hljs-string">&#x27;a&#x27;</span>) + OFFSET;<br>        &#125;<br>        set.add(hash);<br>    &#125;<br><br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String word : words) &#123;<br>        <span class="hljs-keyword">if</span> (check(word)) ans.add(word);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String s)</span>&#123;             <span class="hljs-comment">//判断当前单词是否由一个或多个短单词组成</span><br>    <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    Arrays.fill(f, -<span class="hljs-number">1</span>);<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;                              <span class="hljs-comment">//初始化情况，字符串从 1 开始</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (f[i] == -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;          <span class="hljs-comment">//i == 0 时已经预处理了所有以第一个字符开头的短单词，f[i] 没有被更新可以直接跳过</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            cur = cur * P + (s.charAt(j - <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;a&#x27;</span>) + OFFSET;<br>            <span class="hljs-keyword">if</span> (set.contains(cur)) f[j] = Math.max(f[j], f[i] + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (f[n] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/earsh9.github.io/2022/08/04/9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.%20%E8%83%8C%E5%8C%85/"/>
    <url>/earsh9.github.io/2022/08/04/9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.%20%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>有 n 件物品和一个最多能背重量为 w 的背包。第 i 件物品的重量是 weight[i]，得到的价值是 value[i]。</p><p>每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><img src = "https://img-blog.csdnimg.cn/20210117175428387.jpg" width = "50%"/><h2 id="二维-dp-数组"><a href="#二维-dp-数组" class="headerlink" title="二维 dp 数组"></a>二维 dp 数组</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>每个物品只有两种状态，选 还是 不选，采用回溯进行 o(n ^ 2) 的搜索，n 为物品的数量。</p><h3 id="动态规划进行优化"><a href="#动态规划进行优化" class="headerlink" title="动态规划进行优化"></a>动态规划进行优化</h3><p>dp[i][j] : 对于容量为 j 的背包，0 ~ i 的物品任意选取所能产生的最大价值总和。</p><p>可以从两个方向递推出 dp[i][j]：</p><ol><li><p>不放物品 i ：直接由 dp[i - 1][j] 得到。即背包容量为 j 时，不放物品 i 的最大价值。（适用于物品 i 的质量大于背包 j 的质量时）</p></li><li><p>放物品 i ：由 dp[i - 1][j - weight[i]] + value[i] 得到。</p></li></ol><p>所以递推公式：dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p><ul><li>如何初始化？</li></ul><p>首先背包容量为 0 时的 dp[i][0] 无论选取什么物品价值总和一定为零。</p><p>其次，背包容量比 0 号物品质量还小时 即 j &lt; weight[0]，dp[0][j] &#x3D; 0; 而当 j &gt;&#x3D; weight[0] 时，dp[0][j] &#x3D; value[0]。此时背包容量足够装下物品 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//dp 数组初始化</span><br><span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[weight.length + <span class="hljs-number">1</span>][bagSize + <span class="hljs-number">1</span>];   <span class="hljs-comment">//数组初始化为0，第一个无需重复初始化</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; weight[<span class="hljs-number">0</span>]; j++)&#123;<br>    dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[<span class="hljs-number">0</span>]; j &lt;= bagWeight; j++)&#123;<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>确定遍历顺序</li></ul><p>明确两个遍历维度：物品 与 背包质量。先遍历哪一个都可以！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先遍历物品，好理解</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.length; i++)&#123;      <span class="hljs-comment">//遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagWeight; j++)&#123;     <span class="hljs-comment">//遍历背包容量</span><br>        <span class="hljs-keyword">if</span>(j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先遍历背包容量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagWeight; j++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个 for 循环虽然次序不同，但 dp[i][j] 所需数据都是左上角的，所以都可以。</p><h2 id="滚动数组优化成一维-dp-数组"><a href="#滚动数组优化成一维-dp-数组" class="headerlink" title="滚动数组优化成一维 dp 数组"></a>滚动数组优化成一维 dp 数组</h2><p>将 dp[i - 1] 那一层的结果拷贝给 dp[i]，递推变为 dp[i][j] &#x3D; Math.max(dp[i][j], dp[i][j - weight[i]] + value[i]);</p><p>与其拷贝，不如直接使用一维数组。</p><p>将每一层的结果自然的由 for 循环赋值传递，而不再额外使用空间。</p><h3 id="为何遍历顺序不同？"><a href="#为何遍历顺序不同？" class="headerlink" title="为何遍历顺序不同？"></a>为何遍历顺序不同？</h3><p>dp[j] : 容量为 j 的背包所背的最大价值。dp[j] &#x3D; Math.max(dp[j], dp[j - weight[i]] + value[i]);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagSize + <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.length; i++)&#123;   <span class="hljs-comment">//物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagSize; j &gt;= weight[i];  j++)&#123;   <span class="hljs-comment">//背包容量，需时刻大于 weight[i]</span><br>        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>背包容量大小 倒序遍历 是为了防止物品被重复加入！</strong></p><p>若正序：例如物品 0 的重量 weight[0] &#x3D; 0, value[0] &#x3D; 15</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15;</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30;</p><p>物品 0 被重复放入两次！</p><p>若倒序：先计算 dp[2]</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15;  &#x2F;&#x2F;当物品价值为正时，数组都可初始化即默认为0</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15;</p><p>倒序遍历可以保证每次取得的状态不与之前取得的状态重合，这样每个物品只用取一次。</p><p>而二维 dp 数组，每一层的状态都是由上一层得来，本层的数据不会被覆盖，无需倒序!</p><h1 id="01背包的应用"><a href="#01背包的应用" class="headerlink" title="01背包的应用"></a>01背包的应用</h1><p>集中在 Question01 - ALmid416.java</p><h2 id="416题-分割等和子集"><a href="#416题-分割等和子集" class="headerlink" title="416题 分割等和子集"></a>416题 分割等和子集</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,5,11,5]</p><p>输出：true</p><p>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p><p>示例 2：</p><p>输入：nums &#x3D; [1,2,3,5]</p><p>输出：false</p><p>解释：数组不能分割成两个元素和相等的子集。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</p><p>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h3 id="判断问题的类型"><a href="#判断问题的类型" class="headerlink" title="判断问题的类型"></a>判断问题的类型</h3><ol><li>背包的容量：数组和的一半</li><li>背包中要放入的物品重量：数组元素的数值</li><li>元素不能重复选取：01背包</li><li>只有物品刚好装满背包才行（与原始01背包的 “ 有 N 件物品和一个最多能被重量为 W 的背包” 不同）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>        maxNum = Math.max(maxNum, num);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((sum &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      <span class="hljs-comment">//奇数和无法均分成两堆</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;                  <span class="hljs-comment">//一个背包要装的重量</span><br>    <span class="hljs-keyword">if</span> (maxNum &gt; weight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <span class="hljs-comment">//如果最大元素 比 背包容量还大，说明另一个子集凑不到背包容量，直接返回false</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[weight + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> weight; w &gt;= num; w--)&#123;<br>            dp[w] = Math.max(dp[w], dp[w - num] + num);      <span class="hljs-comment">//物品的重量就是数组元素的数值</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[weight] == weight;          <span class="hljs-comment">//判断容量为 weight 的背包中是否装了重量为 weight 的物品</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似的还有：</p><ul><li>1049题 最后一块石头的重量 II</li></ul><h2 id="494题-目标和"><a href="#494题-目标和" class="headerlink" title="494题 目标和"></a>494题 目标和</h2><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。</p><p>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</p><p>输出：5</p><p>解释：一共有 5 种方法让最终目标和为 3 。</p><p>-1 + 1 + 1 + 1 + 1 &#x3D; 3</p><p>+1 - 1 + 1 + 1 + 1 &#x3D; 3</p><p>+1 + 1 - 1 + 1 + 1 &#x3D; 3</p><p>+1 + 1 + 1 - 1 + 1 &#x3D; 3</p><p>+1 + 1 + 1 + 1 - 1 &#x3D; 3</p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 20</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li><li>0 &lt;&#x3D; sum(nums[i]) &lt;&#x3D; 1000</li><li>-1000 &lt;&#x3D; target &lt;&#x3D; 1000</li></ul><h3 id="组合问题如何转化"><a href="#组合问题如何转化" class="headerlink" title="组合问题如何转化"></a>组合问题如何转化</h3><p>dp[j] : 填满容量为 j 的背包的方案种数。初始化 dp[0] &#x3D; 1</p><p>如何推出 dp[j] ？</p><ul><li><p>填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。</p></li><li><p>那么只要搞到nums[i]的话，凑成dp[j]就有dp[j - nums[i]] 种方法。</p></li></ul><p>求组合类问题的公式，都是类似这种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[j] += dp[j - nums[i]]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//target 有正有负，num 为非负整数</span><br><span class="hljs-comment">//分成l, r 一正一负两个背包：l + r = sum; l - r = target; 2 * l = sum + target;</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        sum += num;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sum + target &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                <span class="hljs-comment">//正数的背包不能加和为负</span><br>    <span class="hljs-keyword">if</span> (((sum + target) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">//2 * l, 必须要能均分</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (sum + target) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;                                    <span class="hljs-comment">//代表不考虑任何数，凑出计算结果为 0 的方案数为 1</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= num; j--)&#123;<br>            dp[j] += dp[j - num];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m];<br>&#125;<br></code></pre></td></tr></table></figure><p>数组较小时，也可以回溯爆炸搜索。但注意很容易超限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//回溯：每个数有成为正数 和 负数 两种选择，爆搜</span><br><span class="hljs-type">int</span>[] nums;<br><span class="hljs-type">int</span> target;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays0</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-built_in">this</span>.nums = nums;<br>    <span class="hljs-built_in">this</span>.target = target;<br>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> t)</span>&#123;       <span class="hljs-comment">//当前索引、加和值</span><br>    <span class="hljs-keyword">if</span> (i == nums.length)&#123;<br>        <span class="hljs-keyword">return</span> t == target ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(i + <span class="hljs-number">1</span>, t + nums[i]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(i + <span class="hljs-number">1</span>, t - nums[i]);<br>    <span class="hljs-keyword">return</span> left + right;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="474题-一和零"><a href="#474题-一和零" class="headerlink" title="474题 一和零"></a>474题 一和零</h2><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>示例 1：</p><p>输入：strs &#x3D; [“10”, “0001”, “111001”, “1”, “0”], m &#x3D; 5, n &#x3D; 3</p><p>输出：4</p><p>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。</p><p>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p><h3 id="两个维度的-01-背包问题"><a href="#两个维度的-01-背包问题" class="headerlink" title="两个维度的 01 背包问题"></a>两个维度的 01 背包问题</h3><p>首先第一个 for 循环是字符串数组 不言而喻，而字符串中 0 和 1 的个数对应于 物品重量，此乃两个维度。</p><p>故 dp[i][j] : 有 m 个 0，n 个 1 的子集个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">//之所以还是 01背包 而非多重背包，是由于数组元素即物品还是一个</span><br>    <span class="hljs-comment">//求解子集中最多有 m 个 0，n 个 1；取 还是 不取 选 max</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">oneNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str.toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) oneNum++;<br>                <span class="hljs-keyword">else</span> zeroNum++;<br>            &#125;<br><br><span class="hljs-comment">//此处两层 for 循环都是遍历 物品重量 这一维度。没有先后之分</span><br><span class="hljs-comment">//每一个 dp[i][j] 都对应一种 是否从 str 转变过来的个数，但只有成功转到 dp[m][n] 的个数才算有意义。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &gt;= zeroNum; i--)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= oneNum; j--)&#123;<br>                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">// + 1 对应 物品的价值</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>有 N 件物品和一个最多能背重量为 W 的背包。第i件物品的重量是 weight[i]，得到的价值是 value[i] 。</p><p>每件物品都有无限个（也就是可以放入背包多次），<strong>求解将哪些物品装入背包里物品价值总和最大</strong>。</p><p>完全背包和01背包问题唯一不同的地方就是，<strong>每种物品有无限件</strong>。</p><h2 id="五部曲也只有遍历顺序不同"><a href="#五部曲也只有遍历顺序不同" class="headerlink" title="五部曲也只有遍历顺序不同"></a>五部曲也只有遍历顺序不同</h2><p>01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p><p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.length; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[i]; j &lt; bagWeight; j++)&#123;<br>        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 01背包：</p><ul><li>物品 和 背包容量 的双层 for循环，二维 dp 数组无先后顺序之分</li><li>一维 dp 数组 必须先物品 后背包容量</li></ul><p>而 完全背包：</p><ul><li>一维 dp 数组 同样无先后顺序之分。</li><li>因为 dp[j] 是根据 j 之前的下标计算出来的，只要保证 j 之前的 dp[j] 是计算出来的就行。</li></ul><h2 id="组合数-与-排列数"><a href="#组合数-与-排列数" class="headerlink" title="组合数 与 排列数"></a>组合数 与 排列数</h2><p>{1，5} 与 {5，1} 是同一个组合，却是两种排列。</p><ul><li><p>求组合数：外层for循环遍历物品，内层for遍历背包。如 - 518. 零钱兑换 II</p><ul><li>因为将 物品 按次序遍历，只会出现一种组合方式。</li></ul></li><li><p>求排列数：外层for遍历背包，内层for循环遍历物品。如 - 377. 组合总和 IV</p><ul><li>而 物品 在内层循环，会出现多种排列方式。</li></ul></li><li><p>求满足方案的最少个数：两种遍历方式都可以。注意一下数组的初始化即可</p><ul><li>如 - 70. 爬楼梯、- 322. 零钱兑换、- 279. 完全平方数</li></ul></li></ul><h2 id="变个花样的背包：139-单词拆分"><a href="#变个花样的背包：139-单词拆分" class="headerlink" title="变个花样的背包：139.单词拆分"></a>变个花样的背包：139.单词拆分</h2><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。</p><p>你可以假设字典中没有重复的单词。</p><p>示例 1：</p><p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]</p><p>输出: true</p><p>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p><p>示例 2：</p><p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]</p><p>输出: true</p><p>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。</p><p>注意你可以重复使用字典中的单词。</p><p><strong>思路：</strong></p><ol><li><p>知道是完全背包；字符串 s 是背包，wordDict 是物品。</p><ul><li>但不知 内层遍历物品是遍历子串，当子串在 wordDict 中出现时转为 true</li></ul></li><li><p>dfs爆搜也可以，需要记忆化搜索否则超限</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>    Arrays.fill(dp, <span class="hljs-literal">false</span>);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(i,j);<br>            <span class="hljs-keyword">if</span> (wordDict.contains(sub) &amp;&amp; dp[i])&#123;<br>                dp[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; wordDict;<br>String s;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span>[] memo;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak1</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>    <span class="hljs-built_in">this</span>.wordDict = wordDict;<br>    <span class="hljs-built_in">this</span>.s = s;<br>    n = s.length();<br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Arrays.fill(memo, -<span class="hljs-number">1</span>);         <span class="hljs-comment">//初始</span><br><br>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span> &#123;<br>    <span class="hljs-keyword">if</span> (st &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">if</span> (memo[st] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[st] == <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st; i &lt; n; i++)&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(st, i + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">if</span> (wordDict.contains(sub) &amp;&amp; dfs(i + <span class="hljs-number">1</span>))&#123;<br>            memo[st] = <span class="hljs-number">1</span>;           <span class="hljs-comment">//可以被拆分</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    memo[st] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p>与 <strong>01背包</strong> 相似，不同在于每件物品不能无限使用而有限制。</p><p>有N种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的空间是 Ci ，价值是 Wi 。</p><p>求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p><h2 id="实现：拆分"><a href="#实现：拆分" class="headerlink" title="实现：拆分"></a>实现：拆分</h2><ol><li>将多件的物品一件件展开，其余不变。</li><li>在 01背包 循环内，一个一个遍历物品。(遍历一个每种商品的数量)</li><li>二进制优化：把每种物品的数量，打包成一个个独立的包。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMultiPack1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 版本一：改变物品数量为01背包格式</span><br>    List&lt;Integer&gt; weight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br>    List&lt;Integer&gt; value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>));<br>    List&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bagWeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>        <span class="hljs-keyword">while</span> (nums.get(i) &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 把物品展开为 i</span><br>            weight.add(weight.get(i));<br>            value.add(value.get(i));<br>            nums.set(i, nums.get(i) - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagWeight + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight.get(i); j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = Math.max(dp[j], dp[j - weight.get(i)] + value.get(i));<br>        &#125;<br>        System.out.println(Arrays.toString(dp));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMultiPack2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 版本二：改变遍历个数</span><br>    <span class="hljs-type">int</span>[] weight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-type">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bagWeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bagWeight + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; weight.length; i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>            <span class="hljs-comment">// 以上为01背包，然后加一个遍历个数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= <span class="hljs-number">0</span>; k++) &#123; <span class="hljs-comment">// 遍历个数</span><br>                dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);<br>            &#125;<br>            System.out.println(Arrays.toString(dp));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子序列问题</title>
    <link href="/earsh9.github.io/2022/08/04/9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <url>/earsh9.github.io/2022/08/04/9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]</p><p>输出：4</p><p>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4</p><h3 id="找到dp-i-是由什么状态递推而来"><a href="#找到dp-i-是由什么状态递推而来" class="headerlink" title="找到dp[i]是由什么状态递推而来"></a>找到dp[i]是由什么状态递推而来</h3><p>dp[i]：0 ~ i 个元素（包括i）中最长上升子序列的个数</p><p><strong>位置 i 的最长上升序子序列等于 j 从 0 到 i-1 各个位置的最长升序子序列个数 + 1 的最大值。！！！</strong></p><p>dp[i] &#x3D; Math.max(dp[i], dp[j] + 1)</p><p>（具体代码 与 贪心解法 已在贪心部分贴过）</p><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a>718. 最长重复子数组</h2><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><p>示例：</p><p>输入： A: [1,2,3,2,1] B: [3,2,1,4,7]</p><p>输出：3</p><p>解释： 长度最长的公共子数组是 [3, 2, 1] 。</p><p>提示：</p><p>1 &lt;&#x3D; len(A), len(B) &lt;&#x3D; 1000</p><p>0 &lt;&#x3D; A[i], B[i] &lt; 100</p><p>法0：暴力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//method0：暴力</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                    <span class="hljs-comment">//重复子数组长度</span><br>            <span class="hljs-keyword">while</span> (nums1[i + k] == nums2[j + k])&#123;<br>                k++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k &gt; result) result = k;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="法1：子数组-即为-连续子序列"><a href="#法1：子数组-即为-连续子序列" class="headerlink" title="法1：子数组 即为 连续子序列"></a>法1：子数组 即为 连续子序列</h3><p>dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。</p><p>if(nums1[i - 1] &#x3D;&#x3D; nums2[j - 1]) dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</p><p>全程标记最大值，也可以滚动数组降维</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//（36ms）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> nums1.length, n2 = nums2.length;<br>        <span class="hljs-keyword">if</span>(n1 == <span class="hljs-number">0</span> || n2 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//以下标 i - 1 结尾的数组1 与下标 j - 1结尾的数组2，最长重复子数组的长度</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n1 + <span class="hljs-number">1</span>][n2 + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n2; j++)&#123;<br><br>                <span class="hljs-keyword">if</span>(nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;      <span class="hljs-comment">//所以 i 从 [1,n]</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(dp[i][j] &gt; result) result = dp[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>法2：滑动窗口（43ms）</p><ul><li>让数组 1 和 2 之间对齐，即获取起始位置</li><li>经过一次遍历，求得子数组的长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums1,nums2;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>    <span class="hljs-built_in">this</span>.nums1 = nums1;<br>    <span class="hljs-built_in">this</span>.nums2 = nums2;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Math.min(n, m - i);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> getMaxLen(i, <span class="hljs-number">0</span>, len);<br>        ret = Math.max(ret, maxLen);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Math.min(m, n - i);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> getMaxLen(<span class="hljs-number">0</span>, i, len);<br>        ret = Math.max(ret, maxLen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxLen</span><span class="hljs-params">(<span class="hljs-type">int</span> st1, <span class="hljs-type">int</span> st2, <span class="hljs-type">int</span> len)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        <span class="hljs-keyword">if</span> (nums1[st1 + i] == nums2[st2 + i])&#123;<br>            k++;<br>        &#125;<span class="hljs-keyword">else</span> k = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (k &gt; ret) ret = k;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>法3：二分查找 + 哈希（9ms）</p><ul><li><p>二分查找 重复子数组的长度 k</p></li><li><p>每次查找，使用哈希来判断 两数组是否存在相同长度的子数组</p></li><li><p>使用 RK算法 对序列 S 进行哈希：数组元素 ≤100，使用素数 base 进行 base进制数的哈希编码，为避<br>免越界还要取另一个素数 mod 取模</p></li><li><p>在已知 [0,len] 序列哈希的情况下，采用滑动窗口的方法获取 [1,len + 1] 序列的哈希</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">131</span>;<br><span class="hljs-type">int</span>[] nums1, nums2;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-built_in">this</span>.nums1 = nums1;<br>    <span class="hljs-built_in">this</span>.nums2 = nums2;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, r = Math.min(nums1.length, nums2.length) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;                                  <span class="hljs-comment">//左闭右开</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check(mid)) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span>&#123;                    <span class="hljs-comment">//对于给定长度len的子数组，看俩数组是否有相同的</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">hashA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;                <span class="hljs-comment">//左侧为高位，右侧为低位</span><br>        hashA = (hashA * base + nums1[i]) % mod;<br>    &#125;<br>    Set&lt;Long&gt; bucketA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    bucketA.add(hashA);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">multi</span> <span class="hljs-operator">=</span> multiply(base, len - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len; i &lt; nums1.length; i++)&#123;<br>        hashA = ((hashA - nums1[i - len] * multi % mod + mod) % mod * base + nums1[i]) % mod;<br>        bucketA.add(hashA);<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">hashB</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        hashB = (hashB * base + nums2[i]) % mod;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (bucketA.contains(hashB)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len; i &lt; nums2.length; i++)&#123;<br>        hashB = ((hashB - nums2[i - len] * multi % mod + mod) % mod * base + nums2[i]) % mod;<br>        <span class="hljs-keyword">if</span> (bucketA.contains(hashB)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> n)</span>&#123;             <span class="hljs-comment">//快速幂求解 x ^ n</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)&#123;<br>            ret = ret * x % mod;<br>        &#125;<br>        x = x * x % mod;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><p>示例 1：</p><p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</p><p>输出：6</p><p>解释：连续子数组 [4,-1,2,1] 的和最大，为 6</p><h3 id="dp-i-：以下标-i-结尾的子数组和的最大值"><a href="#dp-i-：以下标-i-结尾的子数组和的最大值" class="headerlink" title="dp[i]：以下标 i 结尾的子数组和的最大值"></a>dp[i]：以下标 i 结尾的子数组和的最大值</h3><p>dp[i] &#x3D; Math.max(dp[i - 1] + nums[i], nums[i]); 并全程记录最大值</p><p>此题还可用<strong>贪心</strong>：只有加和 大于0 才对后面的序列有好处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>)<br>            sum += num;<br>        <span class="hljs-keyword">else</span><br>            sum = num;<br>        res = Math.max(res, sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分治</strong>：线段树（见分治.md）</p><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>进阶：</p><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><p>示例 1：</p><p>输入：s &#x3D; “abc”, t &#x3D; “ahbgdc”<br>输出：true</p><ul><li>思路1：双指针，s中的字母会按次序出现在t中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; t.length(); j++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; s.length() &amp;&amp; s.charAt(i) == t.charAt(j))&#123;<br>            i++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> i == s.length();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只能对t进行删除操作"><a href="#只能对t进行删除操作" class="headerlink" title="只能对t进行删除操作"></a>只能对t进行删除操作</h3><ul><li><p>思路2：对于惯常的两个字符串题，dp 采用二维</p><ul><li><p>dp[i][j]：以下标 i-1 结尾的s 与 以下标 j-1 结尾的t，相同子序列长度为dp[i][j]</p></li><li><p>之所以用 i - 1 是为了方便遍历以及考虑有空串的情况</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        Arrays.fill(dp[i], <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>)) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];   <span class="hljs-comment">//当前不匹配，只能去看前一位结尾的</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n] == m;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace”</p><p>输出：3</p><p>解释：最长公共子序列是 “ace” ，它的长度为 3</p><h3 id="典型的二维动态规划，两个字符串都能操作"><a href="#典型的二维动态规划，两个字符串都能操作" class="headerlink" title="典型的二维动态规划，两个字符串都能操作"></a>典型的二维动态规划，两个字符串都能操作</h3><p><strong>打表画图更直观:</strong></p><p>dp[i][j]：对于 text1 [0:i - 1] 和 text2 [0:j - 1] 的子串最长公共子序列的长度</p><p>如果 chars[i - 1] &#x3D;&#x3D; chars[j - 1], dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</p><p>else 需要从 dp[i - 1][j]、dp[i][j - 1] 中取大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length(), n = text2.length();<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">char</span>[] chars1 = text1.toCharArray();<br>        <span class="hljs-type">char</span>[] chars2 = text2.toCharArray();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//例：”abcde“和&quot;ace&quot;,当 a 与 a 匹配时，dp[1][1]=1;</span><br><span class="hljs-comment">//遍历到 c、e不等时，dp[1][2]、dp[1][3]均等于左边/上边的结果最大值</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span> (chars1[i - <span class="hljs-number">1</span>] == chars2[j - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>类似的有：- 1035.不相交的线</p><h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a>115. 不同的子序列</h2><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p>示例 1：</p><p>输入：s &#x3D; “rabbbit”, t &#x3D; “rabbit”</p><p>输出：3</p><p>解释：3个’b’，两两组合构成3组”bb”</p><h3 id="只对-s-进行-删不删除的考虑"><a href="#只对-s-进行-删不删除的考虑" class="headerlink" title="只对 s 进行 删不删除的考虑"></a>只对 s 进行 删不删除的考虑</h3><ol><li><p>dp[i][j]：以下标 i-1 结尾的s的子序列中 出现以下标 j-1 结尾的t 的个数</p></li><li><p>当s[i] &#x3D;&#x3D; t[j] 相同时，既可以选取该字母也可以不选取 来得到 t 序列</p><ul><li><p>例如 s：”rara”、t：”ra”</p></li><li><p>i &#x3D; 4,j &#x3D; 2时,”ra”序列既可以从”rara”也可以从”rar”得到</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;                 <span class="hljs-comment">//t为空串的情况</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a>583. 两个字符串的删除操作</h2><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。</p><p>每步 可以删除任意一个字符串中的一个字符。</p><p>示例 1：</p><p>输入: word1 &#x3D; “sea”, word2 &#x3D; “eat”</p><p>输出: 2</p><p>解释: 第一步将 “sea” 变为 “ea” ，第二步将 “eat “变为 “ea”</p><h3 id="word1-和-word2-均能进行-删除-操作"><a href="#word1-和-word2-均能进行-删除-操作" class="headerlink" title="word1 和 word2 均能进行 删除 操作"></a>word1 和 word2 均能进行 删除 操作</h3><p>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所要删除元素的最少次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//相比115.两个字符串都可以删除</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length(), n = word2.length();<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;                       <span class="hljs-comment">//均为空串与其中某一个为空串的初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;     <span class="hljs-comment">//删除word1[i - 1]、删除word2[i - 1]、同时删除</span><br>                dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>, dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>示例 1：</p><p>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”</p><p>输出：3</p><p>解释：</p><p>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)</p><p>rorse -&gt; rose (删除 ‘r’)</p><p>rose -&gt; ros (删除 ‘e’)</p><h3 id="对-word1-进行插入、删除、替换操作"><a href="#对-word1-进行插入、删除、替换操作" class="headerlink" title="对 word1 进行插入、删除、替换操作"></a>对 word1 进行插入、删除、替换操作</h3><p>dp[i][j]：从 word1[0..i-1] 变换到 word2[0..j-1] 所需要的操作数</p><ul><li><p>若知道从 word1[0..i-1] 变换到 word2[0..j-1] 的操作数为 k，那么从 word1[0..i] 变换到 word2[0..j] 的操作数为多少？</p><ul><li>如果 word1[i] &#x3D;&#x3D; word2[j]，无需操作；如果不等直接替换，即 k + 1 步。</li></ul></li><li><p>若知道从 word1[0..i-1] 变换到 word2[0..j] 的操作数为 k，那么从 word1[0..i] 变换到 word2[0..j] 的呢？</p><ul><li>先花 k 步从 word1[0..i-1] 变换到 word2[0..j]，再将 word1[i] 删除，即 k + 1 步。</li></ul></li><li><p>若知道 word1[0..i] 到 word2[0..j-1] 的操作数为 k，那 word1[0..i] 到 word2[0..j] 的呢？</p><ul><li>先花 k 步从 word1[0..i] 变换到 word2[0..j-1]，再插入 word2[j]，即 k + 1 步。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length(), n = word2.length();<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;  <span class="hljs-comment">//word2 为空串，word1只能删除</span><br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;  <span class="hljs-comment">//word1为空串，只能插入</span><br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">//对word1进行替换、删除、插入</span><br>                dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]), dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><p>输入：s &#x3D; “abc”</p><p>输出：3</p><p>解释：三个回文子串: “a”, “b”, “c”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];      <span class="hljs-comment">//起点为i 终点为j 的子串是否回文（左闭右开）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        Arrays.fill(dp[i], <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;<br>                <span class="hljs-keyword">if</span>(j - i &lt;= <span class="hljs-number">1</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])&#123;   <span class="hljs-comment">//a、aa、aba 的情况</span><br>                    result++;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h2><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p>示例 1：</p><p>输入：s &#x3D; “bbbab”</p><p>输出：4</p><p>解释：一个可能的最长回文子序列为 “bbbb” 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];           <span class="hljs-comment">//起点为i 终点为j 的子串中 最长回文子序列的长度</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++)&#123;<br><br>            <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;<br>                <span class="hljs-keyword">if</span>(j - i &lt;= <span class="hljs-number">1</span>)&#123;<br>                    dp[i][j] = <span class="hljs-number">1</span> + j - i;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j]);<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础思想</title>
    <link href="/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/1.%E5%9F%BA%E7%A1%80/"/>
    <url>/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/1.%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p><p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p><p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p><p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4]</p><p>输出: 6</p><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p><strong>思路：</strong></p><ol><li><p>要求连续子数组，不能排序。先从暴力想起：</p><ul><li>双层for循环，外层控制起始位置，内层以此遍历数组来记录最大值。</li></ul></li><li><p>此题何处体现贪心？</p><ul><li>负数只会拉低总和！</li><li>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</li><li>全局最优：选取的最大“连续和”。</li></ul></li><li><p>比较 sum + nums[i] 和 nums[i] 的大小，如果前者小，直接舍弃i之前的求和；选取区间 i 作为新起点重新计算。</p></li><li><p>相对于暴力而言，不断调整最大子序和区间的起始位置。那终止位置呢？</p><ul><li>不遍历完肯定不知道最大是多少噻；也有可能遇到过最大的后又减少了。</li><li>全程单另用一个变量记录最大值就好啦</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> max;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>        max = Math.max(max + nums[i], nums[i]);      <span class="hljs-comment">//要求子数组必须连续,所以当前元素i必须被考虑:要么和之前的连一起要么单开</span><br>        ret = Math.max(max,ret);                     <span class="hljs-comment">//有可能max记录到的不是最大值,例如7，6，-1;用ret及时将最大值记录下来</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1:</p><p>输入: [2,3,1,1,4]</p><p>输出: true</p><p>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>示例 2:</p><p>输入: [3,2,1,0,4]</p><p>输出: false</p><p>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p><p><strong>思路：</strong></p><ol><li>不管一次该跳几步，重要的是能够跳跃到的最远的范围！<ul><li>即这个最远的范围能不能覆盖到终点。</li></ul></li><li>遍历数组，动态维护这个最远的边界：<ul><li>当前位置 i + 其所能跳跃的步数 nums[i]</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;     <span class="hljs-comment">//记录每一个点最远可以到达的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">farmost</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt;= farmost)&#123;               <span class="hljs-comment">//说明位置i可达</span><br>            farmost = Math.max(farmost, i + nums[i]);<br>            <span class="hljs-keyword">if</span>(farmost &gt;= nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-跳跃游戏II"><a href="#45-跳跃游戏II" class="headerlink" title="45.跳跃游戏II"></a>45.跳跃游戏II</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><p>输入: [2,3,1,1,4]</p><p>输出: 2</p><p>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p><p>说明: 假设你总是可以到达数组的最后一个位置。</p><p><strong>思路：</strong></p><ol><li><p>知道还是要看能够覆盖的最大范围，但什么时候步数才加一呢？</p></li><li><p>如果每次真的都跳最大步数了，那下一次最远能跳到哪里就不知道了！</p></li><li><p>所以需要统计两个覆盖的范围：</p><p>1）当前这一步能够到达的最大范围</p><p>2）下一步能够到达的最大范围</p></li><li><p>当前这一步的最大范围是一定可达的，所以走到的时候step再加一就行。</p></li><li><p>另外的细节：如果当前的最大范围是数组的最后一个位置，那么不需要再有多余的步数+1了</p><ul><li>题目保证必可达，遍历走到数组倒数第二个位置就行。</li></ul></li></ol><p>理解本题的关键在于：</p><p><strong>以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点。</strong></p><p>这个范围内最小步数一定可以跳到，不用管具体是怎么跳的，不纠结于一步究竟跳一个单位还是两个单位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxPosition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">//记录每次能到达的最大位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;               <span class="hljs-comment">//最右边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">steps</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;             <span class="hljs-comment">//返回的跳跃次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++)&#123;<br>        maxPosition = Math.max(maxPosition, i + nums[i]);<br>        <span class="hljs-keyword">if</span>(i == end)&#123;          <span class="hljs-comment">//只有当i走到了能走到的最大位置时step才加一，而走的全程都记录了新的最大位置的</span><br>            end = maxPosition;<br>            steps++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> steps;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明:</p><p>如果题目有解，该答案即为唯一答案。</p><p>输入数组均为非空数组，且长度相同。</p><p>输入数组中的元素均为非负数。</p><p>示例 1: 输入:</p><p>gas &#x3D; [1,2,3,4,5]</p><p>cost &#x3D; [3,4,5,1,2]</p><p>输出: 3</p><p>解释:</p><p>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</p><p>开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</p><p>开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</p><p>开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</p><p>开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</p><p>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</p><p>因此，3 可为起始索引。</p><p>示例 2: 输入:</p><p>gas &#x3D; [2,3,4]</p><p>cost &#x3D; [3,4,3]</p><p>输出: -1</p><p>解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油。开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油。开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油。你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。</p><p><strong>思路:</strong></p><ol><li><p>暴力模拟会超限</p><ul><li>当前加油站不能到达终点就返回从下一个加油站重新判断。</li><li>怎样能够减少这样的判断？</li></ul></li><li><p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。题目又保证一定能跑完一圈。</p><ul><li>i 从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</li><li>为啥可以这样？ i 从0开始起码还是正的油量都不能跑到 i，那从大于 0 的开始油量更少更不能跑到 i 了。</li></ul></li><li><p><strong>for循环适合从头到尾遍历，while循环适合环形遍历。</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> gas.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                          <span class="hljs-comment">//加油站的起始位置</span><br><br>    <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sumOfgas</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sumOfcost = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(cnt &lt; n)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (i + cnt) % n;<br>            sumOfgas += gas[j];<br>            sumOfcost += cost[j];<br>            <span class="hljs-keyword">if</span>(sumOfcost &gt; sumOfgas) <span class="hljs-keyword">break</span>;<br>            cnt++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(cnt == n) <span class="hljs-keyword">return</span> i;<br>        <span class="hljs-keyword">else</span> i = i + cnt + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>贪心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>区间重叠问题</title>
    <link href="/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/3.%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98/"/>
    <url>/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/3.%E5%8C%BA%E9%97%B4%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [ i ] &#x3D; [ xstart , xend ] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例 1：</p><p>输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]</p><p>输出：2</p><p>解释：对于该样例，x &#x3D; 6 可以射爆 [2,8],[1,6] 两个气球，以及 x &#x3D; 11 射爆另外两个气球</p><p>示例 2：</p><p>输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]</p><p>输出：4</p><p>示例 3：</p><p>输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]</p><p>输出：2</p><p>示例 4：</p><p>输入：points &#x3D; [[1,2]]</p><p>输出：1</p><p>示例 5：</p><p>输入：points &#x3D; [[2,3],[2,3]]</p><p>输出：1</p><p>提示：</p><p>0 &lt;&#x3D; points.length &lt;&#x3D; 10^4</p><p>points[i].length &#x3D;&#x3D; 2</p><p>-2^31 &lt;&#x3D; xstart &lt; xend &lt;&#x3D; 2^31 - 1</p><p><strong>思路：</strong></p><ol><li><p>想尽量让气球重叠在一起，让一把箭尽可能的多射气球</p></li><li><p>首先得排序，按 start 还是 end 来排都可以</p><ul><li><p>如果按照左边界来升序排列：从前往后遍历数组（好理解）</p><ul><li><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭。</strong></li></ul></li><li><p>如果按照右边界来升序排列：</p><ul><li>当前气球的起始位置超出原先的右边界时就需要弓箭了；并更新新的右边界</li></ul></li></ul></li><li><p>此外还有重构比较器时，预防 整数溢出 的知识点。</p></li></ol><ul><li>左边界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots0</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-keyword">if</span> (points.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        Arrays.sort(points, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br><br><span class="hljs-comment">//直接 a - b 会有整数溢出的情况;修改1：return a &lt; b ? -1 : 1;修改2: Integer.compare();</span><br><br>                <span class="hljs-keyword">return</span> Integer.compare(o1[<span class="hljs-number">0</span>], o2[<span class="hljs-number">0</span>]);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> points.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">shots</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;          <span class="hljs-comment">//points的元素索引</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) shots++<br>            <span class="hljs-keyword">else</span>&#123;<br>                points[i][<span class="hljs-number">1</span>] = Math.min(points[i][<span class="hljs-number">1</span>], points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> shots;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>右边界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>    <span class="hljs-keyword">if</span> (points.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    Arrays.sort(points, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(o1[<span class="hljs-number">1</span>], o2[<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">shots</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] point : points) &#123;<br>        <span class="hljs-keyword">if</span> (point[<span class="hljs-number">0</span>] &gt; right)&#123;       <span class="hljs-comment">//当前气球的起始位置超出原先的右边界时</span><br>            shots++;<br>            right = point[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> shots;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1:</p><p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p><p>输出: 1</p><p>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p><p>示例 2:</p><p>输入: [ [1,2], [1,2], [1,2] ]</p><p>输出: 2</p><p>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p><p>示例 3:</p><p>输入: [ [1,2], [2,3] ]</p><p>输出: 0</p><p>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p><p><strong>思考：</strong></p><ol><li><p>按左边界还是右边界排序？<strong>结尾越小，则后面越有可能容纳更多的区间。</strong></p></li><li><p>如果按左边界</p><ul><li><p>需从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历。</p></li><li><p>也可能从左向右遍历，只需明确：遇见重叠区间时优先选择右边界小的那一个，这样留给剩下的区间空间就越大。</p></li></ul></li><li><p>如果按右边界，从左到右遍历（好理解）</p><ul><li><p>局部最优：<strong>优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些</strong>，从而尽量避免交叉。</p></li><li><p>计算无重叠区间的个数！只有找到无重叠区间后，才更新待比较的右边界值</p></li><li><p>全局最优：选取最多的非交叉区间。</p></li></ul></li></ol><ul><li>左边界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>    <span class="hljs-keyword">if</span>(intervals.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>];       <span class="hljs-comment">//按左边界升序排列</span><br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++)&#123;<br>        <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>            res++;<br>            intervals[i][<span class="hljs-number">1</span>] = Math.min(intervals[i][<span class="hljs-number">1</span>] ,intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]); <span class="hljs-comment">//关键：只有选择结尾短的，后面才有可能连接更多的区间；即默认把结尾长的那个给删了</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>右边界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>    <span class="hljs-keyword">if</span>(intervals.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];       <span class="hljs-comment">//按右边界升序排列</span><br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;              <span class="hljs-comment">//求不重叠的区间个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 记录区间分割点</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++)&#123;<br>        <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= end)&#123;<br>            ans++;<br>            end = intervals[i][<span class="hljs-number">1</span>];      <span class="hljs-comment">//因为是按右边界升序排列的，此时更新的右边界一定是不重叠区间中最小的了</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> intervals.length - ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似题目：</p><ul><li>56.合并区间</li></ul>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>贪心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多维度权衡</title>
    <link href="/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/2.%E5%A4%9A%E7%BB%B4%E5%BA%A6%E6%9D%83%E8%A1%A1/"/>
    <url>/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/2.%E5%A4%9A%E7%BB%B4%E5%BA%A6%E6%9D%83%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h2><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。</p><p>相邻的孩子中，评分高的孩子必须获得更多的糖果。</p><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>示例 1:</p><p>输入: [1,0,2]</p><p>输出: 5</p><p>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</p><p>示例 2:</p><p>输入: [1,2,2]</p><p>输出: 4</p><p>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p><p><strong>思考：</strong></p><ol><li><p>既要保证右边比你分高的孩子糖果比你多，又要保证左边分高的孩子糖果比你多</p><ul><li>两个维度需要权衡时，先定一个再比较另一个</li></ul></li><li><p>从前往后遍历：确定ratings[i] &gt; ratings[i - 1] 那么[i]的糖 一定要比[i - 1]的糖多一个</p></li><li><p>从后往前遍历：确定 ratings[i] &gt; ratings[i + 1]时，i 的糖果是 原先遍历完的糖果数 和 [i + 1] 的糖果数 + 1 中的大者。</p></li><li><p>贪心体现在：</p><ul><li>每一次比较时只比小的那个数量多一，两次方向不同的遍历也是为了利用已经确定好的数量。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ratings.length;<br><br>    <span class="hljs-type">int</span>[] candies = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    candies[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>])&#123;<br>            candies[i] = candies[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> candies[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>])&#123;<br>            candies[i] = Math.max(candies[i], candies[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        res += candies[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.根据身高重建队列</h2><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。</p><p>每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。</p><p>返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><p>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</p><p>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</p><p>解释：</p><p>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</p><p>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</p><p>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</p><p>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</p><p>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</p><p>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</p><p>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</p><p>示例 2：</p><p>输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</p><p>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p><p>提示：</p><p>1 &lt;&#x3D; people.length &lt;&#x3D; 2000</p><p>0 &lt;&#x3D; hi &lt;&#x3D; 10^6</p><p>0 &lt;&#x3D; ki &lt; people.length</p><p>题目数据确保队列可以被重建</p><p><strong>思考：</strong></p><ol><li><p>身高 h 跟人数 k 哪一个更重要？先考虑哪个？</p><ul><li><p>如果先按人数 k 递增来排的话就不能随意挪动以此来保证身高符合条件</p></li><li><p>如果先按身高 h 递减来排，即便它被后来的数组插进来，也不影响当前数组的正确性</p></li><li><p>即按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，</p></li></ul></li><li><p>总结：个子高的看不见个子矮的。个子矮的站个高的前面也不影响个高的条件。</p></li><li><p>即：身高降序排列、相同时按人数递增排列</p></li><li><p>插入的过程：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</p></li></ol><ul><li>插入[7,0]：[[7,0]]</li><li>插入[7,1]：[[7,0],[7,1]]</li><li>插入[6,1]：[[7,0],[6,1],[7,1]]</li><li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li><li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li><li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>    Arrays.sort(people, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] == o2[<span class="hljs-number">0</span>] ? o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>] : o2[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;);<br><br>    List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] person : people) &#123;<br>        list.add(person[<span class="hljs-number">1</span>],person);        <span class="hljs-comment">//关键</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>贪心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多重考虑</title>
    <link href="/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/4.%E5%A4%9A%E9%87%8D%E8%80%83%E8%99%91/"/>
    <url>/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/4.%E5%A4%9A%E9%87%8D%E8%80%83%E8%99%91/</url>
    
    <content type="html"><![CDATA[<p>以下的题多偏重综合考量，不太容易想到：</p><ul><li>738.单调递增的数字</li><li>714.买卖股票的最佳时机含手续费（动规更容易想到）</li><li>968.监控二叉树</li></ul><h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h2><p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。）</p><p>示例 1:</p><p>输入: N &#x3D; 10</p><p>输出: 9</p><p>示例 2:</p><p>输入: N &#x3D; 1234</p><p>输出: 1234</p><p>示例 3:</p><p>输入: N &#x3D; 332</p><p>输出: 299</p><p>说明: N 是在 [0, 10^9] 范围内的一个整数。</p><p><strong>思路：</strong></p><ol><li><p>从个例想起，如：98</p></li><li><p>一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p></li><li><p>遍历方式？从前往后还是从后往前</p><ul><li><p>如果从前往后，可能出现修改后的strNum[i - 1]又小于strNum[i - 2]的情况：如332 -&gt; 329</p></li><li><p>那从后往前，就可以重复利用上次比较得出的结果了，332 -&gt; 329 -&gt; 229</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[] chars= Integer.toString(n).toCharArray();<br><br>        <span class="hljs-type">int</span> start=Integer.MAX_VALUE;<span class="hljs-comment">//start初始值设为最大值，这是为了防止当数字本身是单调递增时，没有一位数字需要改成9的情况</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=chars.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span> (chars[i]&lt;chars[i-<span class="hljs-number">1</span>])&#123;<br>                chars[i-<span class="hljs-number">1</span>]--;<br>                start=i;<br>            &#125;<br>        &#125;<br><br>        StringBuilder res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;chars.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (chars[i]==<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;i==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//防止出现09这样的情况</span><br>            <span class="hljs-keyword">if</span> (i&gt;=start)&#123;<br>                res.append(<span class="hljs-string">&#x27;9&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> res.append(chars[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(res.toString());<br>    &#125;<br></code></pre></td></tr></table></figure><p>从前往后遍历也行，多考虑一点特殊情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">9</span>) <span class="hljs-keyword">return</span> n;<br><br>    <span class="hljs-type">char</span>[] chars = Integer.toString(n).toCharArray();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i + <span class="hljs-number">1</span> &lt; chars.length &amp;&amp; chars[i] &lt;= chars[i + <span class="hljs-number">1</span>])&#123;      <span class="hljs-comment">//找到第一个不满足递增条件的位置</span><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (i == chars.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;                         <span class="hljs-comment">//初始的 n 就满足单增，直接返回</span><br>    <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; chars[i] == chars[i - <span class="hljs-number">1</span>])&#123;                    <span class="hljs-comment">//233331,盲目直接 -1 可能破坏原先的递增条件,故退回到第一个 = 3 的位置</span><br>        i--;<br>    &#125;<br>    chars[i] -= <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; chars.length; j++)&#123;<br>        chars[j] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Integer.parseInt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">对于减1操作后可能导致原先递增部分被破坏：</span><br><span class="hljs-comment">除了去找寻是否有和当前位置相等的数之外，还可以：</span><br><span class="hljs-comment">如果前一位 比 当前位置的数 大，就自减。直到满足单增：</span><br><span class="hljs-comment">while(i &gt; 0 &amp;&amp; chars[i - 1] &gt; chars[i])&#123;</span><br><span class="hljs-comment">    chars[i - 1] -= 1;</span><br><span class="hljs-comment">    i--;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">for(i += 1; i &lt; chars.length; i++)&#123;</span><br><span class="hljs-comment">    chars[i] = &#x27;9&#x27;;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"> */</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>贪心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最长上升子序列（LIS）问题</title>
    <link href="/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/5.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <url>/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/5.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划-与-贪心-的双重解法"><a href="#动态规划-与-贪心-的双重解法" class="headerlink" title="动态规划 与 贪心 的双重解法"></a>动态规划 与 贪心 的双重解法</h1><p>一般动态规划 时间复杂度会较高，但贪心比较难想。</p><ul><li>300.最长上升子序列</li><li>354.俄罗斯套娃信封问题</li><li>面试题 08.13. 堆箱子</li><li>面试题 17.08. 马戏团人塔</li></ul><h2 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a>334. 递增的三元子序列</h2><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p><p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,4,5]</p><p>输出：true</p><p>解释：任何 i &lt; j &lt; k 的三元组都满足题意</p><p>示例 2：</p><p>输入：nums &#x3D; [5,4,3,2,1]</p><p>输出：false</p><p>解释：不存在满足题意的三元组</p><p>示例 3：</p><p>输入：nums &#x3D; [2,1,5,0,4,6]</p><p>输出：true</p><p>解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] &#x3D;&#x3D; 0 &lt; nums[4] &#x3D;&#x3D; 4 &lt; nums[5] &#x3D;&#x3D; 6</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5 * 10^5</p><p>-2^31 &lt;&#x3D; nums[i] &lt;&#x3D; 2^31 - 1</p><p><strong>思路：</strong></p><ol><li><p>题目给出的是 i &lt; j &lt; k 而非 i, i+1, i+2，说明子序列可以<strong>不连续</strong>。</p></li><li><p>数组大小为 10^5，说明暴力的三层for循环不行。</p></li><li><p>双向遍历：记录每一个以该元素结尾的序列的状态</p><ul><li><p>从左往右记录最小的，从右往左记录最大的</p></li><li><p>如果当前元素大于它左边最小的，小于它右边最大的。符合的三元组已找见。</p></li></ul></li><li><p>贪心：实现空间复杂度为o(1)，<strong>让最小值和次小值尽可能的小，找到递增的三元子序列的可能性更大。</strong></p><ul><li><p>预设两个变量a、b初始化均为Integr.MAX_VALUE。a 记录数组的最小值，b 记录次小值</p></li><li><p>一次遍历：若当前元素小于 a ，将其赋给 a ；</p></li><li><p>反之（已经满足大于a了）若小于 b ，将其赋给 b （让次小值也尽可能的小），如此可以尽可能多的出现满足情况的元素。</p></li><li><p>若当前元素大于 b，三元组已找见。</p></li></ul></li></ol><ul><li>双向遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">increasingTriplet</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] leftMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    leftMin[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    rightMax[n - <span class="hljs-number">1</span>] = nums[n - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &lt; leftMin[i - <span class="hljs-number">1</span>])&#123;<br>            leftMin[i] = nums[i];<br>        &#125;<span class="hljs-keyword">else</span> leftMin[i] = leftMin[i - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; rightMax[i + <span class="hljs-number">1</span>])&#123;<br>            rightMax[i] = nums[i];<br>        &#125;<span class="hljs-keyword">else</span> rightMax[i] = rightMax[i + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; leftMin[i] &amp;&amp; nums[i] &lt; rightMax[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>贪心</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//子序列的三个元素在原数组中是可以不连续的</span><br><span class="hljs-comment">//min 始终记录最小值，max 记录次大值并尽可能的小，若元素比 max 还大，说明找见三元组了。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">increasingTriplet</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">if</span>(num &lt;= min)&#123;<br>            min = num;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &lt;= max)&#123;<br>            max = num;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]</p><p>输出：4</p><p>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p><p>示例 2：</p><p>输入：nums &#x3D; [0,1,0,3,2,3]</p><p>输出：4</p><p>示例 3：</p><p>输入：nums &#x3D; [7,7,7,7,7,7,7]</p><p>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500</p><p>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4</p><p>进阶：</p><p>你可以设计时间复杂度为 O(n^2) 的解决方案吗？</p><p>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</p><p><strong>思考：</strong></p><p>上一题的进阶。</p><ol><li><p>动态规划：O(n^2)</p><ul><li><p>dp[i] 记录以 nums[i] 结尾序列的最长递增子序列长度。dp数组初始化全为1</p></li><li><p>对于 0 &lt; j &lt; i 中的任意j，只要nums[i] &gt; nums[j]，dp[i] &#x3D; max(dp[j]) + 1。</p></li><li><p>即我比我前面的数小时，考虑接在它后面即+1，那接在最大的dp[j]后面肯定dp[i]也是最大的了。</p></li></ul></li><li><p>贪心：O(n log(n))</p><ul><li><p>手动维护一个结果数组。若当前元素比结果数组的值都大的的话，就追加在结果数组后面（相当于递增序列长度加了1）</p></li><li><p>否则，二分查找，用当前元素覆盖掉第一个比它大的元素 <strong>（让递增子序列末尾元素的值尽可能小）</strong></p></li><li><p>这样做后续递增序列有可能更长，有可能没有，但只能返回长度符合答案。因为有时候覆盖会导致最终数组里的值不是最终的递增序列值</p></li></ul></li></ol><ul><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];    <span class="hljs-comment">//前 i 个元素中最长LIS的个数</span><br>    Arrays.fill(dp, <span class="hljs-number">1</span>);       <span class="hljs-comment">//任意一个以当前元素为 LIS 的个数都为1</span><br><br><span class="hljs-comment">//位置 i 的最长升序子序列等于 j 从 0 到 i-1 各个位置的最长升序子序列长度 + 1 的最大值。</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(dp[i] &gt; res) res = dp[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>贪心：要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</li></ul><p>新建数组 arr 表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，arr[1] &#x3D; nums[0]。</p><p>我们依次遍历数组 nums 中的每个元素，并更新数组 arr 和 len 的值。如果 nums[i] &gt;  arr[len] 则更新 len &#x3D; len + 1，否则在 arr[1…len]中找满足 arr[i−1] &lt; nums[j] &lt; arr[i] 的下标 i，并更新 arr[i] &#x3D; nums[j]。</p><p>例：[3,5,6,2,5,4,19,5,6,7,12]</p><p>[3,5,6]</p><p>[2,5,6]    &#x2F;&#x2F;替换掉3,让长度为1的递增子序列末尾元素的值更小</p><p>[2,4,6]</p><p>[2,4,6,19]</p><p>[2,4,5,19]</p><p>[2,4,5,6]</p><p>[2,4,5,6,7,12]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];         <span class="hljs-comment">//舍掉arr[0],方便直接返回length</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    arr[len] = nums[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; arr[len])&#123;<br>            len++;<br>            arr[len] = nums[i];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//如果arr中所有数都比 nums[i] 小，预留第一个位置pos + 1给它</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, r = len, pos = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (l &lt;= r)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;   <span class="hljs-comment">//要让 l 和 r 相等时的 mid 也参与比较</span><br>                <span class="hljs-keyword">if</span> (arr[mid] &lt; nums[i])&#123;<br>                    pos = mid;              <span class="hljs-comment">//每找见一个小于nums[i]的，就更新一次pos</span><br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            arr[pos + <span class="hljs-number">1</span>] = nums[i];         <span class="hljs-comment">//以便将 pos+1 位置处的值更新成更小的</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><p>贪心实际是最接近人的理解的方法，我们的难点是怎么将思维整理并转化为代码实现。</p><p>先不考虑题解， 假如给出序列 mylist&#x3D;[1， 3， 5， 6， 7， 2， 5， 7， 9， 10]，我们肉眼来找最长序列的时候，看到1, 3, 5, 6, 7递增，长度len1&#x3D;5，我们怀疑这个就是目标序列，暂且记为答案一。 但是当遇到2(mylist[5])时，我们就考虑另一种答案，有没有可能从1, 2, … (mylist[0], mylist[5]…)会找到一个新的子序列， 且比之前找的序列1, 3, 5, 6, 7更长呢？（记为答案二）我相信大部分人分析题目时，会有这个想法</p><p>接下来，当我们继续验证答案二时，需要依赖2以后的数字，看是否能找到新的递增序列。</p><p>然而，我们的目的是找最长的长度， 有两种结果，新的答案比第一次的答案短， 则我们保留原始答案一， 新的答案比第一次的答案长， 我们用新的方案。 但是过程我们要记录， 1）我新的答案，找到哪个数字了，以便继续往下找 2）如果新的答案不够长，保留答案一的结果。 回到题解，当我找到2时， 新的答案，第二个数字是2， 原来的[1, 3, 5, 6, 7], 3已经不在我新的答案序列了，我就把3替换为2， 依次进行， 如果我新的答案比第一次答案长， 整个序列被替换，如果没有第一个长，我替换的次数不够，原来方案一里最大的数字还在末尾， 原始的d的长度不会被替换。</p><p>那么我们始终能用d的长度表示我们的结果。</p><h2 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a>354. 俄罗斯套娃信封问题</h2><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] &#x3D; [wi, hi] ，表示第 i 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>注意：不允许旋转信封。</p><p>示例 1：</p><p>输入：envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]</p><p>输出：3</p><p>解释：最多信封的个数为 3, 组合为: [2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]。</p><h3 id="二维-LIS"><a href="#二维-LIS" class="headerlink" title="二维 LIS"></a>二维 LIS</h3><ul><li><p>宽度 w 和高度 h 都需要是严格递增的，如何同时控制两个维度？</p><ul><li>先固定一个再对另一个进行选择</li></ul></li><li><p>若所有信封宽度 w 均不相同，将 w值 按照升序排列后，就可忽略宽度这一维度，问题转化为一维的 LIS(longest increase subsequence)问题</p></li><li><p>若宽度有相同的情况呢？如 [1,1],[1,2],[1,3],[1,4]</p><ul><li><p>由于宽度相同不存在一个能装下另一个的情况，故只能在其中选择一个。</p></li><li><p>而直接忽略 w 这一维度，会造成 [1,2,3,4] 这一严格递增子序列，由此产生错误。如何解决？</p><ul><li>宽度相同时将高度这一维度降序排列，由此寻找不到严格递增子序列</li></ul></li></ul></li></ul><ol><li>朴素dp：超限</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] envelopes)</span> &#123;<br>    Arrays.sort(envelopes, (o1, o2) -&gt; o1[<span class="hljs-number">0</span>] == o2[<span class="hljs-number">0</span>] ? o2[<span class="hljs-number">1</span>] - o1[<span class="hljs-number">1</span>] : o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> envelopes.length;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];    <span class="hljs-comment">//dp[i]:以i结尾的序列中最长上升子序列的长度</span><br>    Arrays.fill(dp,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span> (envelopes[j][<span class="hljs-number">1</span>] &lt; envelopes[i][<span class="hljs-number">1</span>])&#123;<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        ans = Math.max(ans, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>二分 + dp</li></ol><p>设 arr[j] 表示 h 的前 i 个元素可以组成的长度为 j 的最长严格递增子序列的末尾元素的最小值。在定义范围内，arr是严格单调递增的，因为越长的递增子序列末尾元素越大。</p><p>在进行状态转移时，我们考虑当前的元素 hi：</p><ul><li><p>如果 hi 大于 arr 中的最大值，那么 hi 就可以接在 arr 中的最大值之后，形成一个长度更长的严格递增子序列；</p></li><li><p>否则我们找出 arr 中比 hi 严格小的最大的元素 f[j0]，即 f[j0] &lt; hi ≤ f[j0 + 1]，那么 hi 可以接在 f[j0] 之后，形成一个长度为 j0 + 1 的严格递增子序列，因此需要对 f[j0 + 1] 进行更新：</p><ul><li>f[j0 +1] &#x3D; hi</li></ul></li></ul><p>​</p><ul><li>在 arr 上进行二分查找，找出满足要求的 j0，在遍历所有的 hi之后，arr 中最后一个有定义的元素的下标增加 1（下标从 0 开始）即为最长严格递增子序列的长度。</li></ul><p>这一过程也可以理解为贪心。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] envelopes)</span> &#123;<br>    Arrays.sort(envelopes, (o1, o2) -&gt; o1[<span class="hljs-number">0</span>] == o2[<span class="hljs-number">0</span>] ? o2[<span class="hljs-number">1</span>] - o1[<span class="hljs-number">1</span>] : o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> envelopes.length;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;                      <span class="hljs-comment">//从 1 开始方便直接返回长度</span><br>    arr[len] = envelopes[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (envelopes[i][<span class="hljs-number">1</span>] &gt; arr[len])&#123;<br>            len++;<br>            arr[len] = envelopes[i][<span class="hljs-number">1</span>];<br>        &#125;<span class="hljs-keyword">else</span>&#123;                      <span class="hljs-comment">//贪心的二分查找arr数组中大于 e[i][1] 的最小值，并将其替换成 e[i][1]以使 LIS 的长度更长</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, r = len;<br>            <span class="hljs-keyword">while</span> (l &lt; r)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (arr[mid] &lt; envelopes[i][<span class="hljs-number">1</span>])&#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    r = mid;<br>                &#125;<br>            &#125;<br>            arr[l] = envelopes[i][<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>贪心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>其他</title>
    <link href="/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/6.%E5%85%B6%E4%BB%96/"/>
    <url>/earsh9.github.io/2022/08/04/8.%E8%B4%AA%E5%BF%83/6.%E5%85%B6%E4%BB%96/</url>
    
    <content type="html"><![CDATA[<h2 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a>621. 任务调度器</h2><p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 <strong>最短时间</strong> 。</p><p>示例 1：</p><p>输入：tasks &#x3D; [“A”,”A”,”A”,”B”,”B”,”B”], n &#x3D; 2</p><p>输出：8</p><p>解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B</p><p>在本示例中，两个相同类型任务之间必须间隔长度为 n &#x3D; 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。</p><h3 id="桶思想"><a href="#桶思想" class="headerlink" title="桶思想"></a>桶思想</h3><ol><li>两相同种类的任务之间必须间隔 n，即一个周期为 n + 1。肯定优先考虑种类数最大的任务！只有这样才能获得最短时间</li></ol><ul><li>建立大小为 n + 1 的桶子，个数为最大任务数量。例如：等待时间 n &#x3D; 2，A 任务个数为 6。建立 6 个大小为 3 的桶子。</li></ul><div align = center><img src = "https://pic.leetcode-cn.com/3829ac05bf1b5321849443021b5ea779495ddbfecd6d6bdca3126494ab477c9a-6XC91X9Y3AV)2)9%7BY%5D2@QWS.png"></div><ol><li><p>先从最简单的情况看起，现在就算没有其他任务，我们完成任务 A 所需的时间应该是 (6-1)*3+1&#x3D;16，因为最后一个桶子，不存在等待时间。</p></li><li><p>接下来添加其他任务</p></li></ol><div align = center><img src = "https://pic.leetcode-cn.com/8993d48fb4109d5d207f135bf73e10fd22c898c25113e5fa09bc91829790f9a0-image.png"></div><p>C 其实并没有对总体时间产生影响，因为它被安排在了其他任务的冷却期间；而 B 和 A 数量相同，这会导致最后一个桶子中，我们需要多执行一次 B 任务，现在我们需要的时间是 (6-1)*3+2&#x3D;17</p><p>前面两种情况，总结起来：<strong>总排队时间 &#x3D; (桶个数 - 1) * (n + 1) + 最后一桶的任务数</strong></p><ol start="3"><li>当冷却时间很短，任务种类很多时</li></ol><div align = center><img src = "https://pic.leetcode-cn.com/c6a573fa1a4da75c6c6c38113b4ad11ae7b8a1aa8ef714b8416a9bc338797ce0-image.png"></div><p>比如上图，我们刚好排满了任务，此时所需时间还是 17，如果现在我还要执行两次任务 F，该怎么安排呢？</p><div align = center><img src = "https://pic.leetcode-cn.com/893c01db5923889a865d7a4fe71de22b9519fc5a673473196ab58f26c1073ed2-image.png"></div><p>临时扩充某些桶子的大小，插进任务 F。此时无论再继续插入多少任务，都可以类似处理，且新插入任务都满足冷却要求。</p><p>-&gt; 每个任务之间都不存在空余时间，冷却时间已经被完全填满了。</p><p>-&gt; <strong>执行任务所需的时间，就是任务的数量</strong></p><ol start="4"><li><p>最终只需计算两个数:</p><ul><li>记录最大任务数量 N，统计任务数量并列最多的任务种类数 X。Num1 &#x3D; (N - 1) * (n + 1) + X;</li><li>Num2 &#x3D; tasks.size();</li><li>输出二者较大值即可。因为存在空闲时肯定 Num1 大，不存在空闲时 Num2 &gt;&#x3D; Num1。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leastInterval</span><span class="hljs-params">(<span class="hljs-type">char</span>[] tasks, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tasks.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> len;<br><br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> task : tasks) &#123;<br>            cnt[task - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>        &#125;<br>        Arrays.sort(cnt);                  <span class="hljs-comment">//升序排列</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max_cnt</span> <span class="hljs-operator">=</span> cnt[<span class="hljs-number">25</span>];             <span class="hljs-comment">//任务中的最大次数，假设A任务的次数最大</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur_cnt</span> <span class="hljs-operator">=</span> (max_cnt - <span class="hljs-number">1</span>) * (n + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//仅执行A任务所需的时间：以n为间隔，除最后一个A不需要冷却时间，其余的执行时间为每 n + 1 一段</span><br><br><span class="hljs-comment">//对于其他任务都可以填充在执行A任务时的冷却时间中，只有和 A任务次数相同的任务，须在最后一轮中 +1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; cnt[i] == max_cnt; i--)&#123;<br>            cur_cnt++;<br>        &#125;<br><br><span class="hljs-comment">//如果冷却时间已经填满，其余的任务顺次填充在每一轮之后也不会再需要新的冷却时间。此时所需时间即 tasks.length</span><br>        <span class="hljs-keyword">return</span> Math.max(cur_cnt, len);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>贪心</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>组合&amp;切割问题</title>
    <link href="/earsh9.github.io/2022/08/04/7.%E5%9B%9E%E6%BA%AF/1.%E7%BB%84%E5%90%88%E4%B8%8E%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/"/>
    <url>/earsh9.github.io/2022/08/04/7.%E5%9B%9E%E6%BA%AF/1.%E7%BB%84%E5%90%88%E4%B8%8E%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li>回溯的本质是暴力穷举，配合以适当剪枝</li><li>解法抽象为树形结构，集合的大小就构成了树的宽度，递归的深度构成的树的深度。</li><li>回溯方法backtracking的参数不容易一次性确定下来，适合先写逻辑，需要什么参数就填什么。</li></ul><img src = "https://img-blog.csdnimg.cn/20210130173631174.png"><ul><li><p><strong>集合的横向搜索用for循环遍历，纵向遍历为backtracking（递归），这样就把这棵树全遍历完了。</strong></p></li><li><p>模板：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一、组合问题"><a href="#一、组合问题" class="headerlink" title="一、组合问题"></a>一、组合问题</h1><h2 id="第77题-组合"><a href="#第77题-组合" class="headerlink" title="第77题. 组合"></a>第77题. 组合</h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:</p><p>输入: n &#x3D; 4, k &#x3D; 2</p><p>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><ul><li>横向for循环遍历n，纵向回溯高度为k</li></ul><img src = "https://img-blog.csdnimg.cn/20201123195223940.png"><ul><li>n，k 需在回溯函数的参数中，除此之外还需起始位置idx</li><li>返回的List全局变量或者函数参数都可</li><li>对于返回条件：<ul><li>list记录到的值满足k了</li><li>而起始位置idx在for循环中已经限制了不会超过n</li></ul></li><li>如何剪枝？<ul><li>当前的位置idx一定是 <strong>小于等于</strong> n - 当前还需的个数 + 1</li><li>当前还需的个数为：k - 已经添加好的list的大小</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>    traceBack(<span class="hljs-number">1</span>,n,k,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceBack</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, List&lt;Integer&gt; list)</span>&#123;<br>    <span class="hljs-keyword">if</span>(list.size() == k)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> idx; st &lt;= n - (k - list.size()) + <span class="hljs-number">1</span>; st++)&#123;<br>        list.add(st);<br>        traceBack(st + <span class="hljs-number">1</span>, n, k, list);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h2><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>注意：解集不能包含重复的组合。 </p><p>示例 1:</p><p>输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</p><p>输出:<br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]</p><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><ol><li>同一树枝(回溯)不能同一个数用两次：<ul><li>回溯时添加一个参数startIndex，每次执行时 + 1</li></ul></li><li>同一层(for循环)不能有相同值的去重：**(重点)**<ul><li><strong>需对原先数组进行排序！</strong></li><li>visit进行标记或者for循环里来判断</li></ul></li></ol><img src = "https://img-blog.csdnimg.cn/20201123202736384.png"><p>以candidates &#x3D; [1, 1, 2], target &#x3D; 3，（方便起见candidates已经排序了）</p><ul><li>预定义和candidates大小一样的boolean型数组visit，初始化全为false</li><li>我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：<ul><li>used[i - 1] &#x3D;&#x3D; true，说明同一树支candidates[i - 1]使用过</li><li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">boolean</span>[] visit;<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span>(candidates.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br><br>    Arrays.sort(candidates);<br>    <span class="hljs-keyword">if</span> (candidates[<span class="hljs-number">0</span>] &gt; target) <span class="hljs-keyword">return</span> res;<br>    visit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<br>    Arrays.fill(visit,<span class="hljs-literal">false</span>);<br><br>    traceBack(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,candidates,target);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">traceBack</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span>(sum == target)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//只对同一层去重，同一树枝可以使用相同的数值</span><br>    <span class="hljs-comment">//同一层遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++)&#123;<br><br>        <span class="hljs-comment">//同一树枝标记是true，同一层还是false</span><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; !visit[i - <span class="hljs-number">1</span>] &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//同一树枝操作</span><br>        list.add(candidates[i]);<br>        visit[i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> traceBack(i + <span class="hljs-number">1</span>, sum + candidates[i], candidates, target);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>        visit[i] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>还可以在for循环内startIndex即此处的index上操作，无需使用数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &gt; index &amp;&amp; arr[i] == arr[i - <span class="hljs-number">1</span>])&#123;  <span class="hljs-comment">//i 大于 index时，说明回溯回来又在同一层了</span><br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、切割问题与组合问题类似"><a href="#二、切割问题与组合问题类似" class="headerlink" title="二、切割问题与组合问题类似"></a>二、切割问题与组合问题类似</h1><p>类似题：</p><ul><li><ol start="93"><li>复原 IP 地址</li></ol></li></ul><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><p>示例 1：</p><p>输入：s &#x3D; “aab”<br>输出：[ [“a”,”a”,”b”], [“aa”,”b”] ]</p><p><strong>问题关键：</strong></p><ol><li>如何切割？（难）</li><li>怎么判断回文？（简单）</li></ol><p>对于字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li></ul><img src = "https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg"><ul><li>如何模拟切割？<ul><li>和组合问题里递归函数参数 startIndex 一样，表示每一轮递归遍历的起始位置。</li></ul></li><li>如何截取子串？<ul><li>在for (int i &#x3D; startIndex; i &lt; s.size(); i++) 循环中，对于起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。</li></ul></li><li>如何判断回文？<ul><li>双指针一前一后比对、动态规划预处理、记忆化搜索都行。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">boolean</span>[][] dp;<br><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>    n = s.length();<br>    dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        Arrays.fill(dp[i],<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            dp[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    traceBack(s,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceBack</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i)</span>&#123;       <span class="hljs-comment">//i 为起始位置</span><br>    <span class="hljs-keyword">if</span>(i == n)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++)&#123;<br>        <span class="hljs-keyword">if</span>(!dp[i][j]) <span class="hljs-keyword">continue</span>;<br><br>        list.add(s.substring(i,j+<span class="hljs-number">1</span>));         <span class="hljs-comment">//subString 左闭右开</span><br>        traceBack(s, j + <span class="hljs-number">1</span>);                  <span class="hljs-comment">//下一次切割从末尾位置 + 1 开始</span><br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、排列问题"><a href="#三、排列问题" class="headerlink" title="三、排列问题"></a>三、排列问题</h1><ul><li><strong>排列是有序的， [1,2] 和 [2,1] 是两个集合</strong>，这与之前分析的问题不同。</li><li>无需使用startIndex，每次递归都要从索引0开始</li><li>这时去重的数组就得是全局变量，记录路径中哪些元素已使用且随list一同回溯。</li></ul><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]</p><p>输出：[ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1] ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">int</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">21</span>];           <span class="hljs-comment">//标记的是元素，也可以标记索引值</span><br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Arrays.fill(vis,-<span class="hljs-number">1</span>);<br>    traceBack(nums);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceBack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-keyword">if</span>(list.size() == nums.length)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(vis[nums[i] + <span class="hljs-number">10</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br><br>        list.add(nums[i]);<br>        vis[nums[i] + <span class="hljs-number">10</span>] = <span class="hljs-number">1</span>;<br>        traceBack(nums);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>        vis[nums[i] + <span class="hljs-number">10</span>] = -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h2><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,2]<br>输出：<br>[ [1,1,2],<br> [1,2,1],<br> [2,1,1] ]</p><p><strong>思路：</strong></p><ol><li>在树枝上：不能有同一个数被使用两次：全局标记数组</li><li>在数层上：不能有相同的数被使用：将原数组排序以判断</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">int</span>[] vis;<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    Arrays.fill(vis,-<span class="hljs-number">1</span>);<br><br>    Arrays.sort(nums);<br>    traceBack(nums);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceBack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-keyword">if</span>(list.size() == nums.length)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>    <span class="hljs-comment">//一个判断是不是同一个数、一个判断是不是相同的值</span><br>        <span class="hljs-keyword">if</span>(vis[i] == <span class="hljs-number">1</span> || (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>] &amp;&amp; vis[i-<span class="hljs-number">1</span>] == -<span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br><br>        list.add(nums[i]);<br>        vis[i] = <span class="hljs-number">1</span>;<br><br>        traceBack(nums);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>        vis[i] = -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子集问题</title>
    <link href="/earsh9.github.io/2022/08/04/7.%E5%9B%9E%E6%BA%AF/2.%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/"/>
    <url>/earsh9.github.io/2022/08/04/7.%E5%9B%9E%E6%BA%AF/2.%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li><p>组合、切割和排列问题只收集走到树中叶子节点的路径，即走到头了才加入answer。</p></li><li><p>子集问题则是收集树中的所有节点，需实时加入answer。</p></li><li><p>子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p></li><li><p>集合无序，仍需去重，即回溯函数中有startIndex</p></li></ul><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[ [],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3] ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    traceBack(nums,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceBack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i &gt; nums.length) <span class="hljs-keyword">return</span>;             <span class="hljs-comment">//可有可无，下面的for循环已经限定i的范围了</span><br><br>    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++)&#123;<br>        list.add(nums[j]);<br>        traceBack(nums,j+<span class="hljs-number">1</span>);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a>491. 递增子序列</h2><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,6,7,7]<br>输出：[ [4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7] ]</p><p>示例 2：</p><p>输入：nums &#x3D; [4,4,3,2,1]<br>输出：[ [4,4] ]</p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 15</li><li>-100 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li></ul><p><strong>思考：</strong></p><ol><li>一般去重是靠排序和标记数组来实现的，但此题<strong>不能改变原数组元素的相对顺序！</strong></li><li>那如何去重？<ul><li>想去重的部分还是在同一层上，而非同一树枝上。</li><li>那就在for循环之上建立标记数组即<strong>一层一个标记数组</strong>，以此来达到目标。</li></ul></li><li>如何保证递增？<ul><li>只选取出比已加入list中最后一个数还要 大 （或等于）的数。</li></ul></li><li>在题目给定数值范围且范围较小的情况下，使用数组来做哈希映射 比 list 要效率高。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    traceBack(nums,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceBack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i)</span>&#123;     <span class="hljs-comment">//i 为起始位置</span><br>    <span class="hljs-keyword">if</span>(list.size() &gt; <span class="hljs-number">1</span>)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] visit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">201</span>];<br>    Arrays.fill(visit,-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++)&#123;<br>        <span class="hljs-comment">//保证递增和实现去重</span><br>        <span class="hljs-keyword">if</span>(list.size() &gt; <span class="hljs-number">0</span> &amp;&amp; nums[j] &lt; list.get(list.size() - <span class="hljs-number">1</span>) || visit[nums[j] + <span class="hljs-number">100</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br><br>        list.add(nums[j]);<br>        visit[nums[j] + <span class="hljs-number">100</span>] = <span class="hljs-number">1</span>;<br><br>        traceBack(nums, j + <span class="hljs-number">1</span>);<br><br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自底向上查找</title>
    <link href="/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/8.%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E6%9F%A5%E6%89%BE/"/>
    <url>/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/8.%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>回溯！</p><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p><img src = "https://img-blog.csdnimg.cn/20201016173414722.png"><p>示例 1:</p><p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</p><p>输出: 3</p><p>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p><p>示例 2:</p><p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</p><p>输出: 5</p><p>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p><strong>思考：</strong></p><ul><li>自底向上查找就能找见公共祖先了：回溯</li><li>后序遍历就是天然的回溯过程，最先处理的一定是叶子节点。</li></ul><ol><li>如果 p 和 q 都不在以 root 为根的树中，return null。</li><li>如果 p 和 q 分别位于 root 的左右子树，那当前节点就是最近公共祖先。</li><li>如果 p 和 q 都在以 root 为根的树中，函数返回值就是最近公共祖先。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;            <span class="hljs-comment">//base case</span><br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p , q);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p ,q);<br><br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;    <span class="hljs-comment">//p,q分别在左右子树中</span><br><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">//p,q不在以root为根节点的树中</span><br><br>    <span class="hljs-keyword">return</span> left == <span class="hljs-literal">null</span> ? right : left;               <span class="hljs-comment">//p,q在同一侧</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>表面上看只需搜到一条路径直接返回就行了，但是这里要对返回值 left 和 right 作逻辑处理，只能遍历完整棵树。这也是后序遍历中处理中间节点的逻辑部分。</li></ul><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h2><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><img src = "https://img-blog.csdnimg.cn/20201019173259554.png"><ul><li>“增删改查”中的“增”</li></ul><p><strong>迭代</strong></p><ul><li>先通过while找到符合条件的叶子节点pre，再在其后插入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);            <span class="hljs-comment">//该插入了</span><br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, pre = root;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>        pre = cur;<br>        <span class="hljs-keyword">if</span>(cur.val &lt; val) cur = cur.right;<br>        <span class="hljs-keyword">else</span> cur = cur.left;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pre.val &gt; val) pre.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>    <span class="hljs-keyword">else</span> pre.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递归</strong></p><ul><li>主要体会有返回值的递归函数的作用：<ul><li>先利用BST性质，不用搜索整棵树</li><li>在搜索的那一边，因为要插入节点即重构树的某部分结构，所以需要返回重构后的新的根节点。</li><li>669题 修剪二叉搜索树 与此类同</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);            <span class="hljs-comment">//该插入了</span><br><br>    <span class="hljs-keyword">if</span>(root.val &gt; val) root.left = insertIntoBST(root.left, val);<br>    <span class="hljs-keyword">else</span> root.right = insertIntoBST(root.right, val);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 $O(h)$，h 为树的高度。</p><img src = "https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg"><p>输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3</p><p>输出：[5,4,6,2,null,null,7]</p><p>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</p><p>一个正确的答案是 [5,4,6,2,null,null,7],</p><p>另一个正确答案是 [5,2,6,null,4,null,7]。</p><p><strong>思考：</strong></p><ul><li><p>再体味因为删除了节点而要重新构造树的结构导致的递归函数有返回值以及如何利用此返回值。</p></li><li><p>待删的节点有几种情况：</p><ul><li>本身为叶子节点，直接删除</li><li>只有一个孩子，让唯一的孩子继位</li><li>有两个孩子，此时需寻找右子树的最小值 &#x2F; 左子树的最大值，与其交换</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (root.val == key)&#123;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.right;<span class="hljs-comment">//处理一个或两个子节点为空的情况</span><br>        <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.left;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> getMin(root.right);   <span class="hljs-comment">//两节点都不为空时</span><br>        root.right = deleteNode(root.right, minNode.val);<span class="hljs-comment">//删除右子树的最小值</span><br>        minNode.left = root.left;                        <span class="hljs-comment">//交换</span><br>        minNode.right = root.right;<br>        root = minNode;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; key)&#123;<br>        root.left =  deleteNode(root.left, key);<br>    &#125;<span class="hljs-keyword">else</span> root.right =  deleteNode(root.right, key);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">getMin</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>    <span class="hljs-keyword">while</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>        node = node.left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>普通二叉树的删除版本：</li><li>待删除的节点需走两次:<ul><li>和其右子树最左边的节点进行值交换,此时待删除的节点成为叶子节点</li><li>该叶子节点被删除</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">delete</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (root.val == key)&#123;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.right;<br>        <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.left;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> root.right;<br>        <span class="hljs-keyword">while</span> (pre.left != <span class="hljs-literal">null</span>)&#123;<br>            pre = pre.left;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> pre.val;<br>        pre.val = root.val;<br>        root.val = tmp;<br>    &#125;<br><br>    root.left = delete(root.left, key);<br>    root.right = delete(root.right, key);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>遍历方式</title>
    <link href="/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/1.%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
    <url>/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/1.%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。<strong>栈</strong><ul><li>前序遍历（递归法，迭代法）：根左右</li><li>中序遍历（递归法，迭代法）：左根右</li><li>后序遍历（递归法，迭代法）：左右根</li></ul></li><li>广度优先遍历：一层一层的去遍历。<strong>队列</strong><ul><li>层次遍历（迭代法）</li></ul></li></ol><h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><p>对应leetcode：</p><ul><li>144.二叉树的前序遍历</li><li>145.二叉树的后序遍历</li><li>94.二叉树的中序遍历</li></ul><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><ul><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归逻辑</li></ul><p>三种遍历只需修改加入answer的顺序即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root,List&lt;Integer&gt; ans)</span>&#123;      <span class="hljs-comment">//preOrder,inOrder,postOrder</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    inorder(root.left,ans);<br>    ans.add(root.val);<br>    inorder(root.right,ans);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h2><ol><li><p>前序遍历</p><p>由于是根左右，将根节点入栈后，先堆入右节点以便弹出时顺序正确。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> ans;<br>    stack.push(root);<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>        ans.add(node.val);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) stack.push(node.right);<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) stack.push(node.left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>中序遍历</p><p>需要一直寻找到根的左叶子节点才能出栈</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Stack&lt;TreeNode&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span> ( root!= <span class="hljs-literal">null</span> || !stk.isEmpty() ) &#123;<br>        <span class="hljs-keyword">while</span> ( root!= <span class="hljs-literal">null</span>) &#123;<br>            stk.push(root);<br>            root = root.left;<br>        &#125;<br>        root = stk.pop();<br>        ans.add(root.val);<br>        root = root.right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>后序遍历</p><ul><li>由先序遍历修改一下：根左右 -&gt; 根右左</li><li>再反转结果：左右根</li><li>反转用头插法或者Collections.reverse(ans)都行</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();                 <span class="hljs-comment">//头插法用LinkedList</span><br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list;<br>    stack.push(root);<br><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>        list.addFirst(node.val);<br><br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) stack.push(node.left);<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) stack.push(node.right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="统一的迭代格式"><a href="#统一的迭代格式" class="headerlink" title="统一的迭代格式"></a>统一的迭代格式</h2><p>前序和中序遍历之所以风格迥然不同，是因为中序遍历无法解决：访问节点（遍历节点）和处理节点（加入结果集）之间不一致的关系。</p><p>那如何统一？</p><p>标记。将遍历到且未处理的节点之后加入一个空节点以作标记；只有空节点之后的节点才加入结果集。</p><p>如此，三种遍历只需更改添加节点的顺序即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) st.push(root);<br><br>    <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> st.peek();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            st.pop();               <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>            <span class="hljs-keyword">if</span> (node.right!=<span class="hljs-literal">null</span>) st.push(node.right);          <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node.left!=<span class="hljs-literal">null</span>) st.push(node.left);            <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>            st.push(node);                                      <span class="hljs-comment">// 添加中节点</span><br>            st.push(<span class="hljs-literal">null</span>);                <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><br>        &#125; <span class="hljs-keyword">else</span> &#123;                             <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>            st.pop();                        <span class="hljs-comment">// 将空节点弹出</span><br>            node = st.peek();                <span class="hljs-comment">// 重新取出栈中元素</span><br>            st.pop();<br>            result.add(node.val);            <span class="hljs-comment">// 加入到结果集</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h1><p>对应leetcode:（BFS和DFS均可以解决、标记√的有小技巧、*的需常数级空间复杂度）</p><ul><li>102.二叉树的层序遍历</li><li>107.二叉树的层次遍历II</li><li>199.二叉树的右视图 √</li><li>637.二叉树的层平均值</li><li>429.N叉树的层序遍历 √</li><li>515.在每个树行中找最大值 √</li><li>116.填充每个节点的下一个右侧节点指针　*</li><li>117.填充每个节点的下一个右侧节点指针II　*</li><li>104.二叉树的最大深度　√</li><li>111.二叉树的最小深度　√</li></ul><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h2><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例：</p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" width="50%"><p>输入: [1,2,3,null,5,null,4]</p><p>输出: [1,3,4]</p><h3 id="思路：BFS和DFS均可做"><a href="#思路：BFS和DFS均可做" class="headerlink" title="思路：BFS和DFS均可做"></a>思路：BFS和DFS均可做</h3><ol><li><p>BFS: breadth 广度优先搜索</p><ul><li>利用队列记录每一层的信息，到达最右边的节点时记录到answer中</li></ul></li><li><p>DFS：深度优先搜索</p><ul><li>最先访问右子树，保证每一层见到的第一个节点是最右边的节点。</li></ul></li></ol><img src="https://assets.leetcode-cn.com/solution-static/199/fig1.png" width="50%"><p>上图表示了问题的一个实例。红色结点自上而下组成答案，边缘以访问顺序标号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BFS：</span><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br><br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br><br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span>(i == n - <span class="hljs-number">1</span>) res.add(node.val);    <span class="hljs-comment">//最右边的节点</span><br><br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">//DFS：根 - 右 - 左 的顺序访问</span><br><br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> depth)</span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">//如果当前节点所在深度还没有出现在res里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。</span><br><span class="hljs-comment">//换言之，如果该层已经有值加入了res，则depth与res.size()一定不等。</span><br><br>        <span class="hljs-keyword">if</span> (depth == res.size())&#123;<br>            res.add(node.val);<br>        &#125;<br><br>        depth++;<br>        dfs(node.right,depth);<br>        dfs(node.left,depth);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a>429. N 叉树的层序遍历</h2><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><img src = "https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" width="50%"><p>输入：root &#x3D; [1,null,3,2,4,null,5,6]</p><p>输出：[ [1],[3,2,4],[5,6] ]</p><p><strong>思路：</strong></p><ol><li>BFS：队列，有个API可以addAll(node.children)</li><li>DFS：虽然不能用递归来实现广度优先搜索，但可以深度优先搜索但按找层序来添加进结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BFS</span><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br><br>    Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            list.add(node.val);<br><br>            queue.addAll(node.children);        <span class="hljs-comment">//API!</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DFS</span><br><span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) dfs(root, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> level)</span>&#123;<br>    <span class="hljs-keyword">if</span> (res.size() &lt;= level)&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    &#125;<br><br>    res.get(level).add(node.val);           <span class="hljs-comment">//但按照层序来添加值进结果</span><br><br>    <span class="hljs-keyword">for</span> (Node child : node.children) &#123;      <span class="hljs-comment">//虽不是按层序来遍历</span><br>        dfs(child, level + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a>515. 在每个树行中找最大值</h2><p>给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><p>输入: root &#x3D; [1,3,2,5,3,null,9]</p><p>输出: [1,3,9]</p><p>解释:</p><pre><code class="hljs">      1     / \    3   2   / \   \  5   3   9</code></pre><p><strong>思考：</strong></p><ol><li>BFS：队列、设 max 进行比较；略</li><li>DFS：（不熟练）和119、429题很相似；list的set(int index, Integer element)注意一下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestValues</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) dfs(root, res, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, List&lt;Integer&gt; res, <span class="hljs-type">int</span> level)</span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (level &gt; res.size())&#123;<br>        res.add(node.val);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> res.get(level);<br>        <span class="hljs-keyword">if</span> (pre &gt; node.val)&#123;<br>            res.set(level, node.val);    <span class="hljs-comment">//.set(int index, Integer element)</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) dfs(node.left, res, level + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) dfs(node.right, res, level + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="116-amp-117-填充每个节点的下一个右侧节点指针-II"><a href="#116-amp-117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="116. &amp; 117. 填充每个节点的下一个右侧节点指针(II)"></a>116. &amp; 117. 填充每个节点的下一个右侧节点指针(II)</h2><p>给定一个完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">struct Node &#123;<br>    <span class="hljs-type">int</span> val;<br>    Node *left;<br>    Node *right;<br>    Node *next;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><img src = "https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" width = "50%"><img src = "https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" width = "50%"><p><strong>两题区别仅在于是否是完美二叉树</strong></p><p>进阶：</p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><strong>思考：</strong><br>使用队列实现层序遍历，边遍历边连接很好写，但如何不使用额外空间？</p><ol><li><p>取巧但不普适。</p><ul><li>题目说<strong>完全</strong>二叉树节点数少于4096意味着最多有12层。（2^12&#x3D;4096）</li><li>创建一个固定大小的数组存储每一层应该被指向的next信息，并不断更新</li><li><strong>对于普通二叉树、不知总节点数的情况并不适用；因为无法确定数组大小</strong></li></ul></li><li><p>站在第N层，去构建n+1层的next关系</p><ul><li>因为对树的结构一无所知，所以使用队列保证有序访问同一层的所有节点，并建立它们之间的连接。</li><li>一旦在某层的节点之间建立了next 指针，那这层节点实际上形成了一个链表。</li><li>如果先去建立某一层的 next 指针，再去遍历这一层，就无需再使用队列了。</li><li>情况1: 两个子节点属于同一个父节点：node.left.next &#x3D; node.right</li><li>情况2：连接不同父节点之间的子节点，但它们的父节点已经被连接好了: node.right.next &#x3D; node.next.left</li></ul></li></ol><ul><li>取巧</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node[] levels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">12</span>];<br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) &#123;<br>        Arrays.fill(levels, <span class="hljs-literal">null</span>);<br>        dfs(root,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> level)</span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    node.next = levels[level];<br>    dfs(node.right, level + <span class="hljs-number">1</span>);<br>    dfs(node.left, level + <span class="hljs-number">1</span>);<br>    levels[level] = node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>完全二叉树：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//每次去寻找最左边的点即每一层链表的头节点</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">leftMost</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (leftMost.left != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> leftMost;<br>            <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>)&#123;<br>                node.left.next = node.right;<br>                <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>) node.right.next = node.next.left;<br>                node = node.next;<br>            &#125;<br>            leftMost = leftMost.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>普通二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//评论区的：注重模拟过程</span><br><span class="hljs-comment">//getNext()函数十分巧妙，整体代码也很易懂</span><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>)&#123;<br>            root.left.next = root.right;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>            root.left.next = getNext(root.next);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>)&#123;<br>            root.right.next = getNext(root.next);<br>        &#125;<br><br>        connect(root.right);    <span class="hljs-comment">//先构建右边的连接，不然左边的无法getNext</span><br>        connect(root.left);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getNext</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> node.left;<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> node.right;<br>        <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> getNext(node.next);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//官解：很显式的表现出来了已经创建好连接的节点们仅需.next就可以连接，无需链表</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, nextStart = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (start != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> start; p != <span class="hljs-literal">null</span>; p = p.next)&#123;<br>                <span class="hljs-keyword">if</span> (p.left != <span class="hljs-literal">null</span>)&#123;<br>                    handle(p.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (p.right != <span class="hljs-literal">null</span>)&#123;<br>                    handle(p.right);<br>                &#125;<br>            &#125;<br>            start = nextStart;<br>            nextStart = <span class="hljs-literal">null</span>;last = <span class="hljs-literal">null</span>;    <span class="hljs-comment">//每一层结束后要清零</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span> (last != <span class="hljs-literal">null</span>)&#123;         <span class="hljs-comment">//last记录的前向节点，非空时直接指向当前节点</span><br>            last.next = node;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nextStart == <span class="hljs-literal">null</span>)&#123;   <span class="hljs-comment">//每一层的第一个节点才会被记录下来，以便start跳转</span><br>            nextStart = node;<br>        &#125;<br>        last = node;             <span class="hljs-comment">//每一个当前节点都是下一个的前向节点</span><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>翻转&amp;对称</title>
    <link href="/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/2.%E7%BF%BB%E8%BD%AC%E3%80%81%E5%AF%B9%E7%A7%B0/"/>
    <url>/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/2.%E7%BF%BB%E8%BD%AC%E3%80%81%E5%AF%B9%E7%A7%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="显式的写出递归逻辑，更好理解"><a href="#显式的写出递归逻辑，更好理解" class="headerlink" title="显式的写出递归逻辑，更好理解"></a>显式的写出递归逻辑，更好理解</h1><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-number">4</span><br>   /   \<br>  <span class="hljs-number">2</span>     <span class="hljs-number">7</span><br> / \   / \<br><span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-number">4</span><br>   /   \<br>  <span class="hljs-number">7</span>     <span class="hljs-number">2</span><br> / \   / \<br><span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。</p><p><strong>思考：</strong></p><ol><li>前序遍历和后序遍历均可实现；</li><li>中序遍历的递归会导致某些节点被翻转两次，需作修改。（靠指针来遍历的）</li><li>而中序遍历的迭代则不用修改，因为是靠栈来遍历的。（很有意思）</li><li>层序遍历也可以实现。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DFS递归：前序和后序遍历一样的</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> ( root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//先将当前节点的左右子树交换</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> root.right;<br>        root.right = root.left;<br>        root.left = tmp;<br>        <span class="hljs-comment">//再递归交换当前节点的左子树和右子树</span><br>        invertTree(root.left);<br>        invertTree(root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DFS中序遍历递归实现：return前的稍作修改了</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> ( root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        invertTree(root.left);                       <span class="hljs-comment">//遍历到叶节点，自底向上</span><br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightTree</span> <span class="hljs-operator">=</span> root.right;             <span class="hljs-comment">//交换</span><br>        root.right = root.left;<br>        root.left = rightTree;<br><br>        invertTree(root.left);     <span class="hljs-comment">//当前左右节点已更换，继续遍历原先的右节点（即现在是左节点）</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DFS中序遍历迭代实现：无需修改；采用通用方式书写</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Stack&lt;TreeNode&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stk.push(root);<br><br>        <span class="hljs-keyword">while</span>(!stk.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stk.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">null</span>)&#123;<br>                stk.pop();                           <span class="hljs-comment">//避免重复，先弹出</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) stk.push(node.right);  <span class="hljs-comment">//右</span><br>                stk.push(node);                               <span class="hljs-comment">//中</span><br>                stk.push(<span class="hljs-literal">null</span>);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) stk.push(node.left);   <span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stk.pop();<br>                node = stk.pop();<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> node.right;                  <span class="hljs-comment">//交换</span><br>                node.right = node.left;<br>                node.left = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//层序遍历的实现:</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    deque.offerLast(root);<br><br>    <span class="hljs-keyword">while</span> (!deque.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> deque.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> node.right;<br>            node.right = node.left;<br>            node.left = tmp;<br><br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) deque.offerLast(node.left);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) deque.offerLast(node.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-number">1</span><br>   / \<br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> / \ / \<br><span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-number">1</span><br> / \<br><span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> \   \<br> <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>比较的是两个子树的里侧和外侧的元素是否相等。</li><li>选择后序遍历：原因是需要获得左右子树判断后的结果。</li><li>一个子树的遍历顺序是左右中，另一个是右左中</li></ul><img src = "https://img-blog.csdnimg.cn/20210203144624414.png" width = "75%"><p>将每一步判断逻辑都显示出来的非简洁代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> </span>&#123;<br>        <span class="hljs-comment">// 首先排除空节点的情况</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 排除了空节点，再排除数值不相同的情况</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//这里用的不是else</span><br><br>        <span class="hljs-comment">// 此时就是：左右节点都不为空，且数值相同的情况</span><br>        <span class="hljs-comment">// 此时才做递归，做下一层的判断</span><br>        <span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="hljs-comment">// 左子树：左、 右子树：右</span><br>        <span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="hljs-comment">// 左子树：右、 右子树：左</span><br>        <span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="hljs-comment">// 左子树：中、 右子树：中 （逻辑处理）</span><br>        <span class="hljs-keyword">return</span> isSame;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>简洁版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">return</span> isSameTree(root.left, root.right);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> ( p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> ( p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> ( p.val != q.val ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> isSameTree(p.left,q.right) &amp;&amp; isSameTree(p.right,q.left);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><p>使用队列或者栈，按次序的放入左右子树，再两两取出比较即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//栈</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    stack.push(root.left);<br>    stack.push(root.right);<br><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-keyword">if</span> (leftNode == <span class="hljs-literal">null</span> &amp;&amp; rightNode == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (leftNode == <span class="hljs-literal">null</span> || rightNode == <span class="hljs-literal">null</span> || leftNode.val != rightNode.val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        stack.push(rightNode.right);     <span class="hljs-comment">//栈就无所谓，按相对顺序填入每两两取出比较即可。</span><br>        stack.push(leftNode.left);<br>        stack.push(rightNode.left);<br>        stack.push(leftNode.right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似题目：</p><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h2><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><img src = "https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" width = "75%" ><ul><li>去分别判断就好啦</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> ( p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> ( p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> ( p.val != q.val ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572.另一个树的子树"></a>572.另一个树的子树</h2><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><p>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p><p>示例；</p><img src = "https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg" width = "50%"><p>输入：root &#x3D; [3,4,5,1,2], subRoot &#x3D; [4,1,2]</p><p>输出：true</p><img src = "https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg" width = "50%"><p>输入：root &#x3D; [3,4,5,1,2,null,null,null,null,0], subRoot &#x3D; [4,1,2]</p><p>输出：false</p><ul><li>思路1：dfs暴力匹配</li></ul><p>一个树是另一个树的子树则：要么这两个树相等、要么这个树是左树的子树、要么这个树是右树的子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubtree</span><span class="hljs-params">(TreeNode root, TreeNode subRoot)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> &amp;&amp; subRoot == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;           <span class="hljs-comment">//预处理</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> isSameTree(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;    <span class="hljs-comment">//判断是否相等</span><br><br>    <span class="hljs-keyword">if</span> ( p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> ( p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> ( p.val != q.val ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>思路2：KMP</li></ul><p>若一个树是另一个树的子树，则它们前序遍历的结果一定是包含关系；</p><p>但反过来讲不一定，例如2分别是1的左&#x2F;右子树</p><p>通过添加两个起标记作用的空节点lNull、rNull来完善前序遍历。是否匹配：KMP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; sublist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, lNull, rNull;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubtree</span><span class="hljs-params">(TreeNode root, TreeNode subRoot)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> &amp;&amp; subRoot == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;           <span class="hljs-comment">//预处理</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    getMax(root);<br>    getMax(subRoot);<br>    lNull = maxValue + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//由于节点的数值在-10^4 - 10^4，获取最大值来创建两个不存在的节点</span><br>    rNull = maxValue + <span class="hljs-number">2</span>;<br><br>    dfs(root, list);<br>    dfs(subRoot, sublist);<br><br>    <span class="hljs-keyword">return</span> kmp();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    maxValue = Math.max(maxValue, node.val);<br>    getMax(node.left);<br>    getMax(node.right);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, List&lt;Integer&gt; list)</span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    list.add(node.val);<br>    <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)&#123;<br>        dfs(node.left, list);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        list.add(lNull);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)&#123;<br>        dfs(node.right, list);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        list.add(rNull);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">kmp</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">Len</span> <span class="hljs-operator">=</span> list.size(), sLen = sublist.size();<br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sLen];<br>    Arrays.fill(next, -<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = -<span class="hljs-number">1</span>; i &lt; sLen; i++)&#123;<br>        <span class="hljs-keyword">while</span> (j != -<span class="hljs-number">1</span> &amp;&amp; !sublist.get(i).equals(sublist.get(j + <span class="hljs-number">1</span>)))&#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sublist.get(i).equals(sublist.get(j + <span class="hljs-number">1</span>)))&#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = -<span class="hljs-number">1</span>; i &lt; Len; i++)&#123;<br>        <span class="hljs-keyword">while</span> (j != -<span class="hljs-number">1</span> &amp;&amp; !list.get(i).equals(sublist.get(j + <span class="hljs-number">1</span>)))&#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (list.get(i).equals(sublist.get(j + <span class="hljs-number">1</span>)))&#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == sLen - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大&amp;最小深度</title>
    <link href="/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/3.%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <url>/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/3.%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h1><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例： 给定二叉树 [3,9,20,null,null,15,7]</p><img src = "https://img-blog.csdnimg.cn/20210203153031914.png"><p>返回它的最大深度 3。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li><p>前序和后序均可实现，前序（中左右）计算的是树的深度带有隐藏的回溯；后序（左右中）计算的是高度。而根节点的高度就是二叉树的最大深度。</p></li><li><p>若用后序遍历来写，递归有返回值来记录深度。</p></li></ul><p>细节：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> leftdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;left);       <span class="hljs-comment">// 左</span><br><span class="hljs-type">int</span> rightdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;right);     <span class="hljs-comment">// 右</span><br><span class="hljs-type">int</span> depth = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftdepth, rightdepth); <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">return</span> depth;<br></code></pre></td></tr></table></figure><p>整体：（简洁版）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxdepth</span><span class="hljs-params">(treenode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> math.max(maxdepth(root.left), maxdepth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="迭代：层序遍历"><a href="#迭代：层序遍历" class="headerlink" title="迭代：层序遍历"></a>迭代：层序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<br>        maxLevel++;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxLevel;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>559.n叉树的最大深度</li></ul><p>类同，略</p><h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h1><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><img src = "https://img-blog.csdnimg.cn/2021020315582586.png"><p>返回它的最小深度 2。</p><h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><img src = "https://img-blog.csdnimg.cn/20210203155800503.png" width = "50%"><p>不是深度直接取小，而是走到了叶子节点才算计算了深度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;left);           <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> rightDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;right);         <span class="hljs-comment">// 右</span><br>                                                        <span class="hljs-comment">// 中</span><br>        <span class="hljs-comment">// 当一个左子树为空，右不为空，这时并不是最低点</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightDepth;<br>        &#125;<br>        <span class="hljs-comment">// 当一个右子树为空，左不为空，这时并不是最低点</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftDepth;<br>        &#125;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(leftDepth, rightDepth);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>简洁版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> ( root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> ( root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> ( root.left == <span class="hljs-literal">null</span> ) &#123;<br>            <span class="hljs-keyword">return</span> minDepth(root.right) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ( root.right == <span class="hljs-literal">null</span> ) &#123;<br>            <span class="hljs-keyword">return</span> minDepth(root.left) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>迭代用层序遍历一样的。</p>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>完全二叉树</title>
    <link href="/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/4.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/4.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h1><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：</p><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</p><p>若最底层为第 h 层，则该层包含 1~ 2^h 个节点。</p><p>示例：</p><img src = "https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" width = "25%"><p>输入：root &#x3D; [1,2,3,4,5,6]</p><p>输出：6</p><h2 id="「完全二叉树」和「满二叉树」"><a href="#「完全二叉树」和「满二叉树」" class="headerlink" title="「完全二叉树」和「满二叉树」"></a>「完全二叉树」和「满二叉树」</h2><p>完全二叉树：每一层都是紧凑靠左排列的。</p><img src = "https://labuladong.gitee.io/algo/images/complete_tree/complete.png" width = "50%"><p>满二叉树：一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：</p><img src = "https://labuladong.gitee.io/algo/images/complete_tree/perfect.png"><h2 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h2><ol><li>普通二叉树时间和空间复杂度均为o(n)，其递归形式为：<ul><li>return countNodes(root.left) + countNodes(root.right) + 1; 左右中的遍历顺序</li></ul></li><li>对于满二叉树，若其树高为h，则节点总数为Math.pow(2,h-1) + 1<ul><li>注意此处根节点深度为1</li></ul></li><li>对于完全二叉树，如何兼顾二者的特点？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root, right = root;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightHeight = <span class="hljs-number">0</span>;     <span class="hljs-comment">//预设根节点深度为0，后续计算时指数无需减1</span><br><br>    <span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-comment">//通过左子树往左走，右子树往右走，判断是否是满二叉树</span><br>        leftHeight++;<br>        left = left.left;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (right != <span class="hljs-literal">null</span>)&#123;<br>        rightHeight++;<br>        right = right.right;<br>    &#125;<br><br>    <span class="hljs-comment">//如果左右子树是满二叉树，则返回节点个数</span><br>    <span class="hljs-keyword">if</span> (leftHeight == rightHeight)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (Math.pow(<span class="hljs-number">2</span> , leftHeight) - <span class="hljs-number">1</span>);   <span class="hljs-comment">//2 &lt;&lt; i 等同于 Math.pow(2,i+1)</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度分析：o(logN * logN)，N为树的节点总个数</li></ul><ol><li>while需要logN的时间</li><li>递归看起来是要o(n)，但实际上是o(logN)<ul><li><strong>一棵完全二叉树的两棵子树，至少有一棵是满二叉树：</strong></li><li>两个递归只有一个会真的递归下去，另一个一定会触发 leftHeight &#x3D;&#x3D; rightHeight 而立即返回，不会递归下去。</li></ul></li></ol><ul><li>另一种写法是：不用while循环校验是否是满二叉树</li></ul><ol><li>若左右子树高度不同，则右子树为满二叉树。对应示例中root &#x3D; [1,2,3,4,5]的情况。</li><li>若高度相同，则左子树是满二叉树。因为完全二叉树是每一层紧凑靠左排列的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>)&#123;<br>        res++;<br>        node = node.left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//去计算左右子树的高度：相等时再返回节点个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes1</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> getHeight(root.left);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> getHeight(root.right);<br><br>    <span class="hljs-keyword">if</span> (left == right)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (Math.pow(<span class="hljs-number">2</span>, left) + countNodes1(root.right));<span class="hljs-comment">//左子树+根节点的个数</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (Math.pow(<span class="hljs-number">2</span>, right) + countNodes1(root.left));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路2：二分查找-位运算"><a href="#思路2：二分查找-位运算" class="headerlink" title="思路2：二分查找 + 位运算"></a>思路2：二分查找 + 位运算</h2><ol><li><p>在知道树高h的情况下，完全二叉树提供了其总节点数的范围：</p><ul><li>当 0 ≤ i &lt; h 时，第 i 层包含 2^i 个节点，最底层包含的节点数最少为 1，最多为 2^h</li><li>节点个数一定在 [2^h , 2^(h+1) - 1] 的范围内，即可进行查找。</li></ul></li><li><p>普通二分查找时间复杂度为o(logN)，即比o(N)快。</p><ul><li>如果第 k 个节点存在，则节点个数一定大于或等于 k，如果第 k 个节点不存在，则节点个数一定小于 k，由此可以将查找的范围缩小一半，直到得到节点个数。</li></ul></li><li><p>但树不像数组有索引很方便查找，那如何确定树的节点？</p><ul><li>用0、1记录树的状态：0 表示移动到左子节点，1 表示移动到右子节点。</li><li>如果第 k 个节点位于第 h 层，则 k 的二进制表示包含 h+1 位，其中最高位是 1</li><li>通过位运算得到第 k 个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 k 个节点是否存在。</li></ul></li></ol><img src = "https://assets.leetcode-cn.com/solution-static/222/1.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二分查找 + 位运算</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes2</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>    <span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>)&#123;         <span class="hljs-comment">//node.left,让后续 1 &lt;&lt; h 无需再减</span><br>        h++;<br>        node = node.left;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; h, right = (<span class="hljs-number">1</span> &lt;&lt; (h + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>;   <span class="hljs-comment">//必须有括号以界定优先级</span><br>    <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (exit(root, h, mid))&#123;<br>            left = mid;              <span class="hljs-comment">//存在时mid有可能就是最后一个</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;         <span class="hljs-comment">//不存在时right一定没有mid</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">bits</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (h - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> &amp;&amp; bits &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> ((k &amp; bits) == <span class="hljs-number">0</span>)&#123;<br>            node = node.left;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            node = node.right;<br>        &#125;<br>        bits &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><p>示例：</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><img src = "https://img-blog.csdnimg.cn/2021020315542230.png" ><p>return true</p><p><strong>思路：</strong></p><ul><li><p>强调一波概念：</p><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</li></ul></li><li><p>在递归求树高的同时，还要不断的判断，遇到不满足的可以不断return false不用再计算别的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">return</span> getHeight(root) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftHeight</span> <span class="hljs-operator">=</span> getHeight(node.left);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightHeight</span> <span class="hljs-operator">=</span> getHeight(node.right);<br><br>    <span class="hljs-keyword">if</span> (leftHeight == -<span class="hljs-number">1</span> || rightHeight == -<span class="hljs-number">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归&amp;回溯</title>
    <link href="/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/5.%E9%80%92%E5%BD%92%E9%9A%90%E8%97%8F%E4%BA%86%E5%9B%9E%E6%BA%AF/"/>
    <url>/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/5.%E9%80%92%E5%BD%92%E9%9A%90%E8%97%8F%E4%BA%86%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="深拷贝、浅拷贝；传值、传地址"><a href="#深拷贝、浅拷贝；传值、传地址" class="headerlink" title="深拷贝、浅拷贝；传值、传地址"></a>深拷贝、浅拷贝；传值、传地址</h1><h2 id="对于C、C-、java的任何赋值（即“-x3D-”）"><a href="#对于C、C-、java的任何赋值（即“-x3D-”）" class="headerlink" title="对于C、C++、java的任何赋值（即“&#x3D;”）"></a>对于C、C++、java的任何赋值（即“&#x3D;”）</h2><ul><li>想看后者（被赋值被传参者）的动作是否会影响到原先的值，只需明白：<ul><li>对于8个基本类型（byte、short、int、long、float、double、boolean、char）<br>是深拷贝（新开辟空间存储后者）不会影响</li><li>对于非基本如TreeNode，String，是浅拷贝（直接指针指向前者）会影响</li></ul></li><li>因为像TreeNode或者自行创建的一个class，其空间很大，盲目复制很占空间。</li><li>String和TreeNode一样都是一个类，只是太常用被开发者省略了new的过程：<ul><li>String s &#x3D; “a” 和 String s &#x3D; new String(“a”) 一样</li></ul></li></ul><h2 id="传值和传地址"><a href="#传值和传地址" class="headerlink" title="传值和传地址"></a>传值和传地址</h2><p>对于函数传参：</p><ul><li>基本类型：新开辟地址传的是值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>    swap(a, b);<br>    System.out.println(a);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> x; x = y; y = tmp;&#125;<br></code></pre></td></tr></table></figure><p>执行swap函数时，x、y新开辟地址拷贝过来a、b的值，进行交换，结束时对a、b的值无影响。</p><p>即输出的a仍为1。</p><ul><li>非基本类型：</li></ul><p>一样的，只不过不是开辟新内存，而是创建新指针指向即传参传的是地址。</p><p>即上述a、b换成String类型的，执行完swap函数后，a还是“1”。</p><h3 id="那怎样才能修改到值呢？（真正实现函数所想实现的）"><a href="#那怎样才能修改到值呢？（真正实现函数所想实现的）" class="headerlink" title="那怎样才能修改到值呢？（真正实现函数所想实现的）"></a>那怎样才能修改到值呢？（真正实现函数所想实现的）</h3><ul><li>对于TreeNode这种自己写的类（知道其内部有<code>val、leftChild 、rightChild</code>这些成员变量）</li><li>可以通过更改其指针指向的值来实现：<ul><li>x.val &#x3D; 8；</li><li>因为a和x都指向这个TreeNode类，更改x的val也就是更改了a的val。</li></ul></li></ul><h3 id="为什么String这么特殊呢？"><a href="#为什么String这么特殊呢？" class="headerlink" title="为什么String这么特殊呢？"></a>为什么String这么特殊呢？</h3><ol><li>String是一个类，函数传参时是指针引用，和其他非基本类型一样例如list</li><li>但String特殊在它指向的是一个常量，每次都是创建新指针来指向复制赋值以后的东西；与list那种可修改数组不同</li><li>函数传参时，先新开辟一段新内存copy过来原先的常量，再用新的指针指向这段内存</li><li>所以修改后者不会影响前者；但copy会占用多余的时间复杂度o(n)</li></ol><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><img src = "https://img-blog.csdnimg.cn/2021020415161576.png" width = "75%"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><img src = "https://img-blog.csdnimg.cn/20210204151702443.png" width = "75%"><ol><li>要遍历完树的所有节点才能返回记录到的路径</li><li>但路径添加到结果后要有删除的步骤，才能进行下一次遍历。</li><li>递归和回溯本就一体，有时隐藏了，此题才显式的看到。</li></ol><h3 id="回溯隐藏了，copy占用多的时间复杂度"><a href="#回溯隐藏了，copy占用多的时间复杂度" class="headerlink" title="回溯隐藏了，copy占用多的时间复杂度"></a>回溯隐藏了，copy占用多的时间复杂度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">  List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths3</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>      dfs(root, <span class="hljs-string">&quot;&quot;</span>);<br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, String s)</span>&#123;<br>      <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>)&#123;<br>          s += node.val;<br>          res.add(s);<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      s += node.val + <span class="hljs-string">&quot;-&gt;&quot;</span>;<br><br><span class="hljs-comment">//函数传参的s是新建的指针，新复制的常量，与前一行的s不同；所以无需像list那样回退，</span><br><span class="hljs-comment">//但时间复杂度也高毕竟算上复制的。</span><br>      <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) dfs(node.left, s);<br>      <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) dfs(node.right, s);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="显式回溯，传参时仅指针指向，无需copy"><a href="#显式回溯，传参时仅指针指向，无需copy" class="headerlink" title="显式回溯，传参时仅指针指向，无需copy"></a>显式回溯，传参时仅指针指向，无需copy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用list显式的表达出回溯：运行时间也从9ms到1ms；list和StringBuilder一样的效果</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths4</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list;<br><br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPath</span><span class="hljs-params">(TreeNode node, List&lt;Integer&gt; path, List&lt;String&gt; list)</span>&#123;<br>    path.add(node.val);<br><br>    <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; path.size() - <span class="hljs-number">1</span>; i++)&#123;<br>            sb.append(path.get(i)).append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>        &#125;<br>        sb.append(path.get(path.size() - <span class="hljs-number">1</span>));<br>        list.add(sb.toString());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>        addPath(node.left, path, list);<br>        path.remove(path.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)&#123;<br>        addPath(node.right, path, list);<br>        path.remove(path.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他题：</p><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h2><p>计算给定二叉树的所有左叶子之和。</p><img src = "https://img-blog.csdnimg.cn/20210204151927654.png" width = "75%"><p>厘清概念和题意就行</p><ol><li>迭代：层序遍历，每一层第一个节点的左右孩子为空则加入答案</li><li>递归：从父节点判断其左孩子的左右孩子是否为空</li></ol><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h2><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p>示例：</p><img src = "https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" width = "25%"><p>输入: [1,2,3,4,null,5,6,null,null,7]</p><p>输出: 7</p><ol><li>迭代：层序遍历，每走一层用最左边的值更新答案</li><li>递归：需要深度的信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> maxDepth, res;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    maxDepth = <span class="hljs-number">1</span>;<br>    res = root.val;<br>    dfs(root, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> depth)</span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(depth &gt; maxDepth)&#123;<br>            maxDepth = depth;<br>            res = node.val;<br>        &#125;<br>    &#125;<br><br>    dfs(node.left, depth + <span class="hljs-number">1</span>);<br>    dfs(node.right, depth + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>递归函数什么时候需要返回值？</p><ul><li>无需走完所有节点的时候即搜索某一路径，因为遇到满足条件的直接返回无需再走了。</li><li>而搜索整棵树即无需返回值</li></ul><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span> ( root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> ( root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> ) &#123;<br>        <span class="hljs-keyword">return</span> targetSum - root.val == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> hasPathSum(root.left,targetSum - root.val) || hasPathSum(root.right,targetSum - root.val);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路径总和ii"><a href="#113-路径总和ii" class="headerlink" title="113.路径总和ii"></a>113.路径总和ii</h2><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br><br>    addPath(root, targetSum, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPath</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> target, List&lt;Integer&gt; list)</span>&#123;<br>    list.add(node.val);<br><br>    <span class="hljs-keyword">if</span>(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (target == node.val)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>        addPath(node.left, target - node.val, list);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>        addPath(node.right, target - node.val, list);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>构造二叉树</title>
    <link href="/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/6.%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/6.%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="分治-递归"><a href="#分治-递归" class="headerlink" title="分治 + 递归"></a>分治 + 递归</h1><ul><li>切割区间时，保持区间不变性，以下全用左右双闭来写。</li><li>尽量在原数组上进行查找，也可以新建map以空间换时间。</li></ul><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder &#x3D; [9,3,15,20,7]</p><p>后序遍历 postorder &#x3D; [9,15,7,20,3]</p><p>返回如下的二叉树：</p><img src = "https://img-blog.csdnimg.cn/20210203154316774.png"><p><strong>思路：</strong></p><ol><li>后序遍历的数组最后一个元素代表的即为根节点。</li><li>利用已知的根节点信息在中序遍历的数组中找到根节点所在的下标</li><li>该下标将中序遍历数组一分为二成为左右子树；再利用两遍历数组大小一致的特点来界定左右子树边界。</li><li>不想让2.的查找每次都遍历一次数组的话：建一个值和索引对应的map</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>    <span class="hljs-keyword">if</span> (inorder == <span class="hljs-literal">null</span> || inorder.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1 : inorder) &#123;<br>        map.put(i1, i++);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> inorder.length;<br>    <span class="hljs-keyword">return</span> build(<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,postorder,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> postLeft, <span class="hljs-type">int</span> postRight)</span>&#123;<br>    <span class="hljs-keyword">if</span> (inLeft &gt; inRight || postLeft &gt; postRight) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(postorder[postRight]);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> map.get(postorder[postRight]);<br><br>    root.right = build(idx + <span class="hljs-number">1</span>, inRight, postorder, postRight - inRight + idx,postRight - <span class="hljs-number">1</span>);<br>    root.left = build(inLeft,idx - <span class="hljs-number">1</span>,postorder,postLeft, postRight - inRight + idx - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p>Input:</p><p>preorder &#x3D; [3,9,20,15,7],</p><p>inorder &#x3D; [9,3,15,20,7]</p><p>Output: [3,9,20,null,null,15,7]</p><img src = "https://assets.leetcode.com/uploads/2021/02/19/tree.jpg"><p>思路类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//method1:分治、递归</span><br>    <span class="hljs-comment">//先序遍历提供根节点的信息，中序遍历提供了由根节点将整个序列分为左、右子树的信息。</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        Map&lt;Integer,Integer&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : inorder) &#123;<br>            hash.put(i,index++);           <span class="hljs-comment">//以空间换时间，每次由前序遍历根节点的值找到其在中序遍历中的位置</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> createTree(preorder,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,hash,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//preorder : 前序遍历序列</span><br>    <span class="hljs-comment">//preLeft,preRight : 前序遍历序列(子区间)的左右边界，闭区间</span><br>    <span class="hljs-comment">//hash : 中序遍历中数值与下标的关系</span><br>    <span class="hljs-comment">//inLeft,inRight : 中序遍历序列(子区间)的左右边界，闭区间</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">createTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preLeft, <span class="hljs-type">int</span> preRight, Map&lt;Integer,Integer&gt; hash, <span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight)</span>&#123;<br>        <span class="hljs-keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[preLeft];<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pIndex</span> <span class="hljs-operator">=</span> hash.get(rootVal);          <span class="hljs-comment">//根节点在中序遍历中的位置</span><br>        node.left = createTree(preorder,preLeft + <span class="hljs-number">1</span>, pIndex - inLeft + preLeft, hash,inLeft,pIndex - <span class="hljs-number">1</span>);<br>        node.right = createTree(preorder,pIndex - inLeft + preLeft + <span class="hljs-number">1</span>,preRight,hash,pIndex + <span class="hljs-number">1</span>,inRight);<br><br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br></code></pre></td></tr></table></figure><p>还有迭代写法、不好理解</p><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h2><p>给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p><ul><li>二叉树的根是数组 nums 中的最大元素。</li><li>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。</li><li>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。</li><li>返回有给定数组 nums 构建的 最大二叉树 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">return</span> buildTree(nums,<span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[left], idx = left;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt; right; i++)&#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; max)&#123;<br>            max = nums[i];<br>            idx = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(max);<br>    root.left = buildTree(nums, left, idx - <span class="hljs-number">1</span>);<br>    root.right = buildTree(nums, idx + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有单调栈解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//每次在一个区间内寻找最大值耗时</span><br><span class="hljs-comment">//单调栈：降序堆栈否则弹出</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[i]);                          <span class="hljs-comment">//3,2,1,6</span><br><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val &lt; cur.val)&#123;       <span class="hljs-comment">//1 &lt; 6</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();                              <span class="hljs-comment">//弹出1</span><br><br>            <span class="hljs-keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek().val &lt; cur.val)&#123;      <span class="hljs-comment">//2 &lt; 6</span><br>                stack.peek().right = node;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                cur.left = node;     <span class="hljs-comment">//当前节点是遍历到最新的一个节点，栈中节点肯定在其左侧</span><br>            &#125;<br>        &#125;<br>        stack.push(cur);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>        cur = stack.pop();<br><br>        <span class="hljs-keyword">if</span> (!stack.isEmpty())&#123;        <span class="hljs-comment">//栈中剩余的元素已经是降序排列，全排大者的右边</span><br>            stack.peek().right = cur;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BST</title>
    <link href="/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/7.BST%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/earsh9.github.io/2022/08/04/6.%E4%BA%8C%E5%8F%89%E6%A0%91/7.BST%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p><strong>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</strong></p><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h2><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><img src = "https://img-blog.csdnimg.cn/20210204155522476.png" width = "75%"><p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p><p><strong>思考：</strong></p><ul><li><p>利用BST的性质，根节点值小于目标值则去右子树搜索，反之亦然。</p></li><li><p><strong>在递归遍历的时候，什么时候直接return递归函数的返回值，什么时候不用加这个return呢</strong></p><ul><li>如果要搜索一条边，递归函数就要加返回值</li><li>因为搜索到目标节点了就可以即刻返回</li><li>若不加return就是搜索整棵树了</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 去左子树搜索</span><br>    <span class="hljs-keyword">if</span> (root.val &gt; target) &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.left, target);     <span class="hljs-comment">//要reutrn!</span><br>    &#125;<br>    <span class="hljs-comment">// 去右子树搜索</span><br>    <span class="hljs-keyword">if</span> (root.val &lt; target) &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.right, target);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="96题-不同的二叉搜索树"><a href="#96题-不同的二叉搜索树" class="headerlink" title="96题 不同的二叉搜索树"></a>96题 不同的二叉搜索树</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p>对于1到n的任意数i，均可以作为根节点，而其作为根节点对应的BST的个数F(i,n) &#x3D; G(i-1)*G(n-i)</p><p>对于长度为n的序列，其能构成不同BST的个数为：G(n)&#x3D; ∑ F(i,n) (i&#x3D;1:n)</p><p>边界情况：空树：G(0) &#x3D; 0;仅有一个根节点：G(1) &#x3D; 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sloution</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-type">int</span>[] G = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        G[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        G[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;          <span class="hljs-comment">//对于1到i中的任意节点j</span><br>                G[i] += G[j - <span class="hljs-number">1</span>] * G[i - j];     <span class="hljs-comment">//其BST个数为其左右子树集合个数的乘积</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> G[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="95题-不同的二叉搜索树II"><a href="#95题-不同的二叉搜索树II" class="headerlink" title="95题 不同的二叉搜索树II"></a>95题 不同的二叉搜索树II</h2><p><code>现要将这些不同的BST输出出来</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sloution</span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title function_">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">return</span> generate(<span class="hljs-number">1</span>,n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        List&lt;TreeNode&gt; allTrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            allTrees.add(<span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">return</span> allTrees;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            List&lt;TreeNode&gt; leftTrees = generate(start, i - <span class="hljs-number">1</span>);  <span class="hljs-comment">//获得所有可行的左右子树集合</span><br>            List&lt;TreeNode&gt; rightTrees = generate(i + <span class="hljs-number">1</span>, end);<br><br>            <span class="hljs-keyword">for</span>(TreeNode left : leftTrees)&#123;<br>                <span class="hljs-keyword">for</span>(TreeNode right : rightTrees)&#123;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">currTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(i);<br>                    currTree.left = left;                   <span class="hljs-comment">//每一节点只需拼接自己的左右子树</span><br>                    currTree.right = right;<br>                    allTrees.add(curTree);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> allTrees;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98题-验证二叉搜索树"><a href="#98题-验证二叉搜索树" class="headerlink" title="98题 验证二叉搜索树"></a>98题 验证二叉搜索树</h2><p>树中节点数目范围在[1, 104] 内</p><p>-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1</p><ul><li>二叉搜索树不仅要当前节点大于左子树小于右子树</li><li>root.val 要比左子树的所有节点都更大，要比右子树的所有节点都小，只检查左右两个子节点当然是不够的。</li><li>题目的陷阱：<ul><li><p>BST是严格大于不能取等号;</p></li><li><p>对int型数据的边界处理:</p><ul><li>用long型</li><li>虚拟一个前节点,预设为空</li></ul></li></ul></li></ul><p>处理陷阱的手法 530. 二叉搜索树的最小绝对差 也适用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isValid(root,Long.MIN_VALUE,Long.MAX_VALUE);<br>    &#125;<br><br><span class="hljs-comment">//任何node.val要在(lower,upper)之间，还是开区间</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(node.val &lt;= lower || node.val &gt;= upper)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> isValid(node.left,lower,node.val) &amp;&amp; isValid(node.right,node.val,upper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历：递归实现"><a href="#中序遍历：递归实现" class="headerlink" title="中序遍历：递归实现"></a>中序遍历：递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;          <span class="hljs-comment">//预设前序节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isValidBST(root.left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt;= pre.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isValidBST(root.right);<br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历：非递归实现"><a href="#中序遍历：非递归实现" class="headerlink" title="中序遍历：非递归实现"></a>中序遍历：非递归实现</h3><p>实时检查当前节点值是否大于前一个中序遍历到的节点值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">inorder</span> <span class="hljs-operator">=</span> -Double.MAX_VALUE;<br><br>        whlie(!stack.isEmpty || root != <span class="hljs-literal">null</span>)&#123;<br><br>            <span class="hljs-comment">//root跳出此while循环后就结束使命了，因为已经找见了前一个节点</span><br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br><br>            <span class="hljs-comment">//更新root，inorder记录前序节点的值</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">if</span>(root.val &lt;= inorder)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            inorder = root.val;<br>            root = root.right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="99题-恢复二叉搜索树"><a href="#99题-恢复二叉搜索树" class="headerlink" title="99题 恢复二叉搜索树"></a>99题 恢复二叉搜索树</h2><h3 id="1-显示中序遍历，写一个List放值，找到对应的节点，再重新遍历一遍去恢复"><a href="#1-显示中序遍历，写一个List放值，找到对应的节点，再重新遍历一遍去恢复" class="headerlink" title="1.显示中序遍历，写一个List放值，找到对应的节点，再重新遍历一遍去恢复"></a>1.显示中序遍历，写一个List放值，找到对应的节点，再重新遍历一遍去恢复</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    inorder(root);<br>    <span class="hljs-type">int</span>[] tmp = getSwapIndex();<br>    recover(root,<span class="hljs-number">2</span>,tmp[<span class="hljs-number">0</span>],tmp[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    inorder(node.left);<br>    list.add(node.val);<br>    inorder(node.right);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getSwapIndex()&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.size();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>,index2 = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span> (list.get(i) &gt; list.get(i + <span class="hljs-number">1</span>))&#123;<br>            index2 = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (index1 == -<span class="hljs-number">1</span>)&#123;<br>                index1 = i;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;list.get(index1),list.get(index2)&#125;;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recover</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> count, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;  <span class="hljs-comment">//之所以重新中序遍历一遍，是由于存储交换信息的是数值而不是节点</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (node.val == x || node.val == y)&#123;<br>        node.val = node.val == x ? y : x;<br>        <span class="hljs-keyword">if</span> (--count == <span class="hljs-number">0</span>)&#123;                      <span class="hljs-comment">//先减了，提前检查</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    recover(node.left,count,x,y);              <span class="hljs-comment">//再用，没到0的情况</span><br>    recover(node.right,count,x,y);<br></code></pre></td></tr></table></figure><h3 id="2-隐式中序遍历，迭代写法。维护一个栈"><a href="#2-隐式中序遍历，迭代写法。维护一个栈" class="headerlink" title="2.隐式中序遍历，迭代写法。维护一个栈"></a>2.隐式中序遍历，迭代写法。维护一个栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverTree2</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>,t1 = <span class="hljs-literal">null</span>,t2 = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty() || root != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>)&#123;<br>            stack.push(root);<br>            root = root.left;<br>        &#125;<br><br>        root = stack.pop();<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt; pre.val)&#123;        <span class="hljs-comment">//会出现3，2，1如此连续大于的情况，pre不更新，root一直要更新；所以作为break条件的t1放pre。</span><br>            t2 = root;<br>            <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span>)&#123;<br>                t1 = pre;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pre = root;<br>        root = root.right;<br>    &#125;<br><br>    swap(t1,t2);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(TreeNode x,TreeNode y)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> y.val;<br>    y.val = x.val;<br>    x.val = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-隐式中序遍历，递归写法。记录的是需交换的两个节点，浅拷贝所以可以直接change"><a href="#3-隐式中序遍历，递归写法。记录的是需交换的两个节点，浅拷贝所以可以直接change" class="headerlink" title="3.隐式中序遍历，递归写法。记录的是需交换的两个节点，浅拷贝所以可以直接change"></a>3.隐式中序遍历，递归写法。记录的是需交换的两个节点，浅拷贝所以可以直接change</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeNode t1,t2,pre;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    dfs(root);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> t2.val;<br>    t2.val = t1.val;<br>    t1.val = tmp;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    dfs(node.left);<br>    <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.val &gt; node.val)&#123;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span>) t1 = pre;<br>        t2 = node;<br>    &#125;<br>    pre = node;<br>    dfs(node.right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-morris中序遍历，空间复杂度O-1"><a href="#4-morris中序遍历，空间复杂度O-1" class="headerlink" title="4.morris中序遍历，空间复杂度O(1)"></a>4.morris中序遍历，空间复杂度O(1)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>,t2 = <span class="hljs-literal">null</span>,pre = <span class="hljs-literal">null</span>,predecessor = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>)&#123;   <span class="hljs-comment">//若root左子树非空，则去寻找其左子树的最右节点</span><br>            predecessor = root.left;<br>            <span class="hljs-keyword">while</span> (predecessor.right != <span class="hljs-literal">null</span> &amp;&amp; predecessor.right != root)&#123;<br>                predecessor = predecessor.right;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (predecessor.right == <span class="hljs-literal">null</span>)&#123;<br>                predecessor.right = root;     <span class="hljs-comment">//建立连接，继续遍历左子树</span><br>                root = root.left;<br>            &#125;<span class="hljs-keyword">else</span> &#123;                           <span class="hljs-comment">//左子树遍历完了，进行比较，断开连接，继续遍历右子树</span><br>                <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.val &gt; root.val)&#123;<br>                    t2 = root;<br>                    <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span>)&#123;<br>                        t1 = pre;<br>                    &#125;<br>                &#125;<br>                pre = root;<br><br>                predecessor.right = <span class="hljs-literal">null</span>;<br>                root = root.right;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;                  <span class="hljs-comment">//root左子树为空，直接遍历右子树</span><br>            <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.val &gt; root.val)&#123;<br>                t2 = root;<br>                <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span>)&#123;<br>                    t1 = pre;<br>                &#125;              <span class="hljs-comment">//没有else break;也是因为这里为了省去stack的空间，无法预知下一个节点在哪，就需要一直遍历</span><br>            &#125;<br>            pre = root;<br>            root = root.right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">assert</span> t1 != <span class="hljs-literal">null</span>;<br>    swap(t1,t2);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>互相实现</title>
    <link href="/earsh9.github.io/2022/08/04/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/1.%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/"/>
    <url>/earsh9.github.io/2022/08/04/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/1.%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="232题-用栈实现队列"><a href="#232题-用栈实现队列" class="headerlink" title="232题 用栈实现队列"></a>232题 用栈实现队列</h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false</p><p><strong>思路：</strong></p><ol><li>两个栈，一个负责输入一个负责输出；当要输出时颠倒顺序以符合队列的先进先出</li><li>pop()和peek()的实现很类似，将公共部分提取出来比大量的重复更清爽</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;<br>    Stack&lt;Integer&gt; s1;<br>    Stack&lt;Integer&gt; s2;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span>()</span> &#123;<br>        s1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();            <span class="hljs-comment">//负责输入</span><br>        s2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();            <span class="hljs-comment">//负责输出</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br>        s1.push(x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>()</span> &#123;<br>        dumpyStack1();<br>        <span class="hljs-keyword">return</span> s2.pop();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">peek</span>()</span> &#123;<br>        dumpyStack1();<br>        <span class="hljs-keyword">return</span> s2.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dumpyStack1</span>()</span>&#123;          <span class="hljs-comment">//dumpy就是转存的意思</span><br>        <span class="hljs-keyword">if</span> (s2.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span> (!s1.isEmpty())&#123;<br>                s2.push(s1.pop());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>可以定义front变量以简化peek()：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;<br>    Stack&lt;Integer&gt; s1;<br>    Stack&lt;Integer&gt; s2;<br>    <span class="hljs-built_in">int</span> front;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span>()</span> &#123;<br>        s1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();            <span class="hljs-comment">//负责输入</span><br>        s2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();            <span class="hljs-comment">//负责输出</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;         <span class="hljs-comment">//时间复杂度o(1),空间复杂度o(n):栈一直在内存中来存储队列的元素</span><br>        <span class="hljs-keyword">if</span> (s1.isEmpty()) front = x;         <span class="hljs-comment">//标记队首元素</span><br>        s1.push(x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>()</span> &#123;               <span class="hljs-comment">//空间复杂度o(1),时间复杂度摊还:o(1),最坏情况下o(n)</span><br>        <span class="hljs-keyword">if</span> (s2.isEmpty())&#123;                   <span class="hljs-comment">//转存(颠倒)s1以弹出真正的队首</span><br>            <span class="hljs-keyword">while</span> (!s1.isEmpty())&#123;<br>                s2.push(s1.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s2.pop();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">peek</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(!s2.isEmpty())<br>            <span class="hljs-keyword">return</span> s2.peek();<br><br>        <span class="hljs-keyword">return</span> front;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="225题-用队列实现栈"><a href="#225题-用队列实现栈" class="headerlink" title="225题 用队列实现栈"></a>225题 用队列实现栈</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p><p><strong>思考：</strong></p><ol><li>对于队列而言，出队再入队一次并不能颠倒顺序；只能每加一个值再让原先值重新入队一次。</li><li>不想多次交换的话，改成赋值也行：一个队列始终在push前保持为空，另一个每次都重新入队。<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> </span>&#123;<br>    Queue&lt;Integer&gt; q1;<br>    Queue&lt;Integer&gt; q2;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;<br>        q1 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();     <span class="hljs-comment">//存储栈内元素</span><br>        q2 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();     <span class="hljs-comment">//辅助</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        q2.offer(x);<br>        <span class="hljs-keyword">while</span> (!q1.isEmpty())&#123;<br>            q2.offer(q1.poll());<br>        &#125;<br>        <span class="hljs-comment">//可以交换q1和q2，使得每次q2在push之前始终为空队列</span><br>        Queue&lt;Integer&gt; tmp = q2;<br>        q2 = q1;<br>        q1 = tmp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> q1.<span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> q1.<span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> q1.<span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>用一个队列也行：q2.offer(x)后，将x前的元素重新出队并添加到队尾。</strong></li><li>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>匹配与去重问题</title>
    <link href="/earsh9.github.io/2022/08/04/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/2.%E5%8C%B9%E9%85%8D%E5%92%8C%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98/"/>
    <url>/earsh9.github.io/2022/08/04/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/2.%E5%8C%B9%E9%85%8D%E5%92%8C%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>括号匹配是使用栈解决的经典问题。</strong></p><h2 id="20题-有效的括号"><a href="#20题-有效的括号" class="headerlink" title="20题 有效的括号"></a>20题 有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ul><p>示例 1:<br>输入: “()”<br>输出: true</p><p>示例 2:<br>输入: “()[]{}”<br>输出: true</p><p>示例 3:<br>输入: “(]”<br>输出: false</p><p>示例 4:<br>输入: “([)]”<br>输出: false</p><p>示例 5:<br>输入: “{[]}”<br>输出: true</p><p>先分析有几种不匹配的情况：</p><ol><li>字符串里左方向的括号多余了，所以不匹配。例如：([]{}()</li><li>括号没有多余，但是括号的类型没有匹配上。例如：[({})}</li><li>字符串里右方向的括号多余了，所以不匹配。例如：({})[])))</li></ol><p><em><strong>思想：</strong></em></p><ol><li>符合要求的表达式的子表达式也是符合要求的</li><li>当遇到一对匹配的括号时，就将其从表达式中删除，继而缩短表达式长度</li><li>但我们无法从内到外的处理这个问题，因为无法预知整体结构。但是堆栈可以从外部到内部递归地处理这个问题。</li><li>小技巧：碰到左侧的括号时进栈的是对应的右侧括号，比官解种的创建Map来记录左右括号的对应关系要快一些；但元素多时写if会麻烦。</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.<span class="hljs-built_in">toCharArray</span>())&#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">isEmpty</span>() || stack.<span class="hljs-built_in">peek</span>() != c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">//右括号多了或者出现左右括号不匹配的情况</span><br>        <span class="hljs-keyword">else</span> stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">isEmpty</span>();       <span class="hljs-comment">//遍历完字符串后若为空即匹配,不为空即左括号多了</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1047题-删除字符串中的所有相邻重复项"><a href="#1047题-删除字符串中的所有相邻重复项" class="headerlink" title="1047题 删除字符串中的所有相邻重复项"></a>1047题 删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><p>输入：”abbaca”<br>输出：”ca”<br>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p><p><strong>思路：</strong></p><ul><li>第一反应是创建一个Stack来模拟插入和删除</li><li>StringBuilder自带入栈和删除操作，无需单独创建Stack</li><li>还可以原地修改</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public String remove<span class="hljs-constructor">Duplicates0(String <span class="hljs-params">s</span>)</span> &#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">char</span> c : s.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!stack.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> &amp;&amp; </span>c<span class="hljs-operator"> == </span>stack.peek<span class="hljs-literal">()</span>) stack.pop<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">else</span> stack.push(c);<br>    &#125;<br><br>    StringBuilder res = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>    <span class="hljs-keyword">while</span>(!stack.is<span class="hljs-constructor">Empty()</span>)&#123;<br>        res.append(stack.pop<span class="hljs-literal">()</span>);<br>    &#125;<br>    return res.reverse<span class="hljs-literal">()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>&#125;<br><br><span class="hljs-comment">//StringBuilder自带入栈和删除操作，无需单独创建Stack</span><br>public String remove<span class="hljs-constructor">Duplicates1(String <span class="hljs-params">s</span>)</span> &#123;<br>    StringBuilder stack = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>    <span class="hljs-built_in">int</span> top = -<span class="hljs-number">1</span>;                                   <span class="hljs-comment">//用top来标记StringBuilder最后一位的索引值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">char</span> c : s.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>)&#123;<br>        <span class="hljs-keyword">if</span> (top &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>stack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">top</span>)</span><span class="hljs-operator"> == </span>c)&#123;<br>            stack.delete<span class="hljs-constructor">CharAt(<span class="hljs-params">top</span>)</span>;<br>            top--;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            stack.append(c);<br>            top++;<br>        &#125;<br>    &#125;<br>    return stack.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>&#125;<br><br><span class="hljs-comment">//还可以原地修改</span><br>public String remove<span class="hljs-constructor">Duplicates(String <span class="hljs-params">s</span>)</span> &#123;<br>    <span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> chars = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br>    <span class="hljs-built_in">int</span> top = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length<span class="hljs-literal">()</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span> (top &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>chars<span class="hljs-literal">[<span class="hljs-identifier">top</span>]</span><span class="hljs-operator"> == </span>chars<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>            top--;                                <span class="hljs-comment">//delete</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            top++;<br>            chars<span class="hljs-literal">[<span class="hljs-identifier">top</span>]</span> = chars<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;               <span class="hljs-comment">//append</span><br>        &#125;<br>    &#125;<br><br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">chars</span>,0,<span class="hljs-params">top</span>+1)</span>;    <span class="hljs-comment">//valueOf(char[] data, int offset, int count)</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="150题-逆波兰表达式"><a href="#150题-逆波兰表达式" class="headerlink" title="150题 逆波兰表达式"></a>150题 逆波兰表达式</h2><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]</p><p>输出：6</p><p>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</p><ol><li>用栈很好实现</li><li>数组也行，对对碰，巧妙。</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//或者自己写一个isNumber也行</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> !(s.<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;+&quot;</span>) || s.<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;-&quot;</span>) || s.<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;*&quot;</span>) || s.<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;/&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(<span class="hljs-type">String</span>[] tokens)</span> </span>&#123;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> s : tokens) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNumber</span>(s))&#123;<br>            stack.<span class="hljs-built_in">push</span>(Integer.<span class="hljs-built_in">parseInt</span>(s));<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> b = stack.<span class="hljs-built_in">pop</span>(),a = stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">switch</span> (s)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span> :<br>                    stack.<span class="hljs-built_in">push</span>(a + b);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span> :<br>                    stack.<span class="hljs-built_in">push</span>(a - b);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span> :<br>                    stack.<span class="hljs-built_in">push</span>(a * b);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span> :<br>                    stack.<span class="hljs-built_in">push</span>(a / b);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>对于一个有效的逆波兰表达式，其长度 n 一定是奇数，且操作数的个数一定比运算符的个数多 1 个，即包含 (n+1)&#x2F;2个操作数和 (n-1)&#x2F;2个运算符。</li><li>考虑遇到操作数和运算符时，栈内元素个数分别会如何变化：<ul><li>如果遇到操作数，则将操作数入栈，因此栈内元素增加 1 个；</li><li>如果遇到运算符，则将两个操作数出栈，然后将一个新操作数入栈，因此栈内元素先减少 2 个再增加 1 个，结果是栈内元素减少 1 个。</li></ul></li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(<span class="hljs-type">String</span>[] tokens)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = tokens.length;<br>    <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[(n+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> token : tokens) &#123;<br>        <span class="hljs-keyword">switch</span> (token)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                i--;<br>                nums[i] += nums[i + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                i--;<br>                nums[i] -= nums[i + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                i--;<br>                nums[i] *= nums[i + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                i--;<br>                nums[i] /= nums[i + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                i++;<br>                nums[i] = Integer.<span class="hljs-built_in">parseInt</span>(token);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前k个高频元素</title>
    <link href="/earsh9.github.io/2022/08/04/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/4.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <url>/earsh9.github.io/2022/08/04/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/4.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="347题-前k个高频元素"><a href="#347题-前k个高频元素" class="headerlink" title="347题 前k个高频元素"></a>347题 前k个高频元素</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</p><p>输出: [1,2]</p><p>示例 2:</p><p>输入: nums &#x3D; [1], k &#x3D; 1</p><p>输出: [1]</p><p>提示：</p><p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</p><p>你的算法的时间复杂度必须<strong>优于O(nlogn)</strong>, n 是数组的大小。</p><p>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</p><p>你可以按任意顺序返回答案。</p><p><strong>思考：</strong></p><ol><li>快速排序时间复杂度即是o(nlogn)，如何比它还少？</li><li>可以用哈希表记录每个元素出现的频率，如何只取前k个高频的？</li></ol><h3 id="优先级队列（大根堆、小根堆）"><a href="#优先级队列（大根堆、小根堆）" class="headerlink" title="优先级队列（大根堆、小根堆）"></a>优先级队列（大根堆、小根堆）</h3><ol><li>它是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</li><li>堆是一颗完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</li><li><strong>如何对出现频率进行排序？</strong><ul><li>求前k个高频元素，若用大根堆，不断弹出最大值，那如何记录前k个呢？</li><li>那就用小根堆，每次先把最小的淘汰了</li></ul></li><li>此时时间复杂度o(nlogk)，n为数组大小，k为不重复元素的个数。严格来讲k在最坏的情况下时间复杂度仍是o(nlogn)。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        map.put(num, map.getOrDefault(num,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];                     <span class="hljs-comment">//递增序列，数组0放数值，1放次数</span><br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>        <span class="hljs-keyword">if</span> (pq.size() == k)&#123;            <span class="hljs-comment">//只有当pq.size要 &gt; k时才考虑弹出的问题</span><br><br>        <span class="hljs-comment">//如果当前值比小根堆的堆顶值还要小，就没有再加入的必要了</span><br><br>            <span class="hljs-keyword">if</span> (count &gt; pq.peek()[<span class="hljs-number">1</span>])&#123;<br>                pq.poll();<br>                pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>        res[i] = pq.poll()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于快速排序的思想"><a href="#基于快速排序的思想" class="headerlink" title="基于快速排序的思想"></a>基于快速排序的思想</h3><ol><li>普通的快排是o(nlogn)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        map.put(num, map.getOrDefault(num,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>    &#125;<br><br>    qSort(<span class="hljs-number">0</span>, list.size() - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,i = list.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>)&#123;<br>        res[idx++] = list.get(i--)[<span class="hljs-number">0</span>];<br>        k--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">qSort</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start,j = end;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> list.get(start)[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; list.get(j)[<span class="hljs-number">1</span>] &gt;= key)&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>            Collections.swap(list,i,j);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; list.get(i)[<span class="hljs-number">1</span>] &lt;= key)&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>            Collections.swap(list,j,i);<br>        &#125;<br>    &#125;<br>    qSort(start,i-<span class="hljs-number">1</span>);<br>    qSort(i+<span class="hljs-number">1</span>,end);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>但本题是只取前k大个，可以基于快排修改一下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey(), count = entry.getValue();<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, count&#125;);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        qSortEdit(<span class="hljs-number">0</span>,list.size()-<span class="hljs-number">1</span>,k,<span class="hljs-number">0</span>,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">qSortEdit</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> ed, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> resIdx, <span class="hljs-type">int</span>[] res)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">picked</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * (ed - st + <span class="hljs-number">1</span>)) + st;        <span class="hljs-comment">//随机选定索引</span><br>        Collections.swap(list,picked,st);                              <span class="hljs-comment">//交换，放在start的位置</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> list.get(st)[<span class="hljs-number">1</span>];                                  <span class="hljs-comment">//对应的值为基准值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> st;                                                 <span class="hljs-comment">//记录最后一个大于pivot的索引</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st + <span class="hljs-number">1</span>; i &lt;= ed; i++)&#123;<br>            <span class="hljs-keyword">if</span> (list.get(i)[<span class="hljs-number">1</span>] &gt; pivot)&#123;<br>                Collections.swap(list,idx + <span class="hljs-number">1</span>,i);<br>                idx++;<br>            &#125;<br>        &#125;<br>        Collections.swap(list,st,idx);                               <span class="hljs-comment">//此时pivot前的数值全比它大</span><br><br>        <span class="hljs-keyword">if</span> (idx - st &gt;= k)&#123;                                          <span class="hljs-comment">//说明基准值选的过小，不足以挑出前k大个</span><br>            qSortEdit(st,idx-<span class="hljs-number">1</span>,k,resIdx,res);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> st; i &lt;= idx; i++)&#123;<br>                res[resIdx++] = list.get(i)[<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(k &gt; idx - st + <span class="hljs-number">1</span>)&#123;                           <span class="hljs-comment">//此处必须要有判断，否则没有结束的标识</span><br>                qSortEdit(idx+<span class="hljs-number">1</span>,ed,k - (idx - st + <span class="hljs-number">1</span>),resIdx,res);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/earsh9.github.io/2022/08/04/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/5.%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/earsh9.github.io/2022/08/04/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/5.%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈适用情况"><a href="#单调栈适用情况" class="headerlink" title="单调栈适用情况"></a>单调栈适用情况</h1><p>一维数组，寻找任意元素左(右)边第一个比自己大(小)的元素位置时使用</p><p>虽然单调栈是 for + while 的结构，但细看<strong>每个元素仅进栈一次出栈一次，时间复杂度为 O(n)</strong></p><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>示例 1:</p><p>输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]</p><p>输出: [1,1,4,2,1,1,0,0]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ans[i]：对于任意元素 nums[i]，记算在 i 之前第一个比 nums[i] 小的元素下标 j，存储 i - j 的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures1(<span class="hljs-type">int</span>[] temperatures) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; temperatures[stk.peek()] &lt;= temperatures[i])&#123;<br>            stk.pop();<br>        &#125;<br>        ans[i] = stk.isEmpty() ? <span class="hljs-number">0</span> : stk.peek() - i;<br>        stk.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//也可以正向遍历，找第一个大于当前栈顶元素的下标</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    stk.push(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (temperatures[i] &lt;= temperatures[stk.peek()])&#123;   <span class="hljs-comment">//可以省略，为了能清楚才写出来的</span><br>            stk.push(i);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stk.peek()])&#123;<br>                ans[stk.peek()] = i - stk.peek();<br>                stk.pop();<br>            &#125;<br>            stk.push(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的：</p><ul><li>496.下一个更大元素 I</li><li>503.下一个更大元素 II<ul><li>循环数组 -&gt; 数组扩张一倍 -&gt; 不新建数组扩张 -&gt; 仅在索引值上 i &lt; n + 2、i % n 修改和取余防止超限</li></ul></li></ul><h2 id="42-接雨水（四种解法！）"><a href="#42-接雨水（四种解法！）" class="headerlink" title="42. 接雨水（四种解法！）"></a>42. 接雨水（四种解法！）</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例 1：</p><img src = "https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png"><p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</p><p>输出：6</p><p>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><h3 id="暴力-gt-动态规划"><a href="#暴力-gt-动态规划" class="headerlink" title="暴力 -&gt; 动态规划"></a>暴力 -&gt; 动态规划</h3><ul><li>按每根柱子所能接到的最大雨量来算（宽度为1）-&gt; 寻找每根柱子左右两边高度最大值中的较小者 - 柱子本身的高度</li><li>dp 就是在暴力的基础上优化，记录之前遍历到的结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//暴力：对于每一个柱子，寻找其左右柱子的高度最大值！</span><br><span class="hljs-comment">//根据木桶原理左右高度取小再减去当前柱子本身的高度即为能接的雨水量（按列遍历时宽度为 1）</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap0</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = height.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;   <span class="hljs-comment">//两端为边界，不接雨水</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rHeight = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>            lHeight = Math.max(lHeight, height[j]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++)&#123;<br>            rHeight = Math.max(rHeight, height[j]);<br>        &#125;<br><br>        ans += Math.min(lHeight,rHeight) - height[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>    <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-type">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>    left[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        left[i] = Math.max(left[i - <span class="hljs-number">1</span>], height[i]);<br>    &#125;<br><br>    right[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        right[i] = Math.max(right[i + <span class="hljs-number">1</span>], height[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> Math.min(left[i + <span class="hljs-number">1</span>], right[i]);      <span class="hljs-comment">//木桶原理</span><br>        ans += Math.max(<span class="hljs-number">0</span>, level - height[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态规划-gt-双指针"><a href="#动态规划-gt-双指针" class="headerlink" title="动态规划 -&gt; 双指针"></a>动态规划 -&gt; 双指针</h3><ul><li>不像 dp 分别从左和右各遍历一次，想办法遍历一次。</li><li>注意到左右边界在高度实际计算时取决于小的那一边，根据 left_max 和 right_max 的大小决定遍历方向</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left_max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right_max = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>        <span class="hljs-keyword">if</span> (height[left] &lt; height[right])&#123;        <span class="hljs-comment">//从左往右遍历</span><br>            <span class="hljs-keyword">if</span> (height[left] &gt;= left_max) left_max = height[left];<br>            <span class="hljs-keyword">else</span> ans += (left_max - height[left]);<span class="hljs-comment">//一旦 height[left] 小于 left_max，说明找见短板左边界可以直接可以加入 answer</span><br>            left++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;                                    <span class="hljs-comment">//从右往左遍历</span><br>            <span class="hljs-keyword">if</span> (height[right] &gt;= right_max) right_max = height[right];<br>            <span class="hljs-keyword">else</span> ans += (right_max - height[right]);<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><ul><li>用栈来跟踪可能储水的最长的条形块<ul><li>如果当前条形块 ≤ 栈顶元素，直接入栈说明当前的条形块被栈中的前一个条形块界定；</li><li>若 大于 栈顶元素，说明栈顶元素的两端边界均找见 -&gt; 计算面积</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>    Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span> (cur &lt; height.length)&#123;<br>        <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; height[cur] &gt; height[stk.peek()])&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stk.pop();<br>            <span class="hljs-keyword">if</span> (stk.isEmpty()) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Math.min(height[stk.peek()], height[cur]) - height[top], w = cur - stk.peek() - <span class="hljs-number">1</span>; <span class="hljs-comment">//不加边界只算中间部分</span><br>            ans += w * h;<br>        &#125;<br>        stk.push(cur++);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形（接雨水的互补题）"><a href="#84-柱状图中最大的矩形（接雨水的互补题）" class="headerlink" title="84. 柱状图中最大的矩形（接雨水的互补题）"></a>84. 柱状图中最大的矩形（接雨水的互补题）</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><img src = "https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"><p>示例 1:</p><p>输入：heights &#x3D; [2,1,5,6,2,3]</p><p>输出：10</p><p>解释：最大的矩形为图中红色区域，面积为 10</p><h3 id="法1：从怎么能计算出最大面积想起"><a href="#法1：从怎么能计算出最大面积想起" class="headerlink" title="法1：从怎么能计算出最大面积想起"></a>法1：从怎么能计算出最大面积想起</h3><ul><li><p>若柱子高度在递增说明最大面积在增加；若出现第一个减小的值，说明以当前高度作为矩形高的最大面积已经确定</p><ul><li><p>使用当前高度去计算完矩形面积后，该高度就不被需要了（弹出）</p></li><li><p>例(5,6,7,3)，碰到 3 以后先计算以 7 作为高度的矩形面积即 7 × 1，由于 6 &gt; 3，再计算以 6 作为高度的矩形面积即 6 × 2…</p></li><li><p>存储的应该是索引值，以方便作差求矩形的宽</p></li></ul></li><li><p>矩形的宽：左右边界索引值作差，高：height数组的当前元素</p></li><li><p>不能解决数组为连续递增的情况，解决方法：在数组首尾各添加一个 0</p><ul><li>首部的 0 保证栈不为空，尾部的 0 保证所有元素都能被弹出。例(0,5,6,7,0)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br><span class="hljs-comment">//arraycopy()：source arr, st pos in source arr, destination arr, st pos in destination arr, num of elements to be copied</span><br>    System.arraycopy(heights, <span class="hljs-number">0</span>, arr, <span class="hljs-number">1</span>, n);<br>    Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++)&#123;<br>        <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; arr[i] &lt; arr[stk.peek()])&#123;  <span class="hljs-comment">//arr[i] 为栈顶元素的 右边界</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> arr[stk.pop()];<br>            ans = Math.max(ans, h * (i - stk.peek() - <span class="hljs-number">1</span>));   <span class="hljs-comment">//此时的 stk.peek() 为被弹出栈顶元素的 左边界，且左右边界均取不到</span><br>        &#125;<br>        stk.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="法2：对于数组中任意元素-height-i-寻找其左右两边第一个比它小的元素下标-由此计算面积"><a href="#法2：对于数组中任意元素-height-i-寻找其左右两边第一个比它小的元素下标-由此计算面积" class="headerlink" title="法2：对于数组中任意元素 height[i], 寻找其左右两边第一个比它小的元素下标, 由此计算面积"></a>法2：对于数组中任意元素 height[i], 寻找其左右两边第一个比它小的元素下标, 由此计算面积</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> heights.length;<br>    <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    <span class="hljs-type">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//由于边界为双开，栈为空时分别设为 -1，len</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; heights[i] &lt;= heights[stk.peek()]) &#123;  <span class="hljs-comment">//(5,5,5,3)</span><br>            stk.pop();<br>        &#125;<br>        left[i] = stk.isEmpty() ? -<span class="hljs-number">1</span> : stk.peek();<br>        stk.push(i);<br>    &#125;<br><br>    stk.clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; heights[i] &lt;= heights[stk.peek()]) &#123;<br>            stk.pop();<br>        &#125;<br>        right[i] = stk.isEmpty() ? len : stk.peek();<br>        stk.push(i);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        ans = Math.max(ans, heights[i] * (right[i] - left[i] - <span class="hljs-number">1</span>));      <span class="hljs-comment">//两边的都取不到</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优化：对于 left 和 right 数组不用正向反向各遍历一次，仅需一次遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.fill(right, len);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>    <span class="hljs-keyword">while</span>(!stk.isEmpty() &amp;&amp; height[i] &lt;= height[stk.peek()])&#123;  <span class="hljs-comment">//带不带等号都行</span><br>        right[stk.peek()] = i;<br>        stk.pop();<br>    &#125;<br>    left[i] = stk.isEmpty() ? -<span class="hljs-number">1</span> : stk.peek();<br>    stk.push(i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="456-132-模式"><a href="#456-132-模式" class="headerlink" title="456. 132 模式"></a>456. 132 模式</h2><p>给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。</p><p>如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。</p><p>示例 3：</p><p>输入：nums &#x3D; [-1,3,2,0]</p><p>输出：true</p><p>解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 10^5</p><p>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</p><h3 id="想清楚枚举哪一个及对应的逻辑（枚举-i-最简单）"><a href="#想清楚枚举哪一个及对应的逻辑（枚举-i-最简单）" class="headerlink" title="想清楚枚举哪一个及对应的逻辑（枚举 i 最简单）"></a>想清楚枚举哪一个及对应的逻辑（枚举 i 最简单）</h3><ol><li><p>枚举i：i 是132结构中最小的数，即需要在 i 之后找到一组数对 (j,k)，使得 j, k 都比 i 大且 j &gt; k</p><ul><li><p>反向遍历，栈中维护最大的 j，被弹出的数 k 在既在索引上满足 j &lt; k，又在数值上满足 j &gt; k。</p></li><li><p>维护一个 max_k，当 nums[i] &lt; max_k 时，132结构找见了。</p></li></ul></li><li><p>枚举j：j 是132结构中最大的数，即需要在 j 之后找比 j 小的「最大」的数，又要找在 j 之前比 j 小的「最小」的数的数</p><ul><li>朴素单调栈只能维护左边或者右边「最近」的数，无法满足「最大」「最小」的需求，需另加逻辑。</li></ul></li><li><p>枚举k：k 是132结构中中间的数，与枚举 i 类似</p><ul><li>需要找到 k 左边的 i，同时确保 [i,k] 之间存在比 i 和 k 大的数字。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//枚举 i</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find132pattern</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxK</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; maxK) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; nums[i] &gt; nums[stk.peek()])&#123;<br>            maxK = nums[stk.pop()];            <span class="hljs-comment">//maxK 具有单调性，无需 math.max()</span><br>        &#125;<br>        stk.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的：</p><ul><li>1673.找出最具竞争力的子序列</li><li>402.移掉 K 位数字 （多了一个处理前导0的操作而已）</li></ul><h2 id="2104-子数组范围和"><a href="#2104-子数组范围和" class="headerlink" title="2104. 子数组范围和"></a>2104. 子数组范围和</h2><p>给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。</p><p>返回 nums 中 所有 子数组范围的 和 。</p><p>子数组是数组中一个连续 非空 的元素序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]</p><p>输出：4</p><p>解释：nums 的 6 个子数组如下所示：</p><p>[1]，范围 &#x3D; 最大 - 最小 &#x3D; 1 - 1 &#x3D; 0</p><p>[2]，范围 &#x3D; 2 - 2 &#x3D; 0</p><p>[3]，范围 &#x3D; 3 - 3 &#x3D; 0</p><p>[1,2]，范围 &#x3D; 2 - 1 &#x3D; 1</p><p>[2,3]，范围 &#x3D; 3 - 2 &#x3D; 1</p><p>[1,2,3]，范围 &#x3D; 3 - 1 &#x3D; 2</p><p>所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 &#x3D; 4</p><ol><li><p>暴力。枚举每个子数组的过程中用 min,max 两个变量维护最大值和最小值。O(n ^ 2)</p></li><li><p>单调栈</p><ul><li><p>根据范围和的定义，所有数组范围和 sum 等于 所有子数组最大值之和 与 所有子数组最小值之和 作差。</p></li><li><p>对于数组任意元素 nums[i], 记录在 i 之前第一个比 nums[i] 小的数的下标 j，在 i 之后第一个比 nums[i] 小的数的下标 k</p><ul><li>则在区间 (j,k) 中最小值为 nums[i]</li><li>在计算所有子数组最小值之和中贡献了 (i - j) * (k - i) 个 nums[i] 这一最小值</li></ul></li><li><p>同理，求出 nums[i] 在哪些区间内是作为最大值存储的，继而求得 sumMax - sumMin</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">subArrayRanges</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    n = nums.length;<br>    <span class="hljs-type">long</span>[] min = getCnt(nums, <span class="hljs-literal">true</span>), max = getCnt(nums, <span class="hljs-literal">false</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) ans += (max[i] - min[i]) * nums[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span>[] getCnt(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span> isMin)&#123;<br>    Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];      <span class="hljs-comment">//求解 nums[i] 左边第一个比其小(大)的数的下标、右边第一个比其小(大)的数的下标</span><br>    <span class="hljs-type">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>    <span class="hljs-comment">//为了避免重复计算，left 和 right 处有一个地方加等号就行，左闭右开</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; (isMin ? nums[stk.peekLast()] &gt;= nums[i] : nums[stk.peekLast()] &lt;= nums[i]))&#123;<br>            stk.pollLast();<br>        &#125;<br>        left[i] = stk.isEmpty() ? -<span class="hljs-number">1</span> : stk.peekLast();<br>        stk.offerLast(i);<br>    &#125;<br>    stk.clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n -<span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; (isMin ? nums[stk.peekLast()] &gt; nums[i] : nums[stk.peekLast()] &lt; nums[i]))&#123;<br>            stk.pollLast();<br>        &#125;<br>        right[i] = stk.isEmpty() ? n : stk.peekLast();<br>        stk.offerLast(i);<br>    &#125;<br>    <span class="hljs-type">long</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) res[i] = (<span class="hljs-type">long</span>) (i - left[i]) * (right[i] - i);    <span class="hljs-comment">//求解 nums[i] 在计算范围和中 贡献的最大(小)值次数</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口最大值问题</title>
    <link href="/earsh9.github.io/2022/08/04/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/3.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <url>/earsh9.github.io/2022/08/04/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/3.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>滑动窗口的最大值是使用单调队列的经典题目</strong></p><p>单调队列随应用场景不同有不同写法，只是要保证单调递减或递增的原则。</p><p>与优先队列（大根堆）不同。</p><h2 id="239题-滑动窗口最大值"><a href="#239题-滑动窗口最大值" class="headerlink" title="239题 滑动窗口最大值"></a>239题 滑动窗口最大值</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</p><p>输出：[3,3,5,5,6,7]</p><p>解释：</p><p>滑动窗口的位置                 <em><strong>最大值</strong></em></p><p>[1  3  -1] -3  5  3  6  7       <em><strong>3</strong></em></p><p> 1 [3  -1  -3] 5  3  6  7       <em><strong>3</strong></em></p><p> 1  3 [-1  -3  5] 3  6  7       <em><strong>5</strong></em></p><p> 1  3  -1 [-3  5  3] 6  7       <em><strong>5</strong></em></p><p> 1  3  -1  -3 [5  3  6] 7       <em><strong>6</strong></em></p><p> 1  3  -1  -3  5 [3  6  7]      <em><strong>7</strong></em></p><h3 id="1-先从暴力开始想起：o-n-2"><a href="#1-先从暴力开始想起：o-n-2" class="headerlink" title="1. 先从暴力开始想起：o(n^2)"></a>1. 先从暴力开始想起：o(n^2)</h3><p>对于每个滑动窗口，我们可以使用 O(k) 的时间遍历其中的每一个元素，找出其中的最大值。对于长度为 n 的数组 nums 而言，窗口的数量为 n−k+1，因此该算法的时间复杂度为 O((n-k+1)k)&#x3D;O(nk)，会超出时间限制，因此需要进行一些优化。</p><h3 id="2-再想到大根堆（优先队列）可以维护一系列元素的最大值：o-nlogn"><a href="#2-再想到大根堆（优先队列）可以维护一系列元素的最大值：o-nlogn" class="headerlink" title="2. 再想到大根堆（优先队列）可以维护一系列元素的最大值：o(nlogn)"></a>2. 再想到大根堆（优先队列）可以维护一系列元素的最大值：o(nlogn)</h3><ol><li>初始化先将数组前k个元素进队，随着窗口右移不断加入新元素</li><li>堆顶元素即为最大值，但最大值会随着窗口的滑动而不在窗口中，怎么判定什么时候删除？</li><li><strong>在队列中存储二元组（num,index），元素的值和下标一起记录。</strong></li><li>大根堆实际上就是一个树，实现树的时间复杂度为o(nlogn)：一棵树n个节点，共有logn层。放一个元素就需要o(logn)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;          <span class="hljs-comment">//实现递减, if a&gt;b return -1; if a&lt;b return 1; 和 return b-a 一样</span><br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] != o2[<span class="hljs-number">0</span>] ? o2[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">0</span>] : o2[<span class="hljs-number">1</span>] - o1[<span class="hljs-number">1</span>];    <span class="hljs-comment">//值不等返回较大者，相等返回索引值较大值</span><br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>        pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums[i], i&#125;);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>    res[<span class="hljs-number">0</span>] = pq.peek()[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; i++)&#123;<br>        pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums[i], i&#125;);<br>        <span class="hljs-keyword">while</span> (pq.peek()[<span class="hljs-number">1</span>] &lt;= i - k)&#123;<br>            pq.poll();<br>        &#125;<br>        res[i - k + <span class="hljs-number">1</span>] = pq.peek()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自己实现compare-方法"><a href="#自己实现compare-方法" class="headerlink" title="自己实现compare()方法"></a>自己实现compare()方法</h4><p>例如要对a和b进行排序，<strong>默认的是若返回值为负数a在前面，若为正数a在后面</strong>。</p><ol><li><p>若想实现成<strong>递增</strong>数列，即要实现：</p><ul><li>if(a &lt; b) return 负数</li><li>if(a &gt; b) return 正数</li><li>if(a &#x3D;&#x3D; b) return 0</li><li>三个if判断不如直接return a - b;</li></ul></li><li><p>如果想排成<strong>递减</strong>数列：</p><ul><li>return b - a;</li><li>返回的是负数说明要把a排在前面。与a &gt; b为递减数列相符。</li></ul></li></ol><h3 id="3-队列没有必要维护窗口中的所有元素，只维护可能成为窗口最大值的元素即可：o-n"><a href="#3-队列没有必要维护窗口中的所有元素，只维护可能成为窗口最大值的元素即可：o-n" class="headerlink" title="3. 队列没有必要维护窗口中的所有元素，只维护可能成为窗口最大值的元素即可：o(n)"></a>3. 队列没有必要维护窗口中的所有元素，只维护可能成为窗口最大值的元素即可：o(n)</h3><ol><li><p>对于窗口中的两个下标 i 和 j，若 i &lt; j 且nums[i] &lt;&#x3D; nums[j]，只要 i 在窗口中 j 一定在窗口中；且由于nums[j] 比 nums[i] 大，则nums[i] 并没有继续存在的必要。</p></li><li><p>可以<strong>维护一个单调递减的双端队列即「单调队列」</strong></p></li><li><p>不断将新元素与队尾元素进行比较，若新元素大则需弹出队尾，直到队列为空或新元素小于队尾。</p></li><li><p>该队列存储的是<strong>索引值</strong>，即队首索引值不在窗口内需弹出队首。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//method2:单调队列</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;                  <span class="hljs-comment">//初始化前K个</span><br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()])&#123;<br>            deque.pollLast();<br>        &#125;<br>        deque.offerLast(i);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>    res[<span class="hljs-number">0</span>] = nums[deque.peekFirst()];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()])&#123;<br>            deque.pollLast();<br>        &#125;<br><br>        deque.offerLast(i);<br><br>        <span class="hljs-keyword">while</span> (deque.peekFirst() &lt;= i - k)&#123;<br>            deque.pollFirst();<br>        &#125;<br>        res[i - k + <span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-分块-预处理-与稀疏表类似？"><a href="#4-分块-预处理-与稀疏表类似？" class="headerlink" title="4. 分块 + 预处理(与稀疏表类似？)"></a>4. 分块 + 预处理(与稀疏表类似？)</h3><ol><li><p>将元素每k个一分组，最后一组可能不足k个。</p></li><li><p>如果希望求出 nums[i] 到 nums[i+k−1] 的最大值，就会有两种情况：</p><ul><li><p>如果 i 是 k 的倍数，则 nums[i] 到 nums[i+k−1] 恰好是一个分组。只要预处理出每个分组中的最大值，即可得到答案；</p></li><li><p>如果 i 不是 k 的倍数，则 nums[i] 到 nums[i+k−1] 会跨越两个分组，占有第一个分组的后缀以及第二个分组的前缀。假设 j 是 k 的倍数，并且满足 i &lt; j ≤ i+k−1，则 nums[i] 到 nums[j−1] 就是第一个分组的后缀，nums[j] 到 nums[i+k−1] 就是第二个分组的前缀。如果能预处理出每个分组中的前缀最大值以及后缀最大值，同样可以在 O(1) 的时间得到答案。</p></li></ul></li><li><p>因此我们用 prefixMax[i] 表示下标 i 对应的分组中，以 i 结尾的前缀最大值；suffixMax[i] 表示下标 i 对应的分组中，以 i 开始的后缀最大值。它们分别满足如下的递推式</p></li></ol><p>$$ prefixMax[i]&#x3D;<br>\begin{cases}<br>\begin{array}{lcl}<br>  \ nums[i], &amp; &amp; i 是 k 的倍数 \<br>  \ max{ prefixMax[i-1], nums[i] },&amp; &amp; i 不是 k 的倍数 \<br>\end{array}<br>\end{cases}<br>$$</p><p>以及<br>$$ suffixMax[i] &#x3D;<br>\begin{cases}<br>\begin{array}{lcl}<br>  \textit{nums}[i], &amp; &amp;  i+1 是 k 的倍数\<br>  \max{ \textit{suffixMax}[i+1], \textit{nums}[i] }, &amp; &amp; i+1 不是 k 的倍数\<br>\end{array}<br>\end{cases}<br>$$</p><ol start="4"><li>需要注意在递推 $\textit{suffixMax}[i]$ 时需要考虑到边界条件 $\textit{suffixMax}[n-1]&#x3D;\textit{nums}[n-1]$，而在递推 $\textit{prefixMax}[i]$ 时的边界条件 $\textit{prefixMax}[0]&#x3D;\textit{nums}[0]$ 恰好包含在递推式的第一种情况中，因此无需特殊考虑。</li></ol><p>在预处理完成之后，对于 $\textit{nums}[i]$ 到 $\textit{nums}[i+k-1]$ 的所有元素，如果 i 不是 k 的倍数，那么窗口中的最大值为 $\textit{suffixMax}[i]$ 与 $\textit{prefixMax}[i+k-1]$ 中的较大值；如果 i 是 k 的倍数，那么此时窗口恰好对应一整个分组，$\textit{suffixMax}[i]$ 和 $\textit{prefixMax}[i+k-1]$ 都等于分组中的最大值，因此无论窗口属于哪一种情况，<br>$$ \max\big{ \textit{suffixMax}[i], \textit{prefixMax}[i+k-1] \big} $$<br>即为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] prefixMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];               <span class="hljs-comment">//以i结尾的前缀最大值</span><br>    <span class="hljs-type">int</span>[] suffixMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];               <span class="hljs-comment">//以i开始的后缀最大值</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i % k == <span class="hljs-number">0</span>) prefixMax[i] = nums[i];                            <span class="hljs-comment">//每K个中以第一个元素结尾的前缀最大值就是它自己</span><br>        <span class="hljs-keyword">else</span> prefixMax[i] = Math.max(prefixMax[i - <span class="hljs-number">1</span>], nums[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span> || (i + <span class="hljs-number">1</span>) % k == <span class="hljs-number">0</span>) suffixMax[i] = nums[i];       <span class="hljs-comment">//以数组中最后一个元素或者每k个中的最后一个元素开始的后缀最大值就是它自己</span><br>        <span class="hljs-keyword">else</span> suffixMax[i] = Math.max(suffixMax[i + <span class="hljs-number">1</span>], nums[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];          <span class="hljs-comment">//有n-k+1个窗口</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n - k; i++)&#123;<br>        res[i] = Math.max(suffixMax[i], prefixMax[i + k - <span class="hljs-number">1</span>]);         <span class="hljs-comment">//以i开头的后缀最大值和以i+k-1结尾的前缀最大值取max,记得是以k个一组分界了的</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模拟</title>
    <link href="/earsh9.github.io/2022/08/04/4.%E5%AD%97%E7%AC%A6%E4%B8%B2/1.%E6%A8%A1%E6%8B%9F/"/>
    <url>/earsh9.github.io/2022/08/04/4.%E5%AD%97%E7%AC%A6%E4%B8%B2/1.%E6%A8%A1%E6%8B%9F/</url>
    
    <content type="html"><![CDATA[<p><strong>对字符串进行反转、替换、翻转和左旋转等操作时：</strong></p><ol><li>若重点考察某一库函数的实现，则不能调包</li><li>进阶：不使用额外空间，直接原地修改。貌似C++可以，java中原字符串不可变，需要.tocharArray()空间复杂度也o(n)了。</li></ol><h2 id="344题-反转字符串"><a href="#344题-反转字符串" class="headerlink" title="344题 反转字符串"></a>344题 反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p><strong>思路：前后双指针实现交换操作。swap交换可以一设置tmp，二使用位运算来实现。</strong></p><h2 id="541题-反转字符串II"><a href="#541题-反转字符串II" class="headerlink" title="541题 反转字符串II"></a>541题 反转字符串II</h2><h3 id="当需要固定规律一段一段去处理字符串的时候，在for循环的表达式上做文章。"><a href="#当需要固定规律一段一段去处理字符串的时候，在for循环的表达式上做文章。" class="headerlink" title="当需要固定规律一段一段去处理字符串的时候，在for循环的表达式上做文章。"></a>当需要固定规律一段一段去处理字符串的时候，在for循环的表达式上做文章。</h3><p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s &#x3D; “abcdefg”, k &#x3D; 2</p><p>输出: “bacdfeg”</p><p><strong>思路：</strong></p><ol><li>不用一味计数k或2k个，让 i +&#x3D; 2*k，每次移动2k就好。</li><li>要反转的字符头用 i 确定了，尾用end &#x3D; Math.min(s.length - 1, i + k -1)。</li></ol><p><strong>method 1:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> String reverseStr(String s, <span class="hljs-type">int</span> k) &#123;<br>    StringBuilder res = <span class="hljs-built_in">new</span> StringBuilder();<br><br>    <span class="hljs-type">int</span> length = s.length();<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; length)&#123;<br>        StringBuilder tmp = <span class="hljs-built_in">new</span> StringBuilder();   //每循环一次新建一个!<br><br>        <span class="hljs-type">int</span> firstK = Math.min(<span class="hljs-keyword">start</span> + k, length);<br>        <span class="hljs-type">int</span> secondK = Math.min(<span class="hljs-keyword">start</span> + <span class="hljs-number">2</span>*k, length);<br><br>        tmp.append(s, <span class="hljs-keyword">start</span>, firstK);              //append为左闭右开的边界<br>        res.append(tmp.reverse());<br><br>        <span class="hljs-keyword">if</span> (firstK &lt; secondK)&#123;                    //小于k大于<span class="hljs-number">2</span>k的部分正序填入<br>            res.append(s, firstK, secondK);<br>        &#125;<br><br>        <span class="hljs-keyword">start</span> += <span class="hljs-number">2</span> * k;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>method 2:</strong></p><ol><li>字符串反转不想每次新建StringBuilder,可以转化成字符数组</li><li>注意 ***字符数组转化为字符串是new String(chars)***，若用Arrays.toString(chars)是物理意义上的输出会有多余空格。</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> String reverseStr(String s, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-type">char</span>[] ch = s.toCharArray();                         //原地修改<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ch.length; i += <span class="hljs-number">2</span>*k)&#123;<br>        <span class="hljs-type">int</span> start = i;<br>        <span class="hljs-type">int</span> end = Math.min(<span class="hljs-keyword">start</span> + k - <span class="hljs-number">1</span>, ch.length - <span class="hljs-number">1</span>);    //双闭的边界<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>            ch[<span class="hljs-keyword">start</span>] ^= ch[<span class="hljs-keyword">end</span>];<br>            ch[<span class="hljs-keyword">end</span>] ^= ch[<span class="hljs-keyword">start</span>];<br>            ch[<span class="hljs-keyword">start</span>] ^= ch[<span class="hljs-keyword">end</span>];<br>            <span class="hljs-keyword">start</span>++;<span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> String(ch);           //字符数组转化为字符串<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>method3：类似method2，将swap单另实现</strong></p><ol><li><em><strong>像String、char[]（各种类型的数组）这种非基本类型的数据类型，同类中其他方法调用它时是浅拷贝即调用地址，所有作出的修改实时更新！</strong></em></li><li>只有int,double,char,float…等基本类型在调用或传参时是深拷贝,对其所作修改对原先的没有任何影响</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> String reverseStr(String s, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-type">char</span>[] ch = s.toCharArray();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i += <span class="hljs-number">2</span>*k)&#123;<br>        <span class="hljs-type">int</span> end = Math.min(i + k, s.length()) - <span class="hljs-number">1</span>;<br>        reverse(ch, i , <span class="hljs-keyword">end</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> String(ch);<br>&#125;<br><br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> reverse(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>)&#123;    //对<span class="hljs-type">char</span>[] ch所作的修改实时更新<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>        ch[<span class="hljs-keyword">start</span>] ^= ch[<span class="hljs-keyword">end</span>];<br>        ch[<span class="hljs-keyword">end</span>] ^= ch[<span class="hljs-keyword">start</span>];<br>        ch[<span class="hljs-keyword">start</span>] ^= ch[<span class="hljs-keyword">end</span>];<br>        <span class="hljs-keyword">start</span>++;<span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>字符串</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>双指针填充</title>
    <link href="/earsh9.github.io/2022/08/04/4.%E5%AD%97%E7%AC%A6%E4%B8%B2/2.%E5%8F%8C%E6%8C%87%E9%92%88%E5%A1%AB%E5%85%85/"/>
    <url>/earsh9.github.io/2022/08/04/4.%E5%AD%97%E7%AC%A6%E4%B8%B2/2.%E5%8F%8C%E6%8C%87%E9%92%88%E5%A1%AB%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="如何不使用额外空间，不调用split等库函数？"><a href="#如何不使用额外空间，不调用split等库函数？" class="headerlink" title="如何不使用额外空间，不调用split等库函数？"></a>如何不使用额外空间，不调用split等库函数？</h1><h2 id="剑指Offer-05-替换空格"><a href="#剑指Offer-05-替换空格" class="headerlink" title="剑指Offer 05.替换空格"></a>剑指Offer 05.替换空格</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1： 输入：s &#x3D; “We are happy.”</p><p>输出：”We%20are%20happy.”</p><p><strong>思考：</strong></p><ol><li><p>若想原地修改，一个空格字符要变成”%20”这三个字符，涉及到扩容问题</p><ol><li>假设面试官让在原先字符串上做替换，并保证输入字符串后有足够多的内存。</li></ol></li><li><p>每替换一次，就需将空格后的内容右移一次，如此是o(n^2)的时间复杂度，如何降低？</p><ol><li><em><strong>双指针，提前计算好需扩容的大小，从后往前填充</strong></em></li></ol></li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == null || s.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;<br><br>    StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();             <span class="hljs-comment">//记录空格个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">charAt</span>(i) == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            sb.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;  &quot;</span>);                           <span class="hljs-comment">//多扩充空格*2</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sb.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;<br><br>    <span class="hljs-type">int</span> left = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;            <span class="hljs-comment">//指向原串的最后一个位置</span><br>    s += sb.<span class="hljs-built_in">toString</span>();                  <span class="hljs-comment">//原串基础上扩容</span><br>    <span class="hljs-type">int</span> right = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;          <span class="hljs-comment">//指向扩容后的最后一个位置</span><br>    <span class="hljs-type">char</span>[] ch = s.<span class="hljs-built_in">toCharArray</span>();        <span class="hljs-comment">//重点！如果是新建的话后期无法复制</span><br><br>    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> (ch[left] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            ch[right--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            ch[right--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            ch[right--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            ch[right--] = ch[left];<br>        &#125;<br><br>        left--;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(ch);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="151题-翻转字符串里的单词"><a href="#151题-翻转字符串里的单词" class="headerlink" title="151题 翻转字符串里的单词"></a>151题 翻转字符串里的单词</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”</p><p>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “</p><p>输出: “world! hello”</p><p>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good   example”</p><p>输出: “example good a”</p><p>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p><strong>思考：</strong></p><ol><li><p>预处理：删除前置空格、后置空格和中间多余空格</p><ol><li>如果是for循环遍历，碰到不符合的就删除。而删除操作就为o(n)的复杂度，外加for即为o(n^2)</li><li><em><strong>用双指针移除冗余空格：fast走的快，slow就标记着移除后的新字符串长度。见数组-&gt;双指针法</strong></em></li><li>也可以原地修改和填充相结合一起写</li></ol></li><li><p>先将字符串整体反转，实现倒序。</p></li><li><p>但单词本身也倒序了，再对单词局部反转。</p><ol><li>两种反转可以共用一个reverse函数</li></ol></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> String reverseWords(String s) &#123;<br>    <span class="hljs-type">char</span>[] initialArr = s.toCharArray();<br><br>    //整体反转后initialArr已被修改，此后的判断就要用initialArr来写而非s.charAt<br><br>    reverse(initialArr, <span class="hljs-number">0</span>, s.length() - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;                           //为了移位(删除前置空格)和记录更新后的字符串最后的位置<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; initialArr.length; i++)&#123;<br>        <span class="hljs-keyword">if</span> (initialArr[i] == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> left = i;                                 //提前记录局部反转的左边界<br>        <span class="hljs-keyword">while</span> (i &lt; initialArr.length &amp;&amp; initialArr[i] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            i++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = left; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span> (j == left)&#123;<br>                reverse(initialArr, left, i - <span class="hljs-number">1</span>);    //局部反转，i - <span class="hljs-number">1</span>为右边界<br>            &#125;<br><br>            initialArr[k++] = initialArr[j];         //从前往后填充(去除前导<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> (j == i - <span class="hljs-number">1</span>)&#123;                         //此次填充结束时的避免溢出判断<br>                <span class="hljs-keyword">if</span> (k &lt; initialArr.length)&#123;<br>                    initialArr[k++] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> String(initialArr, <span class="hljs-number">0</span>, (k == initialArr.length) &amp;&amp; (initialArr[k<span class="hljs-number">-1</span>] != <span class="hljs-string">&#x27; &#x27;</span>) ? k : k - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> reverse(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>)&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>        ch[<span class="hljs-keyword">start</span>] ^= ch[<span class="hljs-keyword">end</span>];<br>        ch[<span class="hljs-keyword">end</span>] ^= ch[<span class="hljs-keyword">start</span>];<br>        ch[<span class="hljs-keyword">start</span>] ^= ch[<span class="hljs-keyword">end</span>];<br>        <span class="hljs-keyword">start</span>++;<span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer58-II-左旋转字符串"><a href="#剑指Offer58-II-左旋转字符串" class="headerlink" title="剑指Offer58-II.左旋转字符串"></a>剑指Offer58-II.左旋转字符串</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>示例 1：<br>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”</p><p>示例 2：<br>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”</p><p>限制：<br>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</p><p><strong>思考：</strong></p><ol><li>把前面若干字符搬到尾部 -&gt; 将字符串分成前后两部分，分别旋转</li><li>再全局旋转</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-title function_">reverseLeftWords</span>(<span class="hljs-built_in">String</span> s, <span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-type">char</span>[] initial = s.<span class="hljs-property">toCharArray</span>();<br>    <span class="hljs-built_in">reverse</span>(initial, <span class="hljs-number">0</span> ,n - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">reverse</span>(initial, n, initial.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">reverse</span>(initial, <span class="hljs-number">0</span>, initial.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(initial);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)&#123;<br>    <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>        ch[i] ^= ch[j];<br>        ch[j] ^= ch[i];<br>        ch[i] ^= ch[j];<br>        i++;j--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>字符串</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串匹配问题</title>
    <link href="/earsh9.github.io/2022/08/04/4.%E5%AD%97%E7%AC%A6%E4%B8%B2/3.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <url>/earsh9.github.io/2022/08/04/4.%E5%AD%97%E7%AC%A6%E4%B8%B2/3.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</p><h2 id="重点：如何记录已经匹配的文本内容？"><a href="#重点：如何记录已经匹配的文本内容？" class="headerlink" title="重点：如何记录已经匹配的文本内容？"></a>重点：如何记录已经匹配的文本内容？</h2><p>用next()数组。next数组就是一个<strong>前缀表（prefix table）。</strong></p><h3 id="1）前缀表有什么作用呢？"><a href="#1）前缀表有什么作用呢？" class="headerlink" title="1）前缀表有什么作用呢？"></a>1）前缀表有什么作用呢？</h3><p>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</p><p>举例：要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="show" /><ul><li><p>文本串中第六个字符b 和 模式串的第六个字符f，不匹配。如果暴力匹配发现不匹配时，直接从头匹配。</p></li><li><p>但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。即<strong>在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</strong></p></li></ul><h3 id="2）前缀表是如何记录的呢？"><a href="#2）前缀表是如何记录的呢？" class="headerlink" title="2）前缀表是如何记录的呢？"></a>2）前缀表是如何记录的呢？</h3><p><strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p><p>字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。</p><p>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。</p><ul><li>在模式串 f 处不匹配时，因为f前的子串“aabaa”有最长相等的前后缀“aa”，<strong>匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。</strong></li></ul><h3 id="3）如何计算前缀表？"><a href="#3）如何计算前缀表？" class="headerlink" title="3）如何计算前缀表？"></a>3）如何计算前缀表？</h3><p>模式串与前缀表<strong>对应位置</strong>的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</p><p>例如：</p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png" alt="slow" /><p>如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置呢？</p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="slow" /><ul><li>当遇到不匹配时，（说明文本串和模式串在该字符之前都匹配！）</li><li>去看它前一个字符的前缀表数值，（该数值代表前面字符串的最长相同的前缀和后缀）</li><li>即模式串的指针就可以移动到该数值所代表的索引位置下继续匹配。</li></ul><h3 id="4）代码实现前缀表：next数组"><a href="#4）代码实现前缀表：next数组" class="headerlink" title="4）代码实现前缀表：next数组"></a>4）代码实现前缀表：next数组</h3><ul><li>next数组可以就是前缀表</li><li>更多的next数组是将前缀表统一减一（右移一位，初始位置为-1）</li></ul><p>动画演示使用next数组来实现字符串匹配：使用前缀表统一减一的形式</p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif" alt="slow" /><p>构建next数组：计算模式串的前缀表。</p><ul><li>初始化：定义两个指针i和j，j指向前缀起始位置，i指向后缀起始位置。</li><li>由于使用前缀表统一减一的形式，j&#x3D;-1,next[0]&#x3D;-1;</li><li>所以每一次和s[i]去比较的是s[j+1]！！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, const string&amp; s)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    next[<span class="hljs-number">0</span>] = j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.size(); i++) &#123; <span class="hljs-comment">// 注意i从1开始</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 前后缀不相同了</span><br>            j = next[j]; <span class="hljs-comment">// 向前回退</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 找到相同的前后缀</span><br>            j++;<br>        &#125;<br>        next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码构造next数组的逻辑流程动画如下：</p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif" alt="slow" /><h2 id="28题-实现strStr"><a href="#28题-实现strStr" class="headerlink" title="28题 实现strStr()"></a>28题 实现strStr()</h2><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p><strong>说明：</strong></p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p><p>示例 1：</p><p>输入：haystack &#x3D; “hello”, needle &#x3D; “ll”</p><p>输出：2</p><p>示例 2：</p><p>输入：haystack &#x3D; “aaaaa”, needle &#x3D; “bba”</p><p>输出：-1</p><p>示例 3：</p><p>输入：haystack &#x3D; “”, needle &#x3D; “”</p><p>输出：0</p><p>提示：</p><p>0 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 5 * 10^4</p><p>haystack 和 needle 仅由小写英文字符组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>    <span class="hljs-keyword">if</span>(needle.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[needle.length()];<br>    getNext(next, needle);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; haystack.length(); i++)&#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j + <span class="hljs-number">1</span>))&#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (haystack.charAt(i) == needle.charAt(j + <span class="hljs-number">1</span>))&#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == needle.length() - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> (i - needle.length() + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>[] next, String s)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    next[<span class="hljs-number">0</span>] = j;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; next.length; i++)&#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j + <span class="hljs-number">1</span>))&#123;<br>            j = next[j];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j + <span class="hljs-number">1</span>))&#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="459题-重复的子字符串"><a href="#459题-重复的子字符串" class="headerlink" title="459题 重复的子字符串"></a>459题 重复的子字符串</h2><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:</p><p>输入: “abab”</p><p>输出: True</p><p>解释: 可由子字符串 “ab” 重复两次构成。</p><p>示例 2:</p><p>输入: “aba”</p><p>输出: False</p><p>示例 3:</p><p>输入: “abcabcabcabc”</p><p>输出: True</p><p>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>KMP中next数组记录最长相等前后缀，对于前缀表统一减一的形式来说：</p><ul><li>设数组长度为len，则 next[len-1] + 1 表示该字符串最长相等前后缀的长度。</li><li>如果len % (len - (next[len - 1] + 1)) &#x3D;&#x3D; 0</li><li>说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。</li></ul></li><li><p>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</p><ul><li>因为前缀不包含最后一个字符，后缀不包含第一个字符。</li></ul></li><li><p>另一种思路是：代码与28题 实现strStr()类似</p><ul><li>对于满足题目要求的字符串s，一定是包含两个及以上的子串a</li><li>那s+s去掉首尾字符（即破坏掉首尾的两个子串a）后，还能再匹配到一个s，即满足题意。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    getNext(next,s);<br><br><span class="hljs-comment">//getNext()实现的是减一的前缀表，判断条件是 !=-1; 例如&quot;bb&quot;</span><br><br>    <span class="hljs-keyword">return</span> next[len-<span class="hljs-number">1</span>] != -<span class="hljs-number">1</span> &amp;&amp; len % (len - (next[len-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>[] next, String s)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    next[<span class="hljs-number">0</span>] = j;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j+<span class="hljs-number">1</span>))&#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j+<span class="hljs-number">1</span>))&#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">haystack</span> <span class="hljs-operator">=</span> (s+s).substring(<span class="hljs-number">1</span>,s.length()*<span class="hljs-number">2</span>-<span class="hljs-number">1</span>);         <span class="hljs-comment">//左闭右开：掐头去尾</span><br><br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>    getNext(next,s);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; haystack.length(); i++)&#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; haystack.charAt(i) != s.charAt(j+<span class="hljs-number">1</span>))&#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (haystack.charAt(i) == s.charAt(j+<span class="hljs-number">1</span>))&#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == s.length() - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="686-重复叠加字符串匹配"><a href="#686-重复叠加字符串匹配" class="headerlink" title="686. 重复叠加字符串匹配"></a>686. 重复叠加字符串匹配</h2><p>给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。</p><p>注意：字符串 “abc” 重复叠加 0 次是 “”，重复叠加 1 次是 “abc”，重复叠加 2 次是 “abcabc”。</p><p><strong>思路：</strong></p><ul><li><p>核心在于怎么计算a需要重复叠加的次数？</p></li><li><p>先利用kmp求得 a 中 b 第一次出现的位置下标 index</p><ul><li><p>若没找到，再重复也不会找到了，直接return -1;</p></li><li><p>若a.length() - index &gt;&#x3D; b.length()，说明a不用重复也能匹配，return 1;</p></li><li><p>反之再去计算个数</p></li></ul></li></ul><p>举例：a &#x3D; “abcd”, b &#x3D; “cdabcdab”</p><p>b的组成如下 cd + 1个 abcd + ab</p><p>故需要a的个数为</p><p>(bn - (an - index) - 1 &#x2F; an) + 2  即 (bn + index - an - 1) &#x2F; an + 2</p><p>其中an-index为cd的长度</p><p>因为不知道cd abcd ab后面是否存在ab这个尾巴, 所有统一减1计算需要a的个数</p><p>cd需要a一个, 尾巴ab需要a一个, 故还要+2</p><p>所以结果为 (bn + index - an - 1) &#x2F; an + 2</p><img src="需要多少个a计算图示.jpg" width = "50%" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">repeatedStringMatch</span><span class="hljs-params">(String a, String b)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">an</span> <span class="hljs-operator">=</span> a.length(), bn = b.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> strStr(a,b);<br><br>    <span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (an - index &gt;= bn) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;         <span class="hljs-comment">//说明a无需叠加，一个就够了</span><br>    <span class="hljs-keyword">return</span> (bn + index - an - <span class="hljs-number">1</span>) / an + <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">//因为a是不断循环叠加的字符串，kmp需查看的是a中b第一次出现的位置下标</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String a, String b)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length(), m = b.length();<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;                   <span class="hljs-comment">//next数组求解不变,本题更方便的是不减一的版本</span><br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; b.charAt(i) != b.charAt(j))&#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (b.charAt(i) == b.charAt(j))&#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i - j &lt; n; i++)&#123;         <span class="hljs-comment">//b 开始匹配的位置是否超过第一个叠加的 a : i和j的间隔差不能超过a的长度n</span><br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a.charAt(i % n) != b.charAt(j))&#123;     <span class="hljs-comment">//a 是循环叠加的字符串，所以取 i % n</span><br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a.charAt(i % n) == b.charAt(j))&#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == b.length()) <span class="hljs-keyword">return</span> i - m + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>字符串</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/earsh9.github.io/2022/08/04/4.%E5%AD%97%E7%AC%A6%E4%B8%B2/4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/earsh9.github.io/2022/08/04/4.%E5%AD%97%E7%AC%A6%E4%B8%B2/4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<ul><li><p>若想在哈希表中记录字符串出现的次数</p><ul><li>Java 中的 String 的 hashCode 实现是会对字符串进行遍历的，这样哈希计数过程仍与长度有关。</li><li>只有存放Integer 的 hashCode 就是该值本身，与长度无关。</li></ul></li><li><p>如何用 int 型数据来区别或者表征不同的字符串？</p><ul><li>使用质数 &#x2F; 二进制码 对字符串进行编码，保证不会有冲突即可。</li><li>对于质数 p 和其元根 N，对于 0 ~ N - 1 中的任意数都可以用 p 的 x 次方来表示。x 取 0 ~ p - 1。</li><li>采用 p 进制数编码后 与 N 取模，以限制数据的范围在 0 ~ N - 1 内。</li></ul></li></ul><h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187.重复的DNA序列"></a>187.重复的DNA序列</h2><p>所有 DNA 都由一系列缩写为 ‘A’，’C’，’G’ 和 ‘T’ 的核苷酸组成，例如：”ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p><p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p><p>示例 1：</p><p>输入：s &#x3D; “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”</p><p>输出：[“AAAAACCCCC”,”CCCCCAAAAA”]</p><p>示例 2：</p><p>输入：s &#x3D; “AAAAAAAAAAAAA”</p><p>输出：[“AAAAAAAAAA”]</p><p>提示：</p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 105</p><p>s[i] 为 ‘A’、’C’、’G’ 或 ‘T’</p><p><strong>思路：</strong></p><ol><li><p>可以 <strong>“哈希表 + 滑动窗口”</strong></p><ul><li>窗口大小固定为10，用String 类型哈希表记录出现次数</li><li>仅出现次数为2时加入answer。</li></ul></li><li><p>但String 类型的哈希表计数时会对字符串遍历，在序列较长时会超限。</p></li><li><p>改为 <strong>“哈希表 + 滑动窗口 + 位运算”</strong> （好理解）</p><ul><li>使用 int 型的哈希表，只存值不会遍历，此步骤用位运算实现。</li><li>数据只有四种类型，用两位二进制码即00、01、10、11就足够。而子串长度均为10，10*2&#x3D;20位二进制码，一个int型有32位足够。</li><li><strong>不要吝啬位运算的括号！！！</strong></li></ul></li><li><p>或者 <strong>“字符串哈希 + 前缀和”</strong></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247489813&amp;idx=1&amp;sn=7f3bc18ca390d85b17655f7164d8e660&amp;chksm=fd9cb20acaeb3b1cc78abf05d6fea6d093098998ce877f799ac478247604bd267fbee6fcd989&amp;token=1342991619&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247489813&amp;idx=1&amp;sn=7f3bc18ca390d85b17655f7164d8e660&amp;chksm=fd9cb20acaeb3b1cc78abf05d6fea6d093098998ce877f799ac478247604bd267fbee6fcd989&amp;token=1342991619&amp;lang=zh_CN#rd</a></li><li>使用质数对子串进行哈希编码，只要没有冲突就行。</li><li>而前缀和可以帮助将 hashcode 一次读取出来。</li></ul></li></ol><p>前缀和（极大降低区间查询的时间复杂度）可以参见 - 825.适龄的朋友<br>进阶： - 1044.最长重复子串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-keyword">if</span>(n &lt;= L) <span class="hljs-keyword">return</span> res;<br><br>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Integer&gt;()&#123;&#123;<br>       put(<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-number">0</span>);<br>       put(<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">1</span>);<br>       put(<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-number">2</span>);<br>       put(<span class="hljs-string">&#x27;T&#x27;</span>,<span class="hljs-number">3</span>);<br>    &#125;&#125;;<br>    <span class="hljs-comment">//先预设前9位的数值例如ACGT...: x 初始化为0,每次通过左移两位以保存原先初始化的值，再与map中字母对应的两位二进制码进行相或 来完成初始化</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; L - <span class="hljs-number">1</span>; i++)&#123;<br>        x = (x &lt;&lt; <span class="hljs-number">2</span>) | map.get(s.charAt(i));<br>    &#125;<br><br>    Map&lt;Integer, Integer&gt; count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n - L; i++)&#123;<br><span class="hljs-comment">//初始化第10位即第一个窗口创建完成,此后还需与操作以实现只去int型数据的低20位</span><br>        x = ((x &lt;&lt; <span class="hljs-number">2</span>) | map.get(s.charAt(i + L - <span class="hljs-number">1</span>))) &amp; ((<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">2</span> * L)) - <span class="hljs-number">1</span>);<br>        count.put(x, count.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">if</span> (count.get(x) == <span class="hljs-number">2</span>) res.add(s.substring(i, i + L));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>字符串</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些用法</title>
    <link href="/earsh9.github.io/2022/08/04/3.%E5%93%88%E5%B8%8C%E8%A1%A8/%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/"/>
    <url>/earsh9.github.io/2022/08/04/3.%E5%93%88%E5%B8%8C%E8%A1%A8/%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表一般用来快速判断一个元素是否出现集合里"><a href="#哈希表一般用来快速判断一个元素是否出现集合里" class="headerlink" title="哈希表一般用来快速判断一个元素是否出现集合里"></a>哈希表一般用来快速判断一个元素是否出现集合里</h1><p><code>像Set、Map底层实现有红黑树和哈希表两种：</code></p><ol><li><p>哈希表的实现一定不保证有序。</p><p>哈希表是通过哈希函数将数据转化为不同的数值，即将数据映射到哈希表的索引数字了。</p></li><li><p>红黑树是一种平衡二叉树，所以有序。</p></li></ol><h1 id="1-去重"><a href="#1-去重" class="headerlink" title="1. 去重"></a>1. 去重</h1><h2 id="349题-两个数组的交集"><a href="#349题-两个数组的交集" class="headerlink" title="349题 两个数组的交集"></a>349题 两个数组的交集</h2><p>题意：给定两个数组，编写一个函数来计算它们的交集。</p><p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]。输出：[2]</p><p>说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p><ol><li>唯一意味着要去重</li><li><strong>未限制数值大小，无法确定数组大小。所以用Set。</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums1) &#123;<br>        set.add(i);<br>    &#125;<br><br>    Set&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums2) &#123;<br>        <span class="hljs-keyword">if</span> (set.contains(i)) res.add(i);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> re : res) &#123;<br>        ret[i++] = re;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="202题-快乐数"><a href="#202题-快乐数" class="headerlink" title="202题 快乐数"></a>202题 快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><ol><li><strong>可能无限循环但始终不到1：数据会出现重复。一旦重复即return false</strong></li><li>除了数据本身无需记录其他，Set即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span> &amp;&amp; !set.contains(n))&#123;        <span class="hljs-comment">//set保证不会死循环</span><br>        set.add(n);<br>        n = getNextNum(n);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNextNum</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">10</span>;<br>        sum += bit * bit;<br>        n = n / <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>是否有重复：判断链表是否有环：快慢指针</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> n;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> getNextNum(n);<br><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-number">1</span> &amp;&amp; slow != fast)&#123;<br>        slow = getNextNum(slow);<br>        fast = getNextNum(getNextNum(fast));<br>    &#125;<br>    <span class="hljs-keyword">return</span> fast == <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-用数组来表示哈希表，更快捷"><a href="#2-用数组来表示哈希表，更快捷" class="headerlink" title="2. 用数组来表示哈希表，更快捷"></a>2. 用数组来表示哈希表，更快捷</h1><h2 id="242题-有效的字母异位词"><a href="#242题-有效的字母异位词" class="headerlink" title="242题 有效的字母异位词"></a>242题 有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true</p><p>示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false</p><h2 id="383题-赎金信"><a href="#383题-赎金信" class="headerlink" title="383题 赎金信"></a>383题 赎金信</h2><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>两题极其相似，由于有以下条件，可以用数组代表哈希表，一加一减来判断：</strong></p><ol><li>你可以假设两个字符串均只含有小写字母。数组大小确定了</li><li>每个字符只能在赎金信字符串中使用一次。限定字母不可重复使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct1</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>    <span class="hljs-type">int</span>[] mag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : magazine.toCharArray()) &#123;<br>        mag[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : ransomNote.toCharArray()) &#123;<br>        mag[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        <span class="hljs-keyword">if</span> (mag[c - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-可以降低时间复杂度"><a href="#3-可以降低时间复杂度" class="headerlink" title="3. 可以降低时间复杂度"></a>3. 可以降低时间复杂度</h1><h2 id="1题-两数之和"><a href="#1题-两数之和" class="headerlink" title="1题 两数之和"></a>1题 两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><ol><li>暴力是o(n^2)</li><li>只有一个答案且一个元素不能使用两遍：一次遍历即可</li><li><strong>返回数组下标：用Map记录数值和对应的索引</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br><br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> target - nums[i];<br>        <span class="hljs-keyword">if</span>(map.containsKey(tmp))&#123;<br>            res[<span class="hljs-number">1</span>] = i;<br>            res[<span class="hljs-number">0</span>] = map.get(tmp);<br>        &#125;<br>        map.put(nums[i], i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="454题-经典哈希：四数相加II"><a href="#454题-经典哈希：四数相加II" class="headerlink" title="454题 经典哈希：四数相加II"></a>454题 经典哈希：四数相加II</h2><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p>例如:</p><p>输入: A &#x3D; [ 1, 2] B &#x3D; [-2,-1] C &#x3D; [-1, 2] D &#x3D; [ 0, 2] 输出: 2 解释: 两个元组如下:</p><p>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</p><p>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</p><ol><li>暴力是o(n^4)</li><li>因为是四个独立的数组，所以无需考虑有重复元素加和为0的情况。！！！！！</li><li><strong>用一个Map统计前两个数组元素之和，和出现的次数。</strong></li><li>对后两个数组进行查找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums1) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : nums2) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum1</span> <span class="hljs-operator">=</span> i + j;<br>            map.put(sum1, map.getOrDefault(sum1, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums3) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : nums4) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(-i-j))&#123;<br>                cnt += map.get(-i-j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-有时候哈希解法不见得很高效"><a href="#4-有时候哈希解法不见得很高效" class="headerlink" title="4. 有时候哈希解法不见得很高效"></a>4. 有时候哈希解法不见得很高效</h1><h2 id="15题-三数之和"><a href="#15题-三数之和" class="headerlink" title="15题 三数之和"></a>15题 三数之和</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p><p>注意： 答案中不可以包含重复的三元组。</p><p>示例：</p><p>给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><ol><li>不能有重复的三元组：去重</li><li>不仅要在遍历数组的时候去重，还要在返回答案的时候去重。</li><li>哈希表来去重，耗时耗空间。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(nums);               <span class="hljs-comment">//排序才有双指针</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">//预处理，最小的都大于0，无解</span><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">//对数组元素去重的正确写法</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (right &gt; left) &#123;              <span class="hljs-comment">//双闭的写法</span><br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br><br>            <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.add(Arrays.asList(nums[i], nums[left], nums[right]));<br><br><span class="hljs-comment">//找到一组正确答案后，再对元素去重。如果在while内一开始就去重，会跳过[0,0,0]这种解</span><br><br>                <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                <span class="hljs-comment">//最后同时收缩区间，进行下一次循环</span><br>                right--;<br>                left++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18题-四数之和"><a href="#18题-四数之和" class="headerlink" title="18题 四数之和"></a>18题 四数之和</h2><p>类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(nums);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;   <span class="hljs-comment">//j = i +1</span><br><br>            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j]) &#123;  <span class="hljs-comment">//去重，细节</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>;                         <span class="hljs-comment">//left = j + 1，细节</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                    left++;      <span class="hljs-comment">//再来一次突兀的加减，是为了缩短区间供下一次循环使用</span><br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟头节点</title>
    <link href="/earsh9.github.io/2022/08/04/2.%E9%93%BE%E8%A1%A8/1.%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9/"/>
    <url>/earsh9.github.io/2022/08/04/2.%E9%93%BE%E8%A1%A8/1.%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>由于链表的节点在内存中是分散存储，查找当前节点往往需要先找到其前序节点。设置虚拟头节点可以快速帮助厘清关系。</p><h2 id="203题-移除链表元素"><a href="#203题-移除链表元素" class="headerlink" title="203题 移除链表元素"></a>203题 移除链表元素</h2><p>要求：删除链表中等于给定值 val 的所有节点。</p><p>有了虚拟头节点，无需对真正头节点进行特殊处理</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> ListNode removeElements(ListNode head, <span class="hljs-built_in">int</span> val) &#123;<br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>, head);<br><br><span class="hljs-comment">//浅拷贝,pre和cur相当于指针,其所作的修改直接对应到dummy上</span><br><br>    ListNode pre = dummy;          <br>    ListNode cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (cur.val == val)&#123;<br>            pre.<span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;<br>        &#125;<span class="hljs-keyword">else</span> pre = cur;<br>        <br>        cur = cur.<span class="hljs-keyword">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CRUD</title>
    <link href="/earsh9.github.io/2022/08/04/2.%E9%93%BE%E8%A1%A8/2.%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <url>/earsh9.github.io/2022/08/04/2.%E9%93%BE%E8%A1%A8/2.%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<ol><li><p>单链表</p><ol><li>查找：o(n)</li><li>增加：o(n)，找到要插入位置的前驱节点</li><li>删除：o(n)，找到要插入位置的前驱节点</li></ol></li><li><p>双链表</p></li></ol><p>通过判断 index &lt; (size - 1) &#x2F; 2 来决定是从头结点还是尾节点遍历，提高效率</p><h2 id="707题-设计链表"><a href="#707题-设计链表" class="headerlink" title="707题 设计链表"></a>707题 设计链表</h2><p>细节满满</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//单链表实现</span><br>public <span class="hljs-keyword">class</span> ListNode &#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>    ListNode next;<br>    <span class="hljs-constructor">ListNode()</span> &#123;&#125;<br>    <span class="hljs-constructor">ListNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123; this.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>; &#125;<br>    <span class="hljs-constructor">ListNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>, ListNode <span class="hljs-params">next</span>)</span> &#123; this.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>; this.next = next; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> MyLinkedList &#123;<br>    <span class="hljs-built_in">int</span> size;                <span class="hljs-comment">//记录链表大小</span><br>    ListNode head;           <span class="hljs-comment">//虚拟头节点</span><br><br>    public <span class="hljs-constructor">MyLinkedList()</span> &#123;<br>        size = <span class="hljs-number">0</span>;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(0)</span>;<br>    &#125;<br><br>    public <span class="hljs-built_in">int</span> get(<span class="hljs-built_in">int</span> index) &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>index &gt;= size) return -<span class="hljs-number">1</span>;<br><br>        ListNode cur = head.next;       <span class="hljs-comment">//因为有一个前驱虚拟节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)&#123;<br>            cur = cur.next;<br>        &#125;<br>        return cur.<span class="hljs-keyword">val</span>;<br>    &#125;<br><br>    public void add<span class="hljs-constructor">AtHead(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        add<span class="hljs-constructor">AtIndex(0,<span class="hljs-params">val</span>)</span>;<br>    &#125;<br><br>    public void add<span class="hljs-constructor">AtTail(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        add<span class="hljs-constructor">AtIndex(<span class="hljs-params">size</span>,<span class="hljs-params">val</span>)</span>;<br>    &#125;<br><br>    public void add<span class="hljs-constructor">AtIndex(<span class="hljs-params">int</span> <span class="hljs-params">index</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size) return;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) index = <span class="hljs-number">0</span>;<br><br>        ListNode pre = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)&#123;<br>            pre = pre.next;<br>        &#125;<br>        ListNode toAdd = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(<span class="hljs-params">val</span>)</span>;<br>        toAdd.next = pre.next;          <span class="hljs-comment">//将虚拟节点跳过了</span><br>        pre.next = toAdd;<br><br>        size++;<br>    &#125;<br><br>    public void delete<span class="hljs-constructor">AtIndex(<span class="hljs-params">int</span> <span class="hljs-params">index</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>index &gt;= size) return;<br><br>        ListNode pre = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)&#123;<br>            pre = pre.next;<br>        &#125;<br>        pre.next = pre.next.next;<br><br>        size--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19题-删除链表的倒数第n个节点"><a href="#19题-删除链表的倒数第n个节点" class="headerlink" title="19题 删除链表的倒数第n个节点"></a>19题 删除链表的倒数第n个节点</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>设置快慢指针，让快指针先走n步再一起走，快指针走到头时，慢指针刚好走到待删的节点。</p><p>有几个细节：</p><ol><li><p>ListNode dummy &#x3D; new ListNode(-1, head);</p></li><li><p>ListNode slow &#x3D; dummy,fast &#x3D; dummy;</p></li><li><p>while(n– &amp;&amp; fast !&#x3D; null) fast &#x3D; fast.next;  先走n步</p></li><li><p>fast &#x3D; fast.next;  再多走一步</p><p>fast指针要再多走一步即共走了n + 1步，如此slow 才能走到待删节点之前。</p><p><em><strong>链表长度是一定的，fast多走一步，slow就少走一步。</strong></em></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>反转链表</title>
    <link href="/earsh9.github.io/2022/08/04/2.%E9%93%BE%E8%A1%A8/3.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/earsh9.github.io/2022/08/04/2.%E9%93%BE%E8%A1%A8/3.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="206题-反转链表"><a href="#206题-反转链表" class="headerlink" title="206题 反转链表"></a>206题 反转链表</h2><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><ol><li>预设一个空的虚拟节点：ListNode a &#x3D; null;</li><li>ListNode b &#x3D; head;</li><li>预先记录要被断开联系的部分：ListNode tmp &#x3D; b.next;</li><li>b -&gt; a</li><li>a &#x3D; b;b &#x3D; tmp</li></ol><p>循环和递归均可完成</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> ListNode reverseList(ListNode head) &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br><br>    ListNode pre = <span class="hljs-literal">null</span>;      <span class="hljs-comment">//预设一个空节点，完美解决断开原先的连接：例1-&gt;2的连接已经在1-&gt;null的时候断开过了</span><br>    ListNode cur = head;<br>    ListNode tmp;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>)&#123;<br>        tmp = cur.<span class="hljs-keyword">next</span>;      <span class="hljs-comment">//先记录要翻转的下一个节点</span><br>        cur.<span class="hljs-keyword">next</span> = pre;<br>        pre = cur;<br>        cur = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//递归:从前往后</span><br><span class="hljs-keyword">public</span> ListNode reverseList(ListNode head) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reverse</span>(<span class="hljs-literal">null</span>, head);<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-keyword">reverse</span>(ListNode pre, ListNode cur)&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> pre;<br><br>    ListNode tmp = cur.<span class="hljs-keyword">next</span>;<br>    cur.<span class="hljs-keyword">next</span> = pre;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reverse</span>(cur, tmp);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//递归：从后往前</span><br><span class="hljs-keyword">public</span> ListNode reverseList(ListNode head) &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;         <span class="hljs-comment">//走到最后一个节点了,不停的返回到上一层,因为它是新的头节点</span><br><br>    ListNode newHead = reverseList(head.<span class="hljs-keyword">next</span>);  <span class="hljs-comment">//先去找尾巴即新的头节点</span><br>    head.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = head;                      <span class="hljs-comment">//执行反转</span><br>    head.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="24题-两两交换链表中的节点"><a href="#24题-两两交换链表中的节点" class="headerlink" title="24题 两两交换链表中的节点"></a>24题 两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><ol><li>直接模拟，画图搞清逻辑：</li></ol><p>两两交换意味着要跳过无需交换的节点，一次跳两个节点。</p><ol start="2"><li><p>ListNode cur &#x3D; new ListNode(-1, head);</p></li><li><p>ListNode a &#x3D; head,b &#x3D; a.next;</p></li><li><p>对于序列1，2，3，4，5</p><ol><li>cur -&gt; b; 2 是新的真正头节点</li><li>a -&gt; b.next; 先建立连接，这样无需tmp</li><li>b -&gt; a; 再反转</li><li>每次跳俩格子</li></ol></li><li><p>a &#x3D;&#x3D; null || b &#x3D;&#x3D; null 时无节点可反转，结束循环</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>相交和环形链表</title>
    <link href="/earsh9.github.io/2022/08/04/2.%E9%93%BE%E8%A1%A8/4.%E7%9B%B8%E4%BA%A4%E5%92%8C%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/earsh9.github.io/2022/08/04/2.%E9%93%BE%E8%A1%A8/4.%E7%9B%B8%E4%BA%A4%E5%92%8C%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。</p><ol><li>对两个链表各循环一次，得到各自的长度</li><li>多的先走长度之差步，再一起走，直到指向同一个节点</li></ol><h2 id="142题-环形链表II"><a href="#142题-环形链表II" class="headerlink" title="142题 环形链表II"></a>142题 环形链表II</h2><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><h3 id="最直观的思路，哈希表"><a href="#最直观的思路，哈希表" class="headerlink" title="最直观的思路，哈希表"></a>最直观的思路，哈希表</h3><p><code>Set&lt;ListNode&gt; visited = new HashSet&lt;&gt;()</code><br>依次记录每个节点，遇到重复的就返回</p><h3 id="想空间复杂度o-1"><a href="#想空间复杂度o-1" class="headerlink" title="想空间复杂度o(1):"></a>想空间复杂度o(1):</h3><ol><li><p>先判断是否有环形：快慢指针</p><ol><li>快的每次比慢的多走一步，若有环形则在环内快的一定会一步一步追上慢的，即相遇。</li></ol></li><li><p>若有环，找到这个环的入口：</p><ol><li>设从头节点到环形入口节点 的节点数为x，环形入口节点到快慢指针相遇节点 的节点数为y，从相遇节点再到环形入口节点为z</li><li>在相遇时：slow指针走过的节点数为：x + y；fast指针走过的节点数为：x + y + n * (y + z)</li><li>二者又有二倍的关系，约分移项后：x &#x3D; (n - 1) * (y + z) + z；</li></ol></li><li><p>例如n &#x3D; 1时，x &#x3D; z，从头节点出发一个指针a，再从相遇节点出发一个指针b，这两个指针每次走一个节点，当两个指针相遇时即为环形入口节点。n &gt; 1时即b要多走n - 1圈才遇见a。</p></li><li><p>为什么slow指针走过节点数为x + y而不是 x + y + 环的若干长度n呢？</p><ol><li>fast一定比slow先入环，当slow走到环形入口位置处时，fast一定在环内某个位置设其在环内已走过k个节点，k &lt; n。</li><li>当fast下一次走到环形入口时，已走过k + n个节点，slow走过(k + n)&#x2F;2。由于k &lt; n，(k + n)&#x2F;2 &lt; n，即slow还没有走完一圈fast就已经走到了环形入口即相遇了。</li><li>fast每次走两步slow每次走一步，fast是一步一步靠近slow，不存在会是跳过的情况。</li></ol></li></ol><p>或者说：</p><ul><li>fast走过的节点数是slow走过的节点数的二倍，若slow和fast同时在环入口处出发，则slow走一圈fast走两圈就会再次相遇。</li><li>而slow走到环入口时，fast一定在环中某一位置处，即fast多走了k个节点。slow还没走完一圈，二者就会再次相遇。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>双向链表</title>
    <link href="/earsh9.github.io/2022/08/04/2.%E9%93%BE%E8%A1%A8/5.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/earsh9.github.io/2022/08/04/2.%E9%93%BE%E8%A1%A8/5.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="双向链表-哈希表的运用-解决-“缓存”-cache-类型的题"><a href="#双向链表-哈希表的运用-解决-“缓存”-cache-类型的题" class="headerlink" title="双向链表 + 哈希表的运用 解决 “缓存”(cache) 类型的题"></a>双向链表 + 哈希表的运用 解决 “缓存”(cache) 类型的题</h1><p>一般是设计一个数据结构实现 增、查 和 改操作，要求每一步时间复杂度为 O(1)</p><h2 id="432-全-O-1-的数据结构"><a href="#432-全-O-1-的数据结构" class="headerlink" title="432. 全 O(1) 的数据结构"></a>432. 全 O(1) 的数据结构</h2><p>请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。</p><p>实现 AllOne 类：</p><p>AllOne() 初始化数据结构的对象。</p><p>inc(String key) 字符串 key 的计数增加 1 。如果数据结构中尚不存在 key ，那么插入计数为 1 的 key 。</p><p>dec(String key) 字符串 key 的计数减少 1 。如果 key 的计数在减少后为 0 ，那么需要将这个 key 从数据结构中删除。</p><p>测试用例保证：在减少计数前，key 存在于数据结构中。</p><p>getMaxKey() 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 “” 。</p><p>getMinKey() 返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串 “” 。</p><p>示例：</p><p>输入</p><p>[“AllOne”, “inc”, “inc”, “getMaxKey”, “getMinKey”, “inc”, “getMaxKey”, “getMinKey”]</p><p>[[], [“hello”], [“hello”], [], [], [“leet”], [], []]</p><p>输出</p><p>[null, null, null, “hello”, “hello”, null, “hello”, “leet”]</p><p>解释</p><p>AllOne allOne &#x3D; new AllOne();</p><p>allOne.inc(“hello”);</p><p>allOne.inc(“hello”);</p><p>allOne.getMaxKey(); &#x2F;&#x2F; 返回 “hello”</p><p>allOne.getMinKey(); &#x2F;&#x2F; 返回 “hello”</p><p>allOne.inc(“leet”);</p><p>allOne.getMaxKey(); &#x2F;&#x2F; 返回 “hello”</p><p>allOne.getMinKey(); &#x2F;&#x2F; 返回 “leet”</p><p>提示：</p><p>1 &lt;&#x3D; key.length &lt;&#x3D; 10</p><p>key 由小写英文字母组成</p><p>测试用例保证：在每次调用 dec 时，数据结构中总存在 key</p><p>最多调用 inc、dec、getMaxKey 和 getMinKey 方法 5 * 10^4 次</p><h3 id="双向链表实现-O-1-排序"><a href="#双向链表实现-O-1-排序" class="headerlink" title="双向链表实现 O(1) 排序"></a>双向链表实现 O(1) 排序</h3><ol><li><p>使用 TreeMap 和 Map 无法实现所有操作均 O(1)，但目前数据量较弱还可以通过</p></li><li><p>字符串长度最大为10，可将其长度视为常数空间</p></li><li><p>双向链表中每个节点 Node 的属性：prev,next,keys,count</p><ul><li><p>除前序和后序节点外，keys表征所有出现次数为 count 的字符串集合</p></li><li><p><strong>双向链表按照单调递增的顺序；哈希表维护（字符串，节点）的键值对方便查找</strong></p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AllOne</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;                         <span class="hljs-comment">//手动实现自定义的 Node，作为双向链表的节点元素</span><br>        Node prev, next;<br>        Set&lt;String&gt; keys;<br>        <span class="hljs-type">int</span> count;<br><br>        Node()&#123;<br>            <span class="hljs-built_in">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>        &#125;<br><br>        Node(String key, <span class="hljs-type">int</span> count)&#123;<br>            <span class="hljs-built_in">this</span>.count = count;<br>            keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>            keys.add(key);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">insert</span><span class="hljs-params">(Node node)</span>&#123;    <span class="hljs-comment">//在 this 后插入 node 节点</span><br>            node.prev = <span class="hljs-built_in">this</span>;<br>            node.next = <span class="hljs-built_in">this</span>.next;<br>            node.prev.next = node;<br>            node.next.prev = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>&#123;              <span class="hljs-comment">//移除自己</span><br>            <span class="hljs-built_in">this</span>.prev.next = <span class="hljs-built_in">this</span>.next;<br>            <span class="hljs-built_in">this</span>.next.prev = <span class="hljs-built_in">this</span>.prev;<br>        &#125;<br>    &#125;<br><br>    Node root;<br>    Map&lt;String, Node&gt; nodes;            <span class="hljs-comment">//当前字符串所处的链表节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AllOne</span><span class="hljs-params">()</span>&#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        root.prev = root;<br>        root.next = root;              <span class="hljs-comment">//初始化哨兵，若判断某节点 .next/.prev 为 root 即代表为空</span><br>        nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inc</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nodes.containsKey(key))&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nodes.get(key);        <span class="hljs-comment">//cur 与 nxt 原先在链表中就是递增的，区别只在于 cur.count 与 nxt.count 是差 1 还是差好多</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> cur.next;<br>            <span class="hljs-keyword">if</span> (cur.next == root || cur.count + <span class="hljs-number">1</span> &lt; nxt.count)&#123;<br>                <span class="hljs-comment">//insert 中的 this 就是当前对象所指向的 Node 即此处的 cur; 插入完成后返回的是当前字符串所对应的最新链表节点</span><br>                nodes.put(key, cur.insert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, cur.count + <span class="hljs-number">1</span>)));<br>            &#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//说明原先cur.count 与 nxt.count 差 1，现在即相等，直接合并</span><br>                nxt.keys.add(key);<br>                nodes.put(key, nxt);<br>            &#125;<br>            cur.keys.remove(key);<br>            <span class="hljs-keyword">if</span> (cur.keys.isEmpty())&#123;<br>                cur.remove();<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (root.next == root || root.next.count &gt; <span class="hljs-number">1</span>)&#123;<br>                nodes.put(key, root.insert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, <span class="hljs-number">1</span>)));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                root.next.keys.add(key);<br>                nodes.put(key, root.next);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dec</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nodes.get(key);<br>        <span class="hljs-keyword">if</span> (cur.count == <span class="hljs-number">1</span>)&#123;            <span class="hljs-comment">//key 仅出现一次的情况单另处理</span><br>            nodes.remove(key);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> cur.prev;<br>            <span class="hljs-keyword">if</span> (pre == root || cur.count - <span class="hljs-number">1</span> &gt; pre.count)&#123;<br>                nodes.put(key, pre.insert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, cur.count - <span class="hljs-number">1</span>)));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pre.keys.add(key);<br>                nodes.put(key, pre);<br>            &#125;<br>        &#125;<br>        cur.keys.remove(key);<br>        <span class="hljs-keyword">if</span> (cur.keys.isEmpty())&#123;<br>            cur.remove();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMaxKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> root.prev != <span class="hljs-literal">null</span> ? root.prev.keys.iterator().next() : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMinKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> root.next != <span class="hljs-literal">null</span> ? root.next.keys.iterator().next() : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your AllOne object will be instantiated and called as such:</span><br><span class="hljs-comment"> * AllOne obj = new AllOne();</span><br><span class="hljs-comment"> * obj.inc(key);</span><br><span class="hljs-comment"> * obj.dec(key);</span><br><span class="hljs-comment"> * String param_3 = obj.getMaxKey();</span><br><span class="hljs-comment"> * String param_4 = obj.getMinKey();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a>146. LRU 缓存</h2><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。</p><p>实现 LRUCache 类：</p><p>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</p><p>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</p><p>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</p><p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p>示例：</p><p>输入</p><p>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]</p><p>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</p><p>输出</p><p>[null, null, null, 1, null, -1, null, -1, 3, 4]</p><p>解释<br>LRUCache lRUCache &#x3D; new LRUCache(2);</p><p>lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 {1&#x3D;1}</p><p>lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 {1&#x3D;1, 2&#x3D;2}</p><p>lRUCache.get(1);    &#x2F;&#x2F; 返回 1</p><p>lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 {1&#x3D;1, 3&#x3D;3}</p><p>lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</p><p>lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 {4&#x3D;4, 3&#x3D;3}</p><p>lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</p><p>lRUCache.get(3);    &#x2F;&#x2F; 返回 3</p><p>lRUCache.get(4);    &#x2F;&#x2F; 返回 4</p><p>提示：</p><p>1 &lt;&#x3D; capacity &lt;&#x3D; 3000</p><p>0 &lt;&#x3D; key &lt;&#x3D; 10000</p><p>0 &lt;&#x3D; value &lt;&#x3D; 105</p><p>最多调用 2 * 10^5 次 get 和 put</p><h3 id="衡量-最久未使用-的标准仅一个：时间上最早进缓存却一直未使用的-Key"><a href="#衡量-最久未使用-的标准仅一个：时间上最早进缓存却一直未使用的-Key" class="headerlink" title="衡量 最久未使用 的标准仅一个：时间上最早进缓存却一直未使用的 Key"></a>衡量 最久未使用 的标准仅一个：时间上最早进缓存却一直未使用的 Key</h3><ul><li>每一次操作都使得被操作节点移到最前面，链表从前往后代表使用关键字的频率从高到低</li><li>和 LinkedHashMap 都使用头插法，超出缓存时删除尾节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>            Node prev, next;<br>            <span class="hljs-type">int</span> key, value;<br><br>            Node(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> val)&#123;<br>                key = k;value = val;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> capacity, size;<br>        Map&lt;Integer, Node&gt; nodes;         <span class="hljs-comment">//(关键字，链表节点)</span><br>        Node head, tail;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>            <span class="hljs-built_in">this</span>.capacity = capacity;<br>            size = <span class="hljs-number">0</span>;<br>            nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1000</span>,-<span class="hljs-number">1000</span>);<br>            tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1000</span>,-<span class="hljs-number">1000</span>);<br>            head.next = tail;<br>            tail.prev = head;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>            <span class="hljs-keyword">if</span> (!nodes.containsKey(key)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nodes.get(key);<br>            moveToTail(cur);<br>            <span class="hljs-keyword">return</span> cur.value;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nodes.get(key);<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)&#123;                  <span class="hljs-comment">//如果key不存在，创建新节点</span><br>                <span class="hljs-type">Node</span> <span class="hljs-variable">new_node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);<br>                addToTail(new_node);<br>                nodes.put(key, new_node);<br>                size++;<br>                <span class="hljs-keyword">if</span> (size &gt; capacity)&#123;           <span class="hljs-comment">//删除当前链表的头节点</span><br>                    <span class="hljs-type">Node</span> <span class="hljs-variable">del</span> <span class="hljs-operator">=</span> removeHead();<br>                    nodes.remove(del.key);<br>                    size--;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;                             <span class="hljs-comment">//若存在，修改值即可，不用走 size 的流程</span><br>                node.value = value;<br>                moveToTail(node);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToTail</span><span class="hljs-params">(Node node)</span>&#123;    <span class="hljs-comment">//怕先后顺序出错，就先把 node 给处理了</span><br>            node.next = tail;<br>            node.prev = tail.prev;<br>            tail.prev.next = node;<br>            tail.prev = node;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Node node)</span>&#123;<br>            node.prev.next = node.next;<br>            node.next.prev = node.prev;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToTail</span><span class="hljs-params">(Node node)</span>&#123;<br>            remove(node);<br>            addToTail(node);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">removeHead</span><span class="hljs-params">()</span>&#123;               <span class="hljs-comment">//便于在 nodes 中删除节点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head.next;<br>            head.next = res.next;<br>            res.next.prev = head;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="460-LFU-缓存"><a href="#460-LFU-缓存" class="headerlink" title="460. LFU 缓存"></a>460. LFU 缓存</h2><p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p><p>实现 LFUCache 类：</p><p>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象</p><p>int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。</p><p>void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。</p><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p><p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p>示例：</p><p>输入：</p><p>[“LFUCache”, “put”, “put”, “get”, “put”, “get”, “get”, “put”, “get”, “get”, “get”]</p><p>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]</p><p>输出：</p><p>[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</p><p>解释：</p><p>&#x2F;&#x2F; cnt(x) &#x3D; 键 x 的使用计数</p><p>&#x2F;&#x2F; cache&#x3D;[] 将显示最后一次使用的顺序（最左边的元素是最近的）</p><p>LFUCache lfu &#x3D; new LFUCache(2);</p><p>lfu.put(1, 1);   &#x2F;&#x2F; cache&#x3D;[1,_], cnt(1)&#x3D;1</p><p>lfu.put(2, 2);   &#x2F;&#x2F; cache&#x3D;[2,1], cnt(2)&#x3D;1, cnt(1)&#x3D;1</p><p>lfu.get(1);      &#x2F;&#x2F; 返回 1<br>                 &#x2F;&#x2F; cache&#x3D;[1,2], cnt(2)&#x3D;1, cnt(1)&#x3D;2</p><p>lfu.put(3, 3);   &#x2F;&#x2F; 去除键 2 ，因为 cnt(2)&#x3D;1 ，使用计数最小<br>                 &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;1, cnt(1)&#x3D;2</p><p>lfu.get(2);      &#x2F;&#x2F; 返回 -1（未找到）</p><p>lfu.get(3);      &#x2F;&#x2F; 返回 3<br>                 &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;2, cnt(1)&#x3D;2</p><p>lfu.put(4, 4);   &#x2F;&#x2F; 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用<br>                 &#x2F;&#x2F; cache&#x3D;[4,3], cnt(4)&#x3D;1, cnt(3)&#x3D;2</p><p>lfu.get(1);      &#x2F;&#x2F; 返回 -1（未找到）</p><p>lfu.get(3);      &#x2F;&#x2F; 返回 3<br>                 &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;1, cnt(3)&#x3D;3</p><p>lfu.get(4);      &#x2F;&#x2F; 返回 4<br>                 &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;2, cnt(3)&#x3D;3</p><p>提示：</p><p>0 &lt;&#x3D; capacity &lt;&#x3D; 10^4</p><p>0 &lt;&#x3D; key &lt;&#x3D; 10^5</p><p>0 &lt;&#x3D; value &lt;&#x3D; 10^9</p><p>最多调用 2 * 105 次 get 和 put 方法</p><h3 id="两个维度衡量（双哈希表方法）"><a href="#两个维度衡量（双哈希表方法）" class="headerlink" title="两个维度衡量（双哈希表方法）"></a>两个维度衡量（双哈希表方法）</h3><ul><li><p>LFU 简单理解则是指「移除使用次数最少的元素」，如果存在多个使用次数最小的元素，则移除「最近不被使用的那个」（LRU 规则）</p></li><li><p>需要用哈希表存储每个元素的使用次数，以及同一使用次数的先后顺序。 -&gt; （次数，双向链表）</p><ul><li>另一个哈希表同 LRU 中的：（key, Node)</li></ul></li><li><p>在 O(1) 的复杂度内:「修改某个元素的使用次数」-&gt; 双向链表</p><ul><li>「找到使用次数最小的元素」-&gt; 维护一个 int 型的 minUsedFreq 方便哈希表直接提取</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 双哈希表：(key, Node) + (freq, DoubleLinkedList)</span><br><span class="hljs-comment">    * */</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>            Node prev, next;<br>            <span class="hljs-type">int</span> key, value, freq;<br>            Node()&#123;&#125;<br><br>            Node(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value, <span class="hljs-type">int</span> freq)&#123;<br>                <span class="hljs-built_in">this</span>.key = key;<br>                <span class="hljs-built_in">this</span>.value = value;<br>                <span class="hljs-built_in">this</span>.freq = freq;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedList</span>&#123;<br>            Node head, tail;<br>            DoubleLinkedList()&#123;<br>                head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>                tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>                head.next = tail;<br>                tail.prev = head;<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">return</span> head.next == tail;<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(Node node)</span>&#123;<br>                node.prev.next = node.next;<br>                node.next.prev = node.prev;<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(Node node)</span>&#123;<br>                node.prev = head;<br>                node.next = head.next;<br>                head.next = node;<br>                node.next.prev = node;<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">deleteTail</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> tail.prev;<br>                res.prev.next = tail;<br>                tail.prev = res.prev;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-type">int</span> capacity, size;<br>        Map&lt;Integer, Node&gt; nodes;                   <span class="hljs-comment">//(key, node)</span><br>        Map&lt;Integer, DoubleLinkedList&gt; map;         <span class="hljs-comment">//(freq, DoubleLinkedList)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minUsedFreq</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LFUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>            <span class="hljs-built_in">this</span>.capacity = capacity;<br>            size = <span class="hljs-number">0</span>;                               <span class="hljs-comment">//当前进入缓存的节点个数</span><br>            nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nodes.get(key);<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span> || capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            map.get(cur.freq).removeNode(cur);       <span class="hljs-comment">//原先频率的链表中移除当前节点</span><br>            <span class="hljs-keyword">if</span> (map.get(cur.freq).isEmpty() &amp;&amp; cur.freq == minUsedFreq)&#123;<br>                minUsedFreq++;<br>            &#125;<br>            cur.freq++;<br>            <span class="hljs-type">DoubleLinkedList</span> <span class="hljs-variable">dll</span> <span class="hljs-operator">=</span> map.getOrDefault(cur.freq, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleLinkedList</span>());<br>            dll.addToHead(cur);<br>            map.put(cur.freq, dll);       <span class="hljs-comment">//新频率下将当前节点头插</span><br>            <span class="hljs-keyword">return</span> cur.value;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>            <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nodes.get(key);<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>)&#123;                       <span class="hljs-comment">//仅对当前 key 进行 value 修改，不涉及缓存容量的增加</span><br>                cur.value = value;<br>                nodes.put(key, cur);                <span class="hljs-comment">//对 nodes 进行更新</span><br>                get(key);                           <span class="hljs-comment">//调用一次 get() 即可进行频率的更新</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (size == capacity)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> map.get(minUsedFreq).deleteTail();<br>                nodes.remove(tmp.key);<br>                size--;<br>            &#125;<br><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value, <span class="hljs-number">1</span>);<br>            minUsedFreq = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">DoubleLinkedList</span> <span class="hljs-variable">dll</span> <span class="hljs-operator">=</span> map.getOrDefault(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleLinkedList</span>());<br>            dll.addToHead(newNode);       <span class="hljs-comment">//新频率下将当前节点头插,三步需分开写</span><br>            map.put(<span class="hljs-number">1</span>, dll);<br><span class="hljs-comment">//            map.put(1, map.getOrDefault(1, new DoubleLinkedList()).addToHead(newNode));</span><br>            size++;<br>            nodes.put(key, newNode);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/0.%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/0.%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="704题-二分查找"><a href="#704题-二分查找" class="headerlink" title="704题 二分查找"></a>704题 二分查找</h2><p><code>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</code></p><ol><li>二分法时间复杂度为O(logn)，比一般的暴力o(n)要高效</li><li>只针对有序数组有效，若数组中有重复元素，则查找得到的下标不唯一。</li><li>根据边界条件分有两种写法：区间双闭、左闭右开。</li></ol><h3 id="区间双闭"><a href="#区间双闭" class="headerlink" title="区间双闭"></a>区间双闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span>(nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = nums.length;        <span class="hljs-comment">//右边界始终取不到</span><br><br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">if</span>(nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板题：-34. 在排序数组中查找元素的第一个和最后一个位置</p><ul><li>满足条件的写 l &#x3D; mid 或者 r &#x3D; mid;<ul><li>初始写 mid &#x3D; l + r &gt;&gt; 1, 如果 l &#x3D; mid,改为 mid &#x3D; l + r + 1 &gt;&gt; 1;</li><li>else对应的写法l &#x3D; mid对应r &#x3D; mid - 1，r &#x3D; mid对应l &#x3D; mid + 1</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/1.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/1.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="209题-长度最小的子数组"><a href="#209题-长度最小的子数组" class="headerlink" title="209题 长度最小的子数组"></a>209题 长度最小的子数组</h2><p><strong>对于全正整数数组和正整数target，求解加和 &gt;&#x3D; target 的最小连续子数组：</strong></p><h3 id="解法一：滑动窗口"><a href="#解法一：滑动窗口" class="headerlink" title="解法一：滑动窗口"></a>解法一：滑动窗口</h3><ol><li>滑动窗口：不断调节子序列的起止位置，直至找到想要的结果</li><li>要想要最小：定义全局变量length，不断更新其值</li><li>当加和 &gt;&#x3D; target时才有可能考虑缩小窗口大小（将起点右移）</li><li>不是说for里面一个while循环就是o(n^2)的时间复杂度！！！主要看每一个元素被操作的次数，每个元素在滑动窗口中进去操作一次，出来一次，每个元素被操作两次，所以时间复杂度为o(2 * n)，即o(n)。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br><br><span class="hljs-comment">//right负责扩大窗口来使sum增大，left负责缩小窗口来让子数组最小</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,length = Integer.MAX_VALUE;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; nums.length; right++)&#123;<br>        sum += nums[right];<br>        <span class="hljs-keyword">while</span> (sum &gt;= target)&#123;<br>            length = Math.min(length,right - left + <span class="hljs-number">1</span>);<br>            sum -= nums[left++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> length == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : length;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法二：前缀和"><a href="#解法二：前缀和" class="headerlink" title="解法二：前缀和"></a>解法二：前缀和</h3><ol><li>新建一个数组sums，记录前i个元素和</li><li>找寻最小的sums[j] - sums[i] &gt;&#x3D; target</li><li>调用java自带的二分查找方法,但其返回值对应多种情况</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><br>    <span class="hljs-comment">//为了方便计算</span><br>    <span class="hljs-comment">//sums[i] : 前i个元素和</span><br><br>    <span class="hljs-type">int</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    sums[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        sums[i] = sums[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">//sums[j] - sums[i] &gt;= target,则return.这里s就是sums[j]</span><br>    <span class="hljs-comment">//要找的数不在数组中，但在数组范围内，从1开始计数，返回&#x27;-插入点索引&#x27;.</span><br>    <span class="hljs-comment">//如1，3，5，7中找4，返回-3，第一个if处理后的2即为第一个&gt;=4的数值索引</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> target + sums[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> Arrays.binarySearch(sums,s);<br>        <span class="hljs-keyword">if</span> (bound &lt; <span class="hljs-number">0</span>)&#123;<br>            bound = -bound - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (bound &lt;= n)&#123;<br>            length = Math.min(length,bound - (i - <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> length == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : length;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来讲binarySearsh(int[] nums, int target):</p><p><a href="https://blog.csdn.net/wanderlustLee/article/details/79208630">https://blog.csdn.net/wanderlustLee/article/details/79208630</a></p><ol><li>若target是数组当中的元素，从0开始计数，返回其索引值。</li><li>若target不是，将其插入排好序的nums中，从1开始计数，返回‘-插入点索引值’。如果所有值都比target大，返回-1；所有值都比target小，返回 -(length + 1).</li><li>该代码中第一个if判断是为了返回第一个大于target的元素索引值。</li><li>手动实现二分查找：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearsh</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = nums.length;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid;<br>        &#125;<span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="904题-水果成篮"><a href="#904题-水果成篮" class="headerlink" title="904题 水果成篮"></a>904题 水果成篮</h2><p><strong>求解仅包含两种元素的最长连续子序列：</strong></p><ol><li>滑动窗口，left只做一件事：当集合中大于两种元素时的删除工作。</li><li>right即i不断向右滑动，每个元素都被加入集合；哈希表记录值和对应的个数</li><li>子序列长度不用索引值相减的形式，而是让len++;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalFruit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] fruits)</span> &#123;<br>    Map&lt;Integer, Integer&gt; basket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,result = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fruits.length; i++)&#123;<br>        basket.put(fruits[i], basket.getOrDefault(fruits[i],<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        len++;<br><br>        <span class="hljs-keyword">while</span> (basket.size() &gt;= <span class="hljs-number">3</span>)&#123;<br>            basket.put(fruits[left], basket.get(fruits[left]) - <span class="hljs-number">1</span>);  <span class="hljs-comment">//去除工作单另找个变量left来完成</span><br>            <span class="hljs-keyword">if</span> (basket.get(fruits[left]) == <span class="hljs-number">0</span>)&#123;<br>                basket.remove(fruits[left]);<br>            &#125;<br>            left++;<br>            len--;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (result &lt; len)&#123;<br>            result = len;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a>1004. 最大连续1的个数 III</h2><p>给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,1,0,0,0,1,1,1,1,0], K &#x3D; 2</p><p>输出：6</p><p>解释：[1,1,1,0,0,1,1,1,1,1,1]</p><p>粗体数字从 0 翻转到 1，最长的子数组长度为 6。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</p><p>nums[i] 不是 0 就是 1</p><p>0 &lt;&#x3D; k &lt;&#x3D; nums.length</p><h3 id="动态规划-gt-二分查找-gt-滑动窗口"><a href="#动态规划-gt-二分查找-gt-滑动窗口" class="headerlink" title="动态规划 -&gt; 二分查找 -&gt; 滑动窗口"></a>动态规划 -&gt; 二分查找 -&gt; 滑动窗口</h3><ul><li><p>动态规划：（dp[i][j]：以 i 结尾(包括 i)数组在最大翻转次数为 j 时，连续1的最大长度）</p><ul><li><p>nums[i] 本身为 1，无需翻转，dp[i][j] &#x3D; dp[i - 1][j] + 1;</p></li><li><p>nums[i] 不为 1 时，必须翻转，dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</p></li><li><p>时间复杂度为 O(nk)，根据给定的数据范围来看会超时</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][k + <span class="hljs-number">1</span>];     <span class="hljs-comment">//对于 i 而言，结果只与前一个有关，可以压缩数组节省空间</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)&#123;<br>                dp[i &amp; <span class="hljs-number">1</span>][j] = dp[(i - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i &amp; <span class="hljs-number">1</span>][j] = dp[(i - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>前缀和 + 二分查找：</p><ul><li><p>最大翻转次数不超过 k -&gt; 找出一段连续区间[l,r]，使得区间中出现 0 的个数不超过 K</p></li><li><p>快速判断区间中 0 的个数 -&gt; 前缀和数组：区间长度 len - 区间和 total (1 的个数) &#x3D; 0 的个数！</p></li><li><p>数组中无负权值，前缀和数组呈现<strong>单调性</strong>，必然一段满足 len - total &lt;&#x3D; k，另一段不满足。<strong>二段性</strong></p></li><li><p>时间复杂度 O(nlogn)</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];           <span class="hljs-comment">//前缀和数组，第0个不用</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;          <span class="hljs-comment">//枚举区间右边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = j;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + right &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(check(sum, mid, j, k))&#123;  <span class="hljs-comment">//区间右边界j已定的情况下，二分查找左边界，求满足 0 的个数不超过 K 的最大区间长度</span><br>                right = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(check(sum, left, j, k)) ans = Math.max(ans, j - left + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sum, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> sum[r + <span class="hljs-number">1</span>] - sum[l], len = r - l + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> len - total &lt;= k;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>滑动窗口：不显示的构造计算前缀和数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//求解包含 0 的个数不超过 k 的最大窗口长度</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = nums.length;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[j] == <span class="hljs-number">0</span>) sum++;<br>        <span class="hljs-keyword">while</span>(sum &gt; k)&#123;<br>            sum -= nums[i++] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        ans = Math.max(ans, j - i + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类似题：2024.考试的最大困扰度</li></ul>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>纯模拟</title>
    <link href="/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/2.%E6%A8%A1%E6%8B%9F%E8%A1%8C%E4%B8%BA/"/>
    <url>/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/2.%E6%A8%A1%E6%8B%9F%E8%A1%8C%E4%B8%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="59题-螺旋矩阵II"><a href="#59题-螺旋矩阵II" class="headerlink" title="59题 螺旋矩阵II"></a>59题 螺旋矩阵II</h2><p>给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix</p><ol><li>这种题不考察算法，只看模拟。要遵循循环不变量原则：即每个边界得是一致的左闭右开。</li></ol><p>严格模拟旋转的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;                      <span class="hljs-comment">//每次填进去的数字</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">startX</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,startY = <span class="hljs-number">0</span>;        <span class="hljs-comment">//每一圈的起始位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">loop</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>;                 <span class="hljs-comment">//循环次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;                   <span class="hljs-comment">//每一圈循环控制每一条边的遍历长度</span><br>    <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>;                 <span class="hljs-comment">//因为次数是取整，n为奇数时矩阵最中间的位置需单另赋值</span><br>    <span class="hljs-keyword">while</span> (loop &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startX;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> startY;<br><br>        <span class="hljs-keyword">for</span> (; j &lt; startY + n - offset; j++)&#123;<br>            matrix[startX][j] = num++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (; i &lt; startX + n - offset; i++)&#123;<br>            matrix[i][j] = num++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (; j &gt; startY; j--)&#123;<br>            matrix[i][j] = num++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (; i &gt; startX; i--)&#123;<br>            matrix[i][j] = num++;<br>        &#125;<br><br>        loop--;<br>        offset += <span class="hljs-number">2</span>;              <span class="hljs-comment">//一圈下来，所能遍历的长度减2</span><br>        startX += <span class="hljs-number">1</span>;<br>        startY += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>        matrix[mid][mid] = num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>双闭的写法，更清爽</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-keyword">return</span> Order(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n],n);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] Order(<span class="hljs-type">int</span>[][] matrix,<span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,bottom = n - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> n * n;<br>    <span class="hljs-keyword">while</span> (total &gt; <span class="hljs-number">0</span>)&#123;<br><br>        <span class="hljs-comment">//每一个循环里也要判断total，以防重复</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right &amp;&amp; total &gt; <span class="hljs-number">0</span>; i++)&#123;<br>            matrix[top][i] = value++;<br>            total--;<br>        &#125;<br>        top++;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom &amp;&amp; total &gt; <span class="hljs-number">0</span>; i++)&#123;<br>            matrix[i][right] = value++;<br>            total--;<br>        &#125;<br>        right--;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left &amp;&amp; total &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            matrix[bottom][i] = value++;<br>            total--;<br>        &#125;<br>        bottom--;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top &amp;&amp; total &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            matrix[i][left] = value++;<br>            total--;<br>        &#125;<br>        left++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/3.%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    <url>/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/3.%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖</p><h2 id="27题-移除元素"><a href="#27题-移除元素" class="headerlink" title="27题 移除元素"></a>27题 移除元素</h2><p><code>要求删除数组中等于val的元素，不使用额外数组空间，数组元素顺序可以改变，只需返回新数组的长度。</code></p><p>用快指针fast指向当前要处理的元素，用慢指针slow指向下一个将要被修改的位置：</p><ol><li>若fast指向的元素 &#x3D;&#x3D; val，slow不动等待被修改，fast照常加一去寻找不等于val的元素。</li><li>若fast指向的元素 !&#x3D; val，将fast指向元素的值赋给slow指向的元素，各自加一。</li></ol><p><code>整个过程不变的是：[0，left)内的元素均不等于val，fast指针遍历完成后返回slow的值即为数组的大小。</code></p><p>最坏的情况下（即数组中没有等于val的元素），两个指针给遍历数组一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; n; right++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[right] != val) &#123;<br>            nums[left] = nums[right];<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双指针优化：避免需要保留元素的重复赋值操作"><a href="#双指针优化：避免需要保留元素的重复赋值操作" class="headerlink" title="双指针优化：避免需要保留元素的重复赋值操作"></a>双指针优化：避免需要保留元素的重复赋值操作</h3><p>如果要移除的元素恰好在数组开头，那需要把所有元素都左移一位，不如让左右指针位于数组的首尾，向中间移动遍历该序列。</p><ol><li>若left所指元素 &#x3D;&#x3D; val，将right所指元素复制到left所指位置，right左移继续判断left所指元素是否等于val，直到left所指元素值不等于val为止。</li><li>当左右指针重合时即遍历完数组了，最坏的情况下两个指针合起来也只遍历数组一次。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">if</span>(nums[left] == val)&#123;<br>            nums[left] == nums[right - <span class="hljs-number">1</span>];<br>            right--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="844题-比较含退格的字符串"><a href="#844题-比较含退格的字符串" class="headerlink" title="844题 比较含退格的字符串"></a>844题 比较含退格的字符串</h2><p><code>需要空间复杂度为O(1)，即选择双指针</code></p><ol><li>一个字符是否应该被删除，取决于其后的退格符，所以逆序遍历来确定当前字符是否应该被删掉</li><li>用skip表示当前待删除的字符数量，当遇到skip &#x3D; 0且是非#字符时，就去做比较</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backspaceCompare1</span><span class="hljs-params">(String s, String t)</span> &#123;<br><br><span class="hljs-comment">//必须分开定义，因为跳出while循环的情况除了break还有i&lt;0。只有从break跳出的才会skip为0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">skip1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,skip2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>, j = t.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>; i--,j--)&#123;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                skip1++;<br>                i--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skip1 &gt; <span class="hljs-number">0</span>)&#123;         <span class="hljs-comment">//非#字符，但还有待删的元素，先后退了再说</span><br>                skip1--;<br>                i--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;                <span class="hljs-comment">//删完了，跳出while去比较</span><br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span> (t.charAt(j) == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                skip2++;<br>                j--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skip2 &gt; <span class="hljs-number">0</span>)&#123;<br>                skip2--;<br>                j--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;              <span class="hljs-comment">//两个字符串都没走到头才能进行比较</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) != t.charAt(j)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)&#123;       <span class="hljs-comment">//如果有其中一个提前走到头，说明长度不一致，肯定无法相等</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="209题-长度最小的子数组"><a href="#209题-长度最小的子数组" class="headerlink" title="209题 长度最小的子数组"></a>209题 长度最小的子数组</h2><p><code>对于全正整数数组和正整数target，求解加和 &gt;= target 的最小连续子数组：</code></p><ol><li>滑动窗口：不断调节子序列的起止位置，直至找到想要的结果</li><li>要想要最小：定义全局变量length，不断更新其值</li><li>当加和 &gt;&#x3D; target时才有可能考虑缩小窗口大小（将起点右移）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br><br><span class="hljs-comment">//right负责扩大窗口来使sum增大，left负责缩小窗口来让子数组最小</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,length = Integer.MAX_VALUE;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; nums.length; right++)&#123;<br>        sum += nums[right];<br>        <span class="hljs-keyword">while</span> (sum &gt;= target)&#123;<br>            length = Math.min(length,right - left + <span class="hljs-number">1</span>);<br>            sum -= nums[left++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> length == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : length;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>不是说for里面一个while循环就是o(n^2)的时间复杂度！！！主要看每一个元素被操作的次数，每个元素在滑动窗口中进去操作一次，出来一次，每个元素被操作两次，所以时间复杂度为o(2 * n)，即o(n)。</li></ol>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多维排序</title>
    <link href="/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/4.%E5%A4%9A%E7%BB%B4%E6%8E%92%E5%BA%8F/"/>
    <url>/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/4.%E5%A4%9A%E7%BB%B4%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序分组计数应用题"><a href="#排序分组计数应用题" class="headerlink" title="排序分组计数应用题"></a>排序分组计数应用题</h1><h2 id="1996-游戏中弱角色的数量"><a href="#1996-游戏中弱角色的数量" class="headerlink" title="1996.游戏中弱角色的数量"></a>1996.游戏中弱角色的数量</h2><p>你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] &#x3D; [attacki, defensei] 表示游戏中第 i 个角色的属性。</p><p>如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackj &gt; attacki 且 defensej &gt; defensei 。</p><p>返回 弱角色 的数量。</p><p>示例 1：</p><p>输入：properties &#x3D; [[5,5],[6,3],[3,6]]</p><p>输出：0</p><p>解释：不存在攻击和防御都严格高于其他角色的角色。</p><p>示例 2：</p><p>输入：properties &#x3D; [[2,2],[3,3]]</p><p>输出：1</p><p>解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</p><p>示例 3：</p><p>输入：properties &#x3D; [[1,5],[10,4],[4,3]]</p><p>输出：1</p><p>解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</p><p>提示：</p><p>2 &lt;&#x3D; properties.length &lt;&#x3D; 10^5</p><p>properties[i].length &#x3D;&#x3D; 2</p><p>1 &lt;&#x3D; attacki, defensei &lt;&#x3D; 10^5</p><p><strong>思路：</strong></p><p>对于每个角色，只需找到一个 攻击力和防御力 都比其高的角色，即可认定该角色为弱角色。</p><p>如果按照角色某一属性如攻击力 由大到小 的顺序进行遍历，并记录 防御力 的最大值 Max。若当前角色 p 的防御力 严格小于 Max，那么说明存在防御值比 p 高的角色（记作 q），如果此时 q 的攻击值也严格大于 p，则可以确定 p 为弱角色。</p><p><strong>难点在于 如何同时保证严格大于，因为有攻击力相同的角色。</strong></p><p>法1. 将攻击力相同的单独分一组，分开比较。</p><p>法2. 将数组按 “攻击力降序排序，当攻击力相同时按防御力升序排列” 的方式排序，由此从前往后遍历时：</p><ul><li><p>可以保证当前已经遍历过的最大防御值角色 q 的防御值 maxDef 严格大于当前角色 p 的防御值时，则此时 q 的攻击值一定严格大于 p 的攻击值</p></li><li><p>因为和 P 相同攻击值，防御力 还比 p 高的角色 一定在 p 之后被遍历到。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfWeakCharacters</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] properties)</span> &#123;<br>        Arrays.sort(properties, (o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] == o2[<span class="hljs-number">0</span>] ? (o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>]) : (o2[<span class="hljs-number">0</span>] - o1[<span class="hljs-number">0</span>]);<br>        &#125;);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDef</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : properties) &#123;<br>            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">1</span>] &lt; maxDef) &#123;<br>                ans++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                maxDef = p[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于两个维度，往不同方向的排序上去想。若要找到所有彼此之间严格大于的，就是“套娃”问题了也即 LIS　问题，见贪心：</p><ul><li>300.最长上升子序列</li><li>354.俄罗斯套娃信封问题</li><li>面试题 08.13. 堆箱子</li><li>面试题 17.08. 马戏团人塔</li></ul>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>修改与查询</title>
    <link href="/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/5.%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9F%A5%E8%AF%A2/"/>
    <url>/earsh9.github.io/2022/08/04/1.%E6%95%B0%E7%BB%84/5.%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="单点修改-与-区间查询"><a href="#单点修改-与-区间查询" class="headerlink" title="单点修改 与 区间查询"></a>单点修改 与 区间查询</h1><ul><li>单点修改：更改数组中一个元素的值</li><li>区间查询：查询一个区间内所有元素的和</li></ul><p><strong>一般性情况：</strong></p><p>（加粗字体为最佳方案）：</p><ul><li>数组不变，区间查询：<strong>前缀和</strong>、树状数组、线段树；</li><li>数组单点修改，区间查询：<strong>树状数组</strong>、线段树；（详见其他-3.树状数组和线段树)</li><li>数组区间修改，单点查询：<strong>差分</strong>、线段树；</li><li>数组区间修改，区间查询：<strong>线段树</strong>。</li></ul><p>对于普通数组，单点修改 O(1)，区间查询 O(n)</p><h2 id="1-前缀和数组"><a href="#1-前缀和数组" class="headerlink" title="1. 前缀和数组"></a>1. 前缀和数组</h2><p>适用场景：原始数组不被修改的情况下，频繁查询某个区间的累加和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><span class="hljs-type">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <span class="hljs-comment">//以 i 结尾（包括 i ）的区间和</span><br>pre[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>    pre[i] = pre[i - <span class="hljs-number">1</span>] + nums[i];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>任意区间 (i,j] 的和：pre[j] - pre[i]。<strong>O(1)</strong></li><li>单点修改：该点及以后的 pre 数组均需修改。<strong>O(n)</strong><ul><li>若持续修改 n 个点，时间复杂度上升到 <strong>O(n^2)</strong></li></ul></li></ul><p>相关题：-剑指 Offer II 010. 和为 k 的子数组（使用Map优化记录前缀和出现的次数）</p><h2 id="2-差分数组：解决频繁对数组区间进行增减的情况"><a href="#2-差分数组：解决频繁对数组区间进行增减的情况" class="headerlink" title="2. 差分数组：解决频繁对数组区间进行增减的情况"></a>2. 差分数组：解决频繁对数组区间进行增减的情况</h2><ul><li>构造差分数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br><span class="hljs-comment">// 构造差分数组</span><br>    diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        diff[i] = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><img src = "https://labuladong.gitee.io/algo/images/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/2.jpeg" width = "50%"><ul><li>还原原始数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[diff.length];<br><span class="hljs-comment">// 根据差分数组构造结果数组</span><br>    res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; diff.length; i++) &#123;<br>        res[i] = res[i - <span class="hljs-number">1</span>] + diff[i];<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>进行区间增减，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] +&#x3D; 3，然后再让 diff[j+1] -&#x3D; 3 即可：</p><ul><li>差分数组是相邻元素作差，对一个区间里的数进行修改，只会影响差分数组中边界处的值</li></ul></li></ul><img src = "https://labuladong.gitee.io/algo/images/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/3.jpeg" width = "50%"><h3 id="1109-航班预订统计（区间修改，单点查询，模板题）"><a href="#1109-航班预订统计（区间修改，单点查询，模板题）" class="headerlink" title="1109. 航班预订统计（区间修改，单点查询，模板题）"></a>1109. 航班预订统计（区间修改，单点查询，模板题）</h3><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] &#x3D; [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</p><p>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><p>示例 1：</p><p>输入：bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5</p><p>输出：[10,55,45,25,25]</p><p>解释：</p><table><thead><tr><th>航班编号</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>预订记录1</td><td>10</td><td>10</td><td></td><td></td><td></td></tr><tr><td>预订记录2</td><td></td><td>20</td><td>20</td><td></td><td></td></tr><tr><td>预订记录3</td><td></td><td>25</td><td>25</td><td>25</td><td>25</td></tr><tr><td>总座位数</td><td>10</td><td>55</td><td>45</td><td>25</td><td>25</td></tr></tbody></table><p>因此，answer &#x3D; [10,55,45,25,25]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//本题即给定一个长度为 n 的数组 nums，其元素全为 0，进行一系列的区间加减操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] corpFlightBookings(<span class="hljs-type">int</span>[][] bookings, <span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-type">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bookings.length; i++)&#123;    <span class="hljs-comment">//航班编号从1开始，要进行减一操作</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> bookings[i][<span class="hljs-number">0</span>], to = bookings[i][<span class="hljs-number">1</span>], seats = bookings[i][<span class="hljs-number">2</span>];<br>        diff[from - <span class="hljs-number">1</span>] += seats;<br>        <span class="hljs-keyword">if</span>(to &lt; n) diff[to] -= seats;<br>    &#125;<br><br>    <span class="hljs-comment">//根据差分数组还原出结果数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        diff[i] += diff[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> diff;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的：</p><ul><li><p>798.得分最高的最小轮调（难点在于怎样转化成差分数组问题）</p></li><li><p>732.我的日程安排表 III（对于未知数据分布 &amp; 数据量很大，使用Map实现，重点在理解对一个区间内值进行修改，在差分数组中只会影响俩边界处的值）</p></li></ul><h2 id="前缀和（-二分查找）"><a href="#前缀和（-二分查找）" class="headerlink" title="前缀和（+ 二分查找）"></a>前缀和（+ 二分查找）</h2><h3 id="2055-蜡烛之间的盘子"><a href="#2055-蜡烛之间的盘子" class="headerlink" title="2055. 蜡烛之间的盘子"></a>2055. 蜡烛之间的盘子</h3><img src = "2055.蜡烛之间的盘子.png"><h4 id="前缀和-二分查找"><a href="#前缀和-二分查找" class="headerlink" title="前缀和 + 二分查找"></a>前缀和 + 二分查找</h4><ul><li>因为要查询任意给定区间 [a,b] 两边缘的蜡烛 [c,d] -&gt; 记录蜡烛的下标以便查找</li><li>查询区间 [c,d] 内的盘子数量                    -&gt; 盘子数量的前缀和数组</li><li>对于二分中 mid 写法的说明：<ul><li>如果循环中是 l &#x3D; mid，为避免 left 和 right 相邻时出现的死循环，需让 mid &#x3D; l + r + 1 &gt;&gt; 1;</li><li>即组合是 l &#x3D; mid,r &#x3D; mid - 1时用 mid &#x3D; l + r + 1 &gt;&gt; 1;</li><li>是 r &#x3D; mid, l &#x3D; mid + 1时用 mid &#x3D; l + r &gt;&gt; 1;就好</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] platesBetweenCandles(String s, <span class="hljs-type">int</span>[][] queries) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), m = queries.length;<br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>    <span class="hljs-type">char</span>[] ch = s.toCharArray();<br><br>    List&lt;Integer&gt; candles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();      <span class="hljs-comment">//记录蜡烛下标</span><br>    <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];                     <span class="hljs-comment">//记录盘子数量的前缀和数组,下标从 1 开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (ch[i] == <span class="hljs-string">&#x27;|&#x27;</span>) candles.add(i);<br>        sum[i + <span class="hljs-number">1</span>] = sum[i] + (ch[i] == <span class="hljs-string">&#x27;*&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(candles.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;            <span class="hljs-comment">//&quot;***&quot;,全盘子的情况！！</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">0</span>], b = queries[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, d = -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//找到 a 右边最近的蜡烛</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = candles.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (candles.get(mid) &gt;= a) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (candles.get(r) &gt;= a) c = candles.get(r);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">//找到 b 左边最近的蜡烛</span><br>        l = <span class="hljs-number">0</span>; r = candles.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (candles.get(mid) &lt;= b) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (candles.get(r) &lt;= b) d = candles.get(r);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (c &lt;= d) ans[i] = sum[d + <span class="hljs-number">1</span>] - sum[c];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="省去二分-gt-三个前缀和数组-（适合数据量少的情况）"><a href="#省去二分-gt-三个前缀和数组-（适合数据量少的情况）" class="headerlink" title="省去二分 -&gt; 三个前缀和数组 （适合数据量少的情况）"></a>省去二分 -&gt; 三个前缀和数组 （适合数据量少的情况）</h4><ul><li>更近一步，s 已经给定 -&gt; 每个位置其左边和右边最近的蜡烛唯一确定</li><li>在预处理前缀和的同时，预处理出每个位置左右最近的蜡烛下标 -&gt; 省去二分</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] platesBetweenCandles(String s, <span class="hljs-type">int</span>[][] queries) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), m = queries.length;<br>    <span class="hljs-type">char</span>[] ch = s.toCharArray();<br>    <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//向前和向后两次处理可以在一个循环中实现，注意要预设 p,q = -1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>, p = -<span class="hljs-number">1</span>, q = -<span class="hljs-number">1</span>; i &lt; n; i++, j--)&#123;<br>        <span class="hljs-keyword">if</span> (ch[i] == <span class="hljs-string">&#x27;|&#x27;</span>) p = i;<br>        <span class="hljs-keyword">if</span> (ch[j] == <span class="hljs-string">&#x27;|&#x27;</span>) q = j;<br>        left[i] = p;right[j] = q;           <span class="hljs-comment">//i 左边最近蜡烛下标为 p, j 右边最近蜡烛下标为 q</span><br>        sum[i + <span class="hljs-number">1</span>] = sum[i] + (ch[i] == <span class="hljs-string">&#x27;*&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">0</span>], b = queries[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> right[a], d = left[b];<br>        <span class="hljs-keyword">if</span> (c != -<span class="hljs-number">1</span> &amp;&amp; c &lt;= d) ans[i] = sum[d + <span class="hljs-number">1</span>] - sum[c];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="528-按权重随机选择（综合笔试题）"><a href="#528-按权重随机选择（综合笔试题）" class="headerlink" title="528. 按权重随机选择（综合笔试题）"></a>528. 按权重随机选择（综合笔试题）</h3><p>给你一个 下标从 0 开始 的正整数数组 w ，其中 w[i] 代表第 i 个下标的权重。</p><p>请你实现一个函数 pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1）选出并返回一个下标。选取下标 i 的 概率 为 w[i] &#x2F; sum(w) 。</p><p>例如，对于 w &#x3D; [1, 3]，挑选下标 0 的概率为 1 &#x2F; (1 + 3) &#x3D; 0.25 （即，25%），而选取下标 1 的概率为 3 &#x2F; (1 + 3) &#x3D; 0.75（即，75%）。</p><p>提示：</p><p>1 &lt;&#x3D; w.length &lt;&#x3D; 10^4</p><p>1 &lt;&#x3D; w[i] &lt;&#x3D; 10^5</p><p>pickIndex 将被调用不超过 10^4 次</p><p><strong>思路：</strong></p><ol><li>数据量不小，如何生成符合权重的序列？任意 i 有 w[i] 个</li><li>不能直接模拟 -&gt; 使用 <strong>前缀和数组</strong> 作为权重分布序列，基本单位为 1 -&gt; 二分查找对应的下标</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//随机数可以由 API 生成，我们只需生成符合权重的序列即可</span><br><span class="hljs-comment">//生成前缀和数组 sum，二分查找对应的下标</span><br><span class="hljs-type">int</span>[] sum;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Solution</span><span class="hljs-params">(<span class="hljs-type">int</span>[] w)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> w.length;<br>    sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    sum[<span class="hljs-number">0</span>] = w[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + w[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pickIndex</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sum.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * sum[n - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (sum[mid] &gt;= t) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LC刷题笔记</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>latex入门&amp;简历书写</title>
    <link href="/earsh9.github.io/2022/08/03/latex/"/>
    <url>/earsh9.github.io/2022/08/03/latex/</url>
    
    <content type="html"><![CDATA[<ul><li>使用的模板是 Github 上提供的：</li></ul><p><code>https://github.com/billryan/resume/tree/zh_CN</code></p><ul><li>简历上的话术参考：</li></ul><p><code>https://github.com/resumejob/awesome-resume</code></p><ul><li>overleaf 的官方讲解：</li></ul><p><code>https://www.overleaf.com/learn</code></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">很有用，这里主要参见的是上色部分，hhh根据官方的颜色编号给简历来点色彩<br></code></pre></td></tr></table></figure><ul><li>上色和调整行间距参考了这个小伙伴的：</li></ul><p><code>https://www.imbajin.com/recruit/2018-01-20-%E4%BD%BF%E7%94%A8Tex%E4%B9%A6%E5%86%99%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%80%E5%8E%86/</code></p><ul><li>出现包冲突问题</li></ul><p>因为没找见最新引入包的地方，所以用 \documentclass 暂时解决。相当于引入 宏包，使用宏包内的东西。</p><p><a href="https://zhuanlan.zhihu.com/p/76684599">https://zhuanlan.zhihu.com/p/76684599</a></p>]]></content>
    
    
    <categories>
      
      <category>备份</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
